{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar ComponentsNamespaceReference, HTMLJSExpander, REQUIRE_RENDERED_INSTANCE, SUPPORTS_REACTIVE_INSTANCE, addEvents, argumentsConstructor, bindComponent, bindDataContext, callTemplateBaseHooks, contentAsFunc, contentAsView, currentViewIfRendering, expand, expandView, getTemplateBase, getTemplateInstance, getTemplateInstanceFunction, method, methodName, originalDot, originalFlattenAttributes, originalGetTemplate, originalInclude, originalVisitTag, ref, registerFirstCreatedHook, registerHooks, templateInstanceToComponent, withTemplateInstanceFunc, wrapHelper, wrapViewAndTemplate,                \n  slice = [].slice,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\ngetTemplateInstance = function(view, skipBlockHelpers) {\n  while (view && !view._templateInstance) {\n    if (skipBlockHelpers) {\n      view = view.parentView;\n    } else {\n      view = view.originalParentView || view.parentView;\n    }\n  }\n  return view != null ? view._templateInstance : void 0;\n};\n\ntemplateInstanceToComponent = function(templateInstanceFunc, skipBlockHelpers) {\n  var templateInstance;\n  templateInstance = typeof templateInstanceFunc === \"function\" ? templateInstanceFunc() : void 0;\n  templateInstance = getTemplateInstance(templateInstance != null ? templateInstance.view : void 0, skipBlockHelpers);\n  while (templateInstance) {\n    if ('component' in templateInstance) {\n      return templateInstance.component;\n    }\n    if (skipBlockHelpers) {\n      templateInstance = getTemplateInstance(templateInstance.view.parentView, skipBlockHelpers);\n    } else {\n      templateInstance = getTemplateInstance(templateInstance.view.originalParentView || templateInstance.view.parentView, skipBlockHelpers);\n    }\n  }\n  return null;\n};\n\ngetTemplateInstanceFunction = function(view, skipBlockHelpers) {\n  var templateInstance;\n  templateInstance = getTemplateInstance(view, skipBlockHelpers);\n  return function() {\n    return templateInstance;\n  };\n};\n\nComponentsNamespaceReference = (function() {\n  function ComponentsNamespaceReference(namespace, templateInstance1) {\n    this.namespace = namespace;\n    this.templateInstance = templateInstance1;\n  }\n\n  return ComponentsNamespaceReference;\n\n})();\n\noriginalDot = Spacebars.dot;\n\nSpacebars.dot = function() {\n  var args, value;\n  value = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  if (value instanceof ComponentsNamespaceReference) {\n    return Blaze._getTemplate(value.namespace + \".\" + (args.join('.')), value.templateInstance);\n  }\n  return originalDot.apply(null, [value].concat(slice.call(args)));\n};\n\noriginalInclude = Spacebars.include;\n\nSpacebars.include = function() {\n  var args, templateOrFunction;\n  templateOrFunction = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  if (templateOrFunction instanceof ComponentsNamespaceReference) {\n    templateOrFunction = Blaze._getTemplate(templateOrFunction.namespace, templateOrFunction.templateInstance);\n  }\n  return originalInclude.apply(null, [templateOrFunction].concat(slice.call(args)));\n};\n\nBlaze._getTemplateHelper = function(template, name, templateInstance) {\n  var component, helper, isKnownOldStyleHelper, mixinOrComponent, ref, ref1, ref2;\n  isKnownOldStyleHelper = false;\n  if (template.__helpers.has(name)) {\n    helper = template.__helpers.get(name);\n    if (helper === Blaze._OLDSTYLE_HELPER) {\n      isKnownOldStyleHelper = true;\n    } else if (helper != null) {\n      return wrapHelper(bindDataContext(helper), templateInstance);\n    } else {\n      return null;\n    }\n  }\n  if (name in template) {\n    if (!isKnownOldStyleHelper) {\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n      if (!template._NOWARN_OLDSTYLE_HELPERS) {\n        Blaze._warn(\"Assigning helper with `\" + template.viewName + \".\" + name + \" = ...` is deprecated.  Use `\" + template.viewName + \".helpers(...)` instead.\");\n      }\n    }\n    if (template[name] != null) {\n      return wrapHelper(bindDataContext(template[name]), templateInstance);\n    } else {\n      return null;\n    }\n  }\n  if (!templateInstance) {\n    return null;\n  }\n  if ((ref = template.viewName) === 'Template.__dynamicWithDataContext' || ref === 'Template.__dynamic') {\n    return null;\n  }\n  component = Tracker.nonreactive(function() {\n    return templateInstanceToComponent(templateInstance, true);\n  });\n  if (component) {\n    if (mixinOrComponent = component.getFirstWith(null, name)) {\n      return wrapHelper(bindComponent(mixinOrComponent, mixinOrComponent[name]), templateInstance);\n    }\n  }\n  if (name && name in BlazeComponent.components) {\n    return new ComponentsNamespaceReference(name, templateInstance);\n  }\n  if (component) {\n    if ((helper = (ref1 = component._componentInternals) != null ? (ref2 = ref1.templateBase) != null ? ref2.__helpers.get(name) : void 0 : void 0) != null) {\n      return wrapHelper(bindDataContext(helper), templateInstance);\n    }\n  }\n  return null;\n};\n\nshare.inExpandAttributes = false;\n\nbindComponent = function(component, helper) {\n  if (_.isFunction(helper)) {\n    return function() {\n      var args, name, result, value;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      result = helper.apply(component, args);\n      if (share.inExpandAttributes && _.isObject(result)) {\n        for (name in result) {\n          value = result[name];\n          if (share.EVENT_HANDLER_REGEX.test(name)) {\n            if (_.isFunction(value)) {\n              result[name] = _.bind(value, component);\n            } else if (_.isArray(value)) {\n              result[name] = _.map(value, function(fun) {\n                if (_.isFunction(fun)) {\n                  return _.bind(fun, component);\n                } else {\n                  return fun;\n                }\n              });\n            }\n          }\n        }\n      }\n      return result;\n    };\n  } else {\n    return helper;\n  }\n};\n\nbindDataContext = function(helper) {\n  if (_.isFunction(helper)) {\n    return function() {\n      var data;\n      data = Blaze.getData();\n      if (data == null) {\n        data = {};\n      }\n      return helper.apply(data, arguments);\n    };\n  } else {\n    return helper;\n  }\n};\n\nwrapHelper = function(f, templateFunc) {\n  if (!Blaze.Template._withTemplateInstanceFunc) {\n    return Blaze._wrapCatchingExceptions(f, 'template helper');\n  }\n  if (!_.isFunction(f)) {\n    return f;\n  }\n  return function() {\n    var args, self;\n    self = this;\n    args = arguments;\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function() {\n      return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n    });\n  };\n};\n\nif (Blaze.Template._withTemplateInstanceFunc) {\n  withTemplateInstanceFunc = Blaze.Template._withTemplateInstanceFunc;\n} else {\n  withTemplateInstanceFunc = function(templateInstance, f) {\n    return f();\n  };\n}\n\ngetTemplateBase = function(component) {\n  return Tracker.nonreactive(function() {\n    var componentTemplate, templateBase;\n    componentTemplate = component.template();\n    if (_.isString(componentTemplate)) {\n      templateBase = Template[componentTemplate];\n      if (!templateBase) {\n        throw new Error(\"Template '\" + componentTemplate + \"' cannot be found.\");\n      }\n    } else if (componentTemplate) {\n      templateBase = componentTemplate;\n    } else {\n      throw new Error(\"Template for the component '\" + (component.componentName() || 'unnamed') + \"' not provided.\");\n    }\n    return templateBase;\n  });\n};\n\ncallTemplateBaseHooks = function(component, hookName) {\n  var callbacks, templateInstance;\n  if (component._componentInternals == null) {\n    component._componentInternals = {};\n  }\n  if (!component._componentInternals.templateInstance) {\n    return;\n  }\n  templateInstance = Tracker.nonreactive(function() {\n    return component._componentInternals.templateInstance();\n  });\n  callbacks = component._componentInternals.templateBase._getCallbacks(hookName);\n  Template._withTemplateInstanceFunc(function() {\n    return templateInstance;\n  }, function() {\n    var callback, i, len, results;\n    results = [];\n    for (i = 0, len = callbacks.length; i < len; i++) {\n      callback = callbacks[i];\n      results.push(callback.call(templateInstance));\n    }\n    return results;\n  });\n};\n\nwrapViewAndTemplate = function(currentView, f) {\n  var templateInstance;\n  templateInstance = getTemplateInstanceFunction(currentView, true);\n  return withTemplateInstanceFunc(templateInstance, function() {\n    return Blaze._withCurrentView(currentView, function() {\n      return f();\n    });\n  });\n};\n\naddEvents = function(view, component) {\n  var eventMap, events, eventsList, fn, handler, i, len, spec;\n  eventsList = component.events();\n  if (!_.isArray(eventsList)) {\n    throw new Error(\"'events' method from the component '\" + (component.componentName() || 'unnamed') + \"' did not return a list of event maps.\");\n  }\n  for (i = 0, len = eventsList.length; i < len; i++) {\n    events = eventsList[i];\n    eventMap = {};\n    fn = function(spec, handler) {\n      return eventMap[spec] = function() {\n        var args, currentView, event;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        event = args[0];\n        currentView = Blaze.getView(event.currentTarget);\n        wrapViewAndTemplate(currentView, function() {\n          return handler.apply(component, args);\n        });\n      };\n    };\n    for (spec in events) {\n      handler = events[spec];\n      fn(spec, handler);\n    }\n    Blaze._addEventMap(view, eventMap, view);\n  }\n};\n\noriginalGetTemplate = Blaze._getTemplate;\n\nBlaze._getTemplate = function(name, templateInstance) {\n  var template;\n  template = Tracker.nonreactive(function() {\n    var parentComponent, ref;\n    if (Blaze.currentView) {\n      parentComponent = BlazeComponent.currentComponent();\n    } else {\n      parentComponent = templateInstanceToComponent(templateInstance, false);\n    }\n    return (ref = BlazeComponent.getComponent(name)) != null ? ref.renderComponent(parentComponent) : void 0;\n  });\n  if (template && (template instanceof Blaze.Template || _.isFunction(template))) {\n    return template;\n  }\n  return originalGetTemplate(name);\n};\n\nregisterHooks = function(template, hooks) {\n  if (template.onCreated) {\n    template.onCreated(hooks.onCreated);\n    template.onRendered(hooks.onRendered);\n    return template.onDestroyed(hooks.onDestroyed);\n  } else {\n    template.created = hooks.onCreated;\n    template.rendered = hooks.onRendered;\n    return template.destroyed = hooks.onDestroyed;\n  }\n};\n\nregisterFirstCreatedHook = function(template, onCreated) {\n  var oldCreated;\n  if (template._callbacks) {\n    return template._callbacks.created.unshift(onCreated);\n  } else {\n    oldCreated = template.created;\n    return template.created = function() {\n      onCreated.call(this);\n      return oldCreated != null ? oldCreated.call(this) : void 0;\n    };\n  }\n};\n\nTemplate.__dynamicWithDataContext.__helpers.set('chooseTemplate', function(name) {\n  return Blaze._getTemplate(name, (function(_this) {\n    return function() {\n      return Template.instance();\n    };\n  })(this));\n});\n\nargumentsConstructor = function() {\n  return assert(false);\n};\n\nTemplate.registerHelper('args', function() {\n  var obj;\n  obj = {};\n  obj.constructor = argumentsConstructor;\n  obj._arguments = arguments;\n  return obj;\n});\n\nshare.EVENT_HANDLER_REGEX = /^on[A-Z]/;\n\nshare.isEventHandler = function(fun) {\n  return _.isFunction(fun) && fun.eventHandler;\n};\n\noriginalFlattenAttributes = HTML.flattenAttributes;\n\nHTML.flattenAttributes = function(attrs) {\n  var name, value;\n  if (attrs = originalFlattenAttributes(attrs)) {\n    for (name in attrs) {\n      value = attrs[name];\n      if (!(share.EVENT_HANDLER_REGEX.test(name))) {\n        continue;\n      }\n      if (share.isEventHandler(value)) {\n        continue;\n      }\n      if (_.isArray(value) && _.some(value, share.isEventHandler)) {\n        continue;\n      }\n      if (_.isArray(value)) {\n        attrs[name] = _.map(value, Spacebars.event);\n      } else {\n        attrs[name] = Spacebars.event(value);\n      }\n    }\n  }\n  return attrs;\n};\n\nSpacebars.event = function() {\n  var args, eventHandler, fun;\n  eventHandler = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  if (!_.isFunction(eventHandler)) {\n    throw new Error(\"Event handler not a function: \" + eventHandler);\n  }\n  args = Spacebars.mustacheImpl.apply(Spacebars, [(function() {\n    var xs;\n    xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return xs;\n  })].concat(slice.call(args)));\n  fun = function() {\n    var currentView, event, eventArgs;\n    event = arguments[0], eventArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    currentView = Blaze.getView(event.currentTarget);\n    return wrapViewAndTemplate(currentView, function() {\n      return eventHandler.apply(null, [event].concat(args, eventArgs));\n    });\n  };\n  fun.eventHandler = true;\n  return fun;\n};\n\noriginalVisitTag = HTML.ToHTMLVisitor.prototype.visitTag;\n\nHTML.ToHTMLVisitor.prototype.visitTag = function(tag) {\n  var attrs, name;\n  if (attrs = tag.attrs) {\n    attrs = HTML.flattenAttributes(attrs);\n    for (name in attrs) {\n      if (share.EVENT_HANDLER_REGEX.test(name)) {\n        delete attrs[name];\n      }\n    }\n    tag.attrs = attrs;\n  }\n  return originalVisitTag.call(this, tag);\n};\n\ncurrentViewIfRendering = function() {\n  var view;\n  view = Blaze.currentView;\n  if (view != null ? view._isInRender : void 0) {\n    return view;\n  } else {\n    return null;\n  }\n};\n\ncontentAsFunc = function(content) {\n  if (!_.isFunction(content)) {\n    return function() {\n      return content;\n    };\n  }\n  return content;\n};\n\ncontentAsView = function(content) {\n  if (content instanceof Blaze.Template) {\n    return content.constructView();\n  } else if (content instanceof Blaze.View) {\n    return content;\n  } else {\n    return Blaze.View('render', contentAsFunc(content));\n  }\n};\n\nHTMLJSExpander = Blaze._HTMLJSExpander.extend();\n\nHTMLJSExpander.def({\n  visitObject: function(x) {\n    if (x instanceof Blaze.Template) {\n      x = x.constructView();\n    }\n    if (x instanceof Blaze.View) {\n      return expandView(x, this.parentView);\n    }\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  }\n});\n\nexpand = function(htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new HTMLJSExpander({\n    parentView: parentView\n  })).visit(htmljs);\n};\n\nexpandView = function(view, parentView) {\n  var htmljs, result;\n  Blaze._createView(view, parentView, true);\n  view._isInRender = true;\n  htmljs = Blaze._withCurrentView(view, function() {\n    return view._render();\n  });\n  view._isInRender = false;\n  Tracker.flush();\n  result = expand(htmljs, view);\n  Tracker.flush();\n  if (Tracker.active) {\n    Tracker.onInvalidate(function() {\n      return Blaze._destroyView(view);\n    });\n  } else {\n    Blaze._destroyView(view);\n  }\n  Tracker.flush();\n  return result;\n};\n\nBlazeComponent = (function(superClass) {\n  extend(BlazeComponent, superClass);\n\n  function BlazeComponent() {\n    return BlazeComponent.__super__.constructor.apply(this, arguments);\n  }\n\n  BlazeComponent.getComponentForElement = function(domElement) {\n    var templateInstance;\n    if (!domElement) {\n      return null;\n    }\n    if (domElement.nodeType !== Node.ELEMENT_NODE) {\n      throw new Error(\"Expected DOM element.\");\n    }\n    templateInstance = getTemplateInstanceFunction(Blaze.getView(domElement), true);\n    return templateInstanceToComponent(templateInstance, true);\n  };\n\n  BlazeComponent.prototype.mixins = function() {\n    return [];\n  };\n\n  BlazeComponent.prototype.mixinParent = function(mixinParent) {\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if (mixinParent) {\n      this._componentInternals.mixinParent = mixinParent;\n      return this;\n    }\n    return this._componentInternals.mixinParent || null;\n  };\n\n  BlazeComponent.prototype.requireMixin = function(nameOrMixin) {\n    var ref;\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);\n    Tracker.nonreactive((function(_this) {\n      return function() {\n        var base, mixinInstance, mixinInstanceComponent, ref1, ref2, ref3;\n        if (_this.getMixin(nameOrMixin)) {\n          return;\n        }\n        if (_.isString(nameOrMixin)) {\n          if (_this.constructor.getComponent) {\n            mixinInstanceComponent = _this.constructor.getComponent(nameOrMixin);\n          } else {\n            mixinInstanceComponent = BlazeComponent.getComponent(nameOrMixin);\n          }\n          if (!mixinInstanceComponent) {\n            throw new Error(\"Unknown mixin '\" + nameOrMixin + \"'.\");\n          }\n          mixinInstance = new mixinInstanceComponent();\n        } else if (_.isFunction(nameOrMixin)) {\n          mixinInstance = new nameOrMixin();\n        } else {\n          mixinInstance = nameOrMixin;\n        }\n        _this._componentInternals.mixins.push(mixinInstance);\n        if (mixinInstance.mixinParent) {\n          mixinInstance.mixinParent(_this);\n        }\n        if (typeof mixinInstance.createMixins === \"function\") {\n          mixinInstance.createMixins();\n        }\n        if ((base = _this._componentInternals).templateInstance == null) {\n          base.templateInstance = new ReactiveField(null, function(a, b) {\n            return a === b;\n          });\n        }\n        if (!((ref1 = _this._componentInternals.templateInstance()) != null ? ref1.view.isDestroyed : void 0)) {\n          if (!_this._componentInternals.inOnCreated && ((ref2 = _this._componentInternals.templateInstance()) != null ? ref2.view.isCreated : void 0)) {\n            if (typeof mixinInstance.onCreated === \"function\") {\n              mixinInstance.onCreated();\n            }\n          }\n          if (!_this._componentInternals.inOnRendered && ((ref3 = _this._componentInternals.templateInstance()) != null ? ref3.view.isRendered : void 0)) {\n            return typeof mixinInstance.onRendered === \"function\" ? mixinInstance.onRendered() : void 0;\n          }\n        }\n      };\n    })(this));\n    return this;\n  };\n\n  BlazeComponent.prototype.createMixins = function() {\n    var i, len, mixin, ref;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if (this._componentInternals.mixins) {\n      return;\n    }\n    this._componentInternals.mixins = [];\n    ref = this.mixins();\n    for (i = 0, len = ref.length; i < len; i++) {\n      mixin = ref[i];\n      this.requireMixin(mixin);\n    }\n    return this;\n  };\n\n  BlazeComponent.prototype.getMixin = function(nameOrMixin) {\n    var i, j, len, len1, mixin, mixinComponentName, ref, ref1, ref2;\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);\n    if (_.isString(nameOrMixin)) {\n      ref1 = this._componentInternals.mixins;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        mixin = ref1[i];\n        mixinComponentName = (typeof mixin.componentName === \"function\" ? mixin.componentName() : void 0) || null;\n        if (mixinComponentName && mixinComponentName === nameOrMixin) {\n          return mixin;\n        }\n      }\n    } else {\n      ref2 = this._componentInternals.mixins;\n      for (j = 0, len1 = ref2.length; j < len1; j++) {\n        mixin = ref2[j];\n        if (mixin.constructor === nameOrMixin) {\n          return mixin;\n        } else if (mixin === nameOrMixin) {\n          return mixin;\n        }\n      }\n    }\n    return null;\n  };\n\n  BlazeComponent.prototype.callFirstWith = function() {\n    var afterComponentOrMixin, args, mixin, propertyName;\n    afterComponentOrMixin = arguments[0], propertyName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n    mixin = this.getFirstWith(afterComponentOrMixin, propertyName);\n    if (!mixin) {\n      return;\n    }\n    if (_.isFunction(mixin[propertyName])) {\n      return mixin[propertyName].apply(mixin, args);\n    } else {\n      return mixin[propertyName];\n    }\n  };\n\n  BlazeComponent.prototype.getFirstWith = function(afterComponentOrMixin, propertyName) {\n    var found, i, len, mixin, ref, ref1;\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);\n    if (!afterComponentOrMixin) {\n      if (propertyName in this) {\n        return this;\n      }\n      found = true;\n    } else if (afterComponentOrMixin && afterComponentOrMixin === this) {\n      found = true;\n    } else {\n      found = false;\n    }\n    ref1 = this._componentInternals.mixins;\n    for (i = 0, len = ref1.length; i < len; i++) {\n      mixin = ref1[i];\n      if (found && propertyName in mixin) {\n        return mixin;\n      }\n      if (mixin === afterComponentOrMixin) {\n        found = true;\n      }\n    }\n    return null;\n  };\n\n  BlazeComponent.renderComponent = function(parentComponent) {\n    return Tracker.nonreactive((function(_this) {\n      return function() {\n        var componentClass, data;\n        componentClass = _this;\n        if (Blaze.currentView) {\n          data = Template.currentData();\n        } else {\n          data = null;\n        }\n        if ((data != null ? data.constructor : void 0) !== argumentsConstructor) {\n          return wrapViewAndTemplate(Blaze.currentView, function() {\n            var component;\n            component = new componentClass();\n            return component.renderComponent(parentComponent);\n          });\n        }\n        return function() {\n          var currentWith, nonreactiveArguments, reactiveArguments;\n          assert(Tracker.active);\n          currentWith = Blaze.getView('with');\n          reactiveArguments = new ComputedField(function() {\n            data = currentWith.dataVar.get();\n            assert.equal(data != null ? data.constructor : void 0, argumentsConstructor);\n            return data._arguments;\n          }, EJSON.equals);\n          nonreactiveArguments = reactiveArguments();\n          return Tracker.nonreactive(function() {\n            var template;\n            template = Blaze._withCurrentView(Blaze.currentView.parentView.parentView, (function(_this) {\n              return function() {\n                return wrapViewAndTemplate(Blaze.currentView, function() {\n                  var component;\n                  component = (function(func, args, ctor) {\n                    ctor.prototype = func.prototype;\n                    var child = new ctor, result = func.apply(child, args);\n                    return Object(result) === result ? result : child;\n                  })(componentClass, nonreactiveArguments, function(){});\n                  return component.renderComponent(parentComponent);\n                });\n              };\n            })(this));\n            registerFirstCreatedHook(template, function() {\n              this.view.originalParentView = this.view.parentView;\n              return this.view.parentView = this.view.parentView.parentView.parentView;\n            });\n            return template;\n          });\n        };\n      };\n    })(this));\n  };\n\n  BlazeComponent.prototype.renderComponent = function(parentComponent) {\n    return Tracker.nonreactive((function(_this) {\n      return function() {\n        var component, template, templateBase;\n        component = _this;\n        component.createMixins();\n        templateBase = getTemplateBase(component);\n        template = new Blaze.Template(\"BlazeComponent.\" + (component.componentName() || 'unnamed'), templateBase.renderFunction);\n        if (component._componentInternals == null) {\n          component._componentInternals = {};\n        }\n        component._componentInternals.templateBase = templateBase;\n        registerHooks(template, {\n          onCreated: function() {\n            var base, base1, base2, base3, componentOrMixin, results;\n            if (parentComponent) {\n              Tracker.nonreactive((function(_this) {\n                return function() {\n                  assert(!component.parentComponent());\n                  component.parentComponent(parentComponent);\n                  return parentComponent.addChildComponent(component);\n                };\n              })(this));\n            }\n            this.view._onViewRendered((function(_this) {\n              return function() {\n                var componentOrMixin, results;\n                if (_this.view.renderCount !== 1) {\n                  return;\n                }\n                componentOrMixin = null;\n                results = [];\n                while (componentOrMixin = _this.component.getFirstWith(componentOrMixin, 'events')) {\n                  results.push(addEvents(_this.view, componentOrMixin));\n                }\n                return results;\n              };\n            })(this));\n            this.component = component;\n            assert(!Tracker.nonreactive((function(_this) {\n              return function() {\n                var base;\n                return typeof (base = _this.component._componentInternals).templateInstance === \"function\" ? base.templateInstance() : void 0;\n              };\n            })(this)));\n            if ((base = this.component._componentInternals).templateInstance == null) {\n              base.templateInstance = new ReactiveField(this, function(a, b) {\n                return a === b;\n              });\n            }\n            this.component._componentInternals.templateInstance(this);\n            if ((base1 = this.component._componentInternals).isCreated == null) {\n              base1.isCreated = new ReactiveField(true);\n            }\n            this.component._componentInternals.isCreated(true);\n            if ((base2 = this.component._componentInternals).isRendered == null) {\n              base2.isRendered = new ReactiveField(false);\n            }\n            this.component._componentInternals.isRendered(false);\n            if ((base3 = this.component._componentInternals).isDestroyed == null) {\n              base3.isDestroyed = new ReactiveField(false);\n            }\n            this.component._componentInternals.isDestroyed(false);\n            try {\n              this.component._componentInternals.inOnCreated = true;\n              componentOrMixin = null;\n              results = [];\n              while (componentOrMixin = this.component.getFirstWith(componentOrMixin, 'onCreated')) {\n                results.push(componentOrMixin.onCreated());\n              }\n              return results;\n            } finally {\n              delete this.component._componentInternals.inOnCreated;\n            }\n          },\n          onRendered: function() {\n            var base, componentOrMixin, results;\n            if ((base = this.component._componentInternals).isRendered == null) {\n              base.isRendered = new ReactiveField(true);\n            }\n            this.component._componentInternals.isRendered(true);\n            Tracker.nonreactive((function(_this) {\n              return function() {\n                return assert.equal(_this.component._componentInternals.isCreated(), true);\n              };\n            })(this));\n            try {\n              this.component._componentInternals.inOnRendered = true;\n              componentOrMixin = null;\n              results = [];\n              while (componentOrMixin = this.component.getFirstWith(componentOrMixin, 'onRendered')) {\n                results.push(componentOrMixin.onRendered());\n              }\n              return results;\n            } finally {\n              delete this.component._componentInternals.inOnRendered;\n            }\n          },\n          onDestroyed: function() {\n            return this.autorun((function(_this) {\n              return function(computation) {\n                if (_this.component.childComponents().length) {\n                  return;\n                }\n                computation.stop();\n                return Tracker.nonreactive(function() {\n                  var base, base1, componentOrMixin;\n                  assert.equal(_this.component._componentInternals.isCreated(), true);\n                  _this.component._componentInternals.isCreated(false);\n                  if ((base = _this.component._componentInternals).isRendered == null) {\n                    base.isRendered = new ReactiveField(false);\n                  }\n                  _this.component._componentInternals.isRendered(false);\n                  if ((base1 = _this.component._componentInternals).isDestroyed == null) {\n                    base1.isDestroyed = new ReactiveField(true);\n                  }\n                  _this.component._componentInternals.isDestroyed(true);\n                  componentOrMixin = null;\n                  while (componentOrMixin = _this.component.getFirstWith(componentOrMixin, 'onDestroyed')) {\n                    componentOrMixin.onDestroyed();\n                  }\n                  if (parentComponent) {\n                    component.parentComponent(null);\n                    parentComponent.removeChildComponent(component);\n                  }\n                  return _this.component._componentInternals.templateInstance(null);\n                });\n              };\n            })(this));\n          }\n        });\n        return template;\n      };\n    })(this));\n  };\n\n  BlazeComponent.prototype.removeComponent = function() {\n    if (this.isRendered()) {\n      return Blaze.remove(this._componentInternals.templateInstance().view);\n    }\n  };\n\n  BlazeComponent.renderComponentToHTML = function(parentComponent, parentView, data) {\n    var component;\n    component = Tracker.nonreactive((function(_this) {\n      return function() {\n        var componentClass;\n        componentClass = _this;\n        parentView = parentView || currentViewIfRendering() || ((parentComponent != null ? parentComponent.isRendered() : void 0) && parentComponent._componentInternals.templateInstance().view) || null;\n        return wrapViewAndTemplate(parentView, function() {\n          return new componentClass();\n        });\n      };\n    })(this));\n    if (arguments.length > 2) {\n      return component.renderComponentToHTML(parentComponent, parentView, data);\n    } else {\n      return component.renderComponentToHTML(parentComponent, parentView);\n    }\n  };\n\n  BlazeComponent.prototype.renderComponentToHTML = function(parentComponent, parentView, data) {\n    var expandedView, template;\n    template = Tracker.nonreactive((function(_this) {\n      return function() {\n        parentView = parentView || currentViewIfRendering() || ((parentComponent != null ? parentComponent.isRendered() : void 0) && parentComponent._componentInternals.templateInstance().view) || null;\n        return wrapViewAndTemplate(parentView, function() {\n          return _this.renderComponent(parentComponent);\n        });\n      };\n    })(this));\n    if (arguments.length > 2) {\n      expandedView = expandView(Blaze._TemplateWith(data, contentAsFunc(template)), parentView);\n    } else {\n      expandedView = expandView(contentAsView(template), parentView);\n    }\n    return HTML.toHTML(expandedView);\n  };\n\n  BlazeComponent.prototype.template = function() {\n    return this.callFirstWith(this, 'template') || this.constructor.componentName();\n  };\n\n  BlazeComponent.prototype.onCreated = function() {\n    return callTemplateBaseHooks(this, 'created');\n  };\n\n  BlazeComponent.prototype.onRendered = function() {\n    return callTemplateBaseHooks(this, 'rendered');\n  };\n\n  BlazeComponent.prototype.onDestroyed = function() {\n    return callTemplateBaseHooks(this, 'destroyed');\n  };\n\n  BlazeComponent.prototype.isCreated = function() {\n    var base;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if ((base = this._componentInternals).isCreated == null) {\n      base.isCreated = new ReactiveField(false);\n    }\n    return this._componentInternals.isCreated();\n  };\n\n  BlazeComponent.prototype.isRendered = function() {\n    var base;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if ((base = this._componentInternals).isRendered == null) {\n      base.isRendered = new ReactiveField(false);\n    }\n    return this._componentInternals.isRendered();\n  };\n\n  BlazeComponent.prototype.isDestroyed = function() {\n    var base;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if ((base = this._componentInternals).isDestroyed == null) {\n      base.isDestroyed = new ReactiveField(false);\n    }\n    return this._componentInternals.isDestroyed();\n  };\n\n  BlazeComponent.prototype.insertDOMElement = function(parent, node, before) {\n    if (before == null) {\n      before = null;\n    }\n    if (parent && node && (node.parentNode !== parent || node.nextSibling !== before)) {\n      parent.insertBefore(node, before);\n    }\n  };\n\n  BlazeComponent.prototype.moveDOMElement = function(parent, node, before) {\n    if (before == null) {\n      before = null;\n    }\n    if (parent && node && (node.parentNode !== parent || node.nextSibling !== before)) {\n      parent.insertBefore(node, before);\n    }\n  };\n\n  BlazeComponent.prototype.removeDOMElement = function(parent, node) {\n    if (parent && node && node.parentNode === parent) {\n      parent.removeChild(node);\n    }\n  };\n\n  BlazeComponent.prototype.events = function() {\n    var eventMap, events, fn, handler, i, len, ref, results, spec, templateInstance, view;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if (!this._componentInternals.templateInstance) {\n      return [];\n    }\n    view = Tracker.nonreactive((function(_this) {\n      return function() {\n        return _this._componentInternals.templateInstance().view;\n      };\n    })(this));\n    templateInstance = getTemplateInstanceFunction(view, true);\n    ref = this._componentInternals.templateBase.__eventMaps;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      events = ref[i];\n      eventMap = {};\n      fn = function(spec, handler) {\n        return eventMap[spec] = function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return withTemplateInstanceFunc(templateInstance, function() {\n            return Blaze._withCurrentView(view, function() {\n              return handler.apply(view, args);\n            });\n          });\n        };\n      };\n      for (spec in events) {\n        handler = events[spec];\n        fn(spec, handler);\n      }\n      results.push(eventMap);\n    }\n    return results;\n  };\n\n  BlazeComponent.prototype.data = function(path, equalsFunc) {\n    var base, ref, view;\n    if (this._componentInternals == null) {\n      this._componentInternals = {};\n    }\n    if ((base = this._componentInternals).templateInstance == null) {\n      base.templateInstance = new ReactiveField(null, function(a, b) {\n        return a === b;\n      });\n    }\n    if (view = (ref = this._componentInternals.templateInstance()) != null ? ref.view : void 0) {\n      if (path != null) {\n        return DataLookup.get((function(_this) {\n          return function() {\n            return Blaze.getData(view);\n          };\n        })(this), path, equalsFunc);\n      } else {\n        return Blaze.getData(view);\n      }\n    }\n    return void 0;\n  };\n\n  BlazeComponent.currentData = function(path, equalsFunc) {\n    var currentView;\n    if (!Blaze.currentView) {\n      return void 0;\n    }\n    currentView = Blaze.currentView;\n    if (_.isString(path)) {\n      path = path.split('.');\n    } else if (!_.isArray(path)) {\n      return Blaze.getData(currentView);\n    }\n    return DataLookup.get((function(_this) {\n      return function() {\n        var lexicalData, result;\n        if (Blaze._lexicalBindingLookup && (lexicalData = Blaze._lexicalBindingLookup(currentView, path[0]))) {\n          result = {};\n          result[path[0]] = lexicalData;\n          return result;\n        }\n        return Blaze.getData(currentView);\n      };\n    })(this), path, equalsFunc);\n  };\n\n  BlazeComponent.prototype.currentData = function(path, equalsFunc) {\n    return this.constructor.currentData(path, equalsFunc);\n  };\n\n  BlazeComponent.prototype.component = function() {\n    return this;\n  };\n\n  BlazeComponent.currentComponent = function() {\n    var templateInstance;\n    templateInstance = getTemplateInstanceFunction(Blaze.currentView, false);\n    return templateInstanceToComponent(templateInstance, false);\n  };\n\n  BlazeComponent.prototype.currentComponent = function() {\n    return this.constructor.currentComponent();\n  };\n\n  BlazeComponent.prototype.firstNode = function() {\n    if (this.isRendered()) {\n      return this._componentInternals.templateInstance().view._domrange.firstNode();\n    }\n    return void 0;\n  };\n\n  BlazeComponent.prototype.lastNode = function() {\n    if (this.isRendered()) {\n      return this._componentInternals.templateInstance().view._domrange.lastNode();\n    }\n    return void 0;\n  };\n\n  BlazeComponent.prototype.autorun = function(runFunc) {\n    var templateInstance;\n    templateInstance = Tracker.nonreactive((function(_this) {\n      return function() {\n        var ref;\n        return (ref = _this._componentInternals) != null ? typeof ref.templateInstance === \"function\" ? ref.templateInstance() : void 0 : void 0;\n      };\n    })(this));\n    if (!templateInstance) {\n      throw new Error(\"The component has to be created before calling 'autorun'.\");\n    }\n    return templateInstance.autorun(_.bind(runFunc, this));\n  };\n\n  return BlazeComponent;\n\n})(BaseComponent);\n\nSUPPORTS_REACTIVE_INSTANCE = ['subscriptionsReady'];\n\nREQUIRE_RENDERED_INSTANCE = ['$', 'find', 'findAll'];\n\nref = Blaze.TemplateInstance.prototype;\nfor (methodName in ref) {\n  method = ref[methodName];\n  if (!(methodName in BlazeComponent.prototype)) {\n    (function(methodName, method) {\n      if (indexOf.call(SUPPORTS_REACTIVE_INSTANCE, methodName) >= 0) {\n        return BlazeComponent.prototype[methodName] = function() {\n          var args, base, templateInstance;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this._componentInternals == null) {\n            this._componentInternals = {};\n          }\n          if ((base = this._componentInternals).templateInstance == null) {\n            base.templateInstance = new ReactiveField(null, function(a, b) {\n              return a === b;\n            });\n          }\n          if (templateInstance = this._componentInternals.templateInstance()) {\n            return templateInstance[methodName].apply(templateInstance, args);\n          }\n          return void 0;\n        };\n      } else if (indexOf.call(REQUIRE_RENDERED_INSTANCE, methodName) >= 0) {\n        return BlazeComponent.prototype[methodName] = function() {\n          var args, ref1;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.isRendered()) {\n            return (ref1 = this._componentInternals.templateInstance())[methodName].apply(ref1, args);\n          }\n          return void 0;\n        };\n      } else {\n        return BlazeComponent.prototype[methodName] = function() {\n          var args, templateInstance;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          templateInstance = Tracker.nonreactive((function(_this) {\n            return function() {\n              var ref1;\n              return (ref1 = _this._componentInternals) != null ? typeof ref1.templateInstance === \"function\" ? ref1.templateInstance() : void 0 : void 0;\n            };\n          })(this));\n          if (!templateInstance) {\n            throw new Error(\"The component has to be created before calling '\" + methodName + \"'.\");\n          }\n          return templateInstance[methodName].apply(templateInstance, args);\n        };\n      }\n    })(methodName, method);\n  }\n}\n","sourceMap":{"version":3,"file":"/lib.coffee.js","sourceRoot":"","sources":["/packages/peerlibrary_blaze-components/lib.coffee"],"names":[],"mappings":"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","sourcesContent":["getTemplateInstance = (view, skipBlockHelpers) ->\n  while view and not view._templateInstance\n    if skipBlockHelpers\n      view = view.parentView\n    else\n      view = view.originalParentView or view.parentView\n\n  view?._templateInstance\n\n# More or less the same as aldeed:template-extension's template.get('component') just specialized.\n# It allows us to not have a dependency on template-extension package and that we can work with Iron\n# Router which has its own DynamicTemplate class which is not patched by template-extension and thus\n# does not have .get() method.\ntemplateInstanceToComponent = (templateInstanceFunc, skipBlockHelpers) ->\n  templateInstance = templateInstanceFunc?()\n\n  # Iron Router uses its own DynamicTemplate which is not a proper template instance, but it is\n  # passed in as such, so we want to find the real one before we start searching for the component.\n  templateInstance = getTemplateInstance templateInstance?.view, skipBlockHelpers\n\n  while templateInstance\n    return templateInstance.component if 'component' of templateInstance\n\n    if skipBlockHelpers\n      templateInstance = getTemplateInstance templateInstance.view.parentView, skipBlockHelpers\n    else\n      templateInstance = getTemplateInstance (templateInstance.view.originalParentView or templateInstance.view.parentView), skipBlockHelpers\n\n  null\n\ngetTemplateInstanceFunction = (view, skipBlockHelpers) ->\n  templateInstance = getTemplateInstance view, skipBlockHelpers\n  ->\n    templateInstance\n\nclass ComponentsNamespaceReference\n  constructor: (@namespace, @templateInstance) ->\n\n# We extend the original dot operator to support {{> Foo.Bar}}. This goes through a getTemplateHelper path, but\n# we want to redirect it to the getTemplate path. So we mark it in getTemplateHelper and then here call getTemplate.\noriginalDot = Spacebars.dot\nSpacebars.dot = (value, args...) ->\n  if value instanceof ComponentsNamespaceReference\n    return Blaze._getTemplate \"#{value.namespace}.#{args.join '.'}\", value.templateInstance\n\n  originalDot value, args...\n\noriginalInclude = Spacebars.include\nSpacebars.include = (templateOrFunction, args...) ->\n  # If ComponentsNamespaceReference gets all the way to the Spacebars.include it means that we are in the situation\n  # where there is both namespace and component with the same name, and user is including a component. But namespace\n  # reference is created instead (because we do not know in advance that there is no Spacebars.dot call around lookup\n  # call). So we dereference the reference and try to resolve a template. Of course, a component might not really exist.\n  if templateOrFunction instanceof ComponentsNamespaceReference\n    templateOrFunction = Blaze._getTemplate templateOrFunction.namespace, templateOrFunction.templateInstance\n\n  originalInclude templateOrFunction, args...\n\n# We override the original lookup method with a similar one, which supports components as well.\n#\n# Now the order of the lookup will be, in order:\n#   a helper of the current template\n#   a property of the current component (not the BlazeComponent.currentComponent() though, but @component())\n#   a helper of the current component's base template (not the BlazeComponent.currentComponent() though, but @component())\n#   the name of a component\n#   the name of a template\n#   global helper\n#   a property of the data context\n#\n# Returns a function, a non-function value, or null. If a function is found, it is bound appropriately.\n#\n# NOTE: This function must not establish any reactive dependencies itself.  If there is any reactivity\n# in the value, lookup should return a function.\n#\n# TODO: Should we also lookup for a property of the component-level data context (and template-level data context)?\n\nBlaze._getTemplateHelper = (template, name, templateInstance) ->\n  isKnownOldStyleHelper = false\n  if template.__helpers.has name\n    helper = template.__helpers.get name\n    if helper is Blaze._OLDSTYLE_HELPER\n      isKnownOldStyleHelper = true\n    else if helper?\n      return wrapHelper bindDataContext(helper), templateInstance\n    else\n      return null\n\n  # Old-style helper.\n  if name of template\n    # Only warn once per helper.\n    unless isKnownOldStyleHelper\n      template.__helpers.set name, Blaze._OLDSTYLE_HELPER\n      unless template._NOWARN_OLDSTYLE_HELPERS\n        Blaze._warn \"Assigning helper with `\" + template.viewName + \".\" + name + \" = ...` is deprecated.  Use `\" + template.viewName + \".helpers(...)` instead.\"\n    if template[name]?\n      return wrapHelper bindDataContext(template[name]), templateInstance\n    else\n      return null\n\n  return null unless templateInstance\n\n  # Do not resolve component helpers if inside Template.dynamic. The reason is that Template.dynamic uses a data context\n  # value with name \"template\" internally. But when used inside a component the data context lookup is then resolved\n  # into a current component's template method and not the data context \"template\". To force the data context resolving\n  # Template.dynamic should use \"this.template\" in its templates, but it does not, so we have a special case here for it.\n  return null if template.viewName in ['Template.__dynamicWithDataContext', 'Template.__dynamic']\n\n  # Blaze.View::lookup should not introduce any reactive dependencies, but we can simply ignore reactivity here because\n  # template instance probably cannot change without reconstructing the component as well.\n  component = Tracker.nonreactive ->\n    # We want to skip any block helper. {{method}} should resolve to\n    # {{component.method}} and not to {{currentComponent.method}}.\n    templateInstanceToComponent templateInstance, true\n\n  # Component.\n  if component\n    # This will first search on the component and then continue with mixins.\n    if mixinOrComponent = component.getFirstWith null, name\n      return wrapHelper bindComponent(mixinOrComponent, mixinOrComponent[name]), templateInstance\n\n  # A special case to support {{> Foo.Bar}}. This goes through a getTemplateHelper path, but we want to redirect\n  # it to the getTemplate path. So we mark it and leave to Spacebars.dot to call getTemplate.\n  # TODO: We should provide a BaseComponent.getComponentsNamespace method instead of accessing components directly.\n  if name and name of BlazeComponent.components\n    return new ComponentsNamespaceReference name, templateInstance\n\n  # Maybe a preexisting template helper on the component's base template.\n  if component\n    if (helper = component._componentInternals?.templateBase?.__helpers.get name)?\n      return wrapHelper bindDataContext(helper), templateInstance\n\n  null\n\nshare.inExpandAttributes = false\n\nbindComponent = (component, helper) ->\n  if _.isFunction helper\n    (args...) ->\n      result = helper.apply component, args\n\n      # If we are expanding attributes and this is an object with dynamic attributes,\n      # then we want to bind all possible event handlers to the component as well.\n      if share.inExpandAttributes and _.isObject result\n        for name, value of result when share.EVENT_HANDLER_REGEX.test name\n          if _.isFunction value\n            result[name] = _.bind value, component\n          else if _.isArray value\n            result[name] = _.map value, (fun) ->\n              if _.isFunction fun\n                _.bind fun, component\n              else\n                fun\n\n      result\n  else\n    helper\n\nbindDataContext = (helper) ->\n  if _.isFunction helper\n    ->\n      data = Blaze.getData()\n      data ?= {}\n      helper.apply data, arguments\n  else\n    helper\n\nwrapHelper = (f, templateFunc) ->\n  # XXX COMPAT WITH METEOR 1.0.3.2\n  return Blaze._wrapCatchingExceptions f, 'template helper' unless Blaze.Template._withTemplateInstanceFunc\n\n  return f unless _.isFunction f\n\n  ->\n    self = @\n    args = arguments\n\n    Blaze.Template._withTemplateInstanceFunc templateFunc, ->\n      Blaze._wrapCatchingExceptions(f, 'template helper').apply self, args\n\nif Blaze.Template._withTemplateInstanceFunc\n  withTemplateInstanceFunc = Blaze.Template._withTemplateInstanceFunc\nelse\n  # XXX COMPAT WITH METEOR 1.0.3.2.\n  withTemplateInstanceFunc = (templateInstance, f) ->\n    f()\n\ngetTemplateBase = (component) ->\n  # We do not allow template to be a reactive method.\n  Tracker.nonreactive ->\n    componentTemplate = component.template()\n    if _.isString componentTemplate\n      templateBase = Template[componentTemplate]\n      throw new Error \"Template '#{componentTemplate}' cannot be found.\" unless templateBase\n    else if componentTemplate\n      templateBase = componentTemplate\n    else\n      throw new Error \"Template for the component '#{component.componentName() or 'unnamed'}' not provided.\"\n\n    templateBase\n\ncallTemplateBaseHooks = (component, hookName) ->\n  component._componentInternals ?= {}\n\n  # In mixins we do not have a template instance. There is also\n  # no reason for a template instance to extend a Blaze template.\n  return unless component._componentInternals.templateInstance\n\n  templateInstance = Tracker.nonreactive ->\n    component._componentInternals.templateInstance()\n  callbacks = component._componentInternals.templateBase._getCallbacks hookName\n  Template._withTemplateInstanceFunc(\n    ->\n      templateInstance\n  ,\n    ->\n      for callback in callbacks\n        callback.call templateInstance\n  )\n\n  return\n\nwrapViewAndTemplate = (currentView, f) ->\n  # For template content wrapped inside the block helper, we want to skip the block\n  # helper when searching for corresponding template. This means that Template.instance()\n  # will return the component's template, while BlazeComponent.currentComponent() will\n  # return the component inside.\n  templateInstance = getTemplateInstanceFunction currentView, true\n\n  # We set template instance to match the current view (mostly, only not when inside\n  # the block helper). The latter we use for BlazeComponent.currentComponent(), but\n  # it is good that both template instance and current view correspond to each other\n  # as much as possible.\n  withTemplateInstanceFunc templateInstance, ->\n    # We set view based on the current view so that inside event handlers\n    # BlazeComponent.currentData() (and Blaze.getData() and Template.currentData())\n    # returns data context of event target and not component/template. Moreover,\n    # inside event handlers BlazeComponent.currentComponent() returns the component\n    # of event target.\n    Blaze._withCurrentView currentView, ->\n      f()\n\naddEvents = (view, component) ->\n  eventsList = component.events()\n\n  throw new Error \"'events' method from the component '#{component.componentName() or 'unnamed'}' did not return a list of event maps.\" unless _.isArray eventsList\n\n  for events in eventsList\n    eventMap = {}\n\n    for spec, handler of events\n      do (spec, handler) ->\n        eventMap[spec] = (args...) ->\n          event = args[0]\n\n          currentView = Blaze.getView event.currentTarget\n          wrapViewAndTemplate currentView, ->\n            handler.apply component, args\n\n          # Make sure CoffeeScript does not return anything.\n          # Returning from event handlers is deprecated.\n          return\n\n    Blaze._addEventMap view, eventMap, view\n\n  return\n\noriginalGetTemplate = Blaze._getTemplate\nBlaze._getTemplate = (name, templateInstance) ->\n  # Blaze.View::lookup should not introduce any reactive dependencies, so we are making sure it is so.\n  template = Tracker.nonreactive ->\n    if Blaze.currentView\n      parentComponent = BlazeComponent.currentComponent()\n    else\n      # We do not skip block helpers to assure that when block helpers are used,\n      # component tree integrates them nicely into a tree.\n      parentComponent = templateInstanceToComponent templateInstance, false\n\n    BlazeComponent.getComponent(name)?.renderComponent parentComponent\n  return template if template and (template instanceof Blaze.Template or _.isFunction template)\n\n  originalGetTemplate name\n\nregisterHooks = (template, hooks) ->\n  if template.onCreated\n    template.onCreated hooks.onCreated\n    template.onRendered hooks.onRendered\n    template.onDestroyed hooks.onDestroyed\n  else\n    # XXX COMPAT WITH METEOR 1.0.3.2.\n    template.created = hooks.onCreated\n    template.rendered = hooks.onRendered\n    template.destroyed = hooks.onDestroyed\n\nregisterFirstCreatedHook = (template, onCreated) ->\n  if template._callbacks\n    template._callbacks.created.unshift onCreated\n  else\n    # XXX COMPAT WITH METEOR 1.0.3.2.\n    oldCreated = template.created\n    template.created = ->\n      onCreated.call @\n      oldCreated?.call @\n\n# We make Template.dynamic resolve to the component if component name is specified as a template name, and not\n# to the non-component template which is probably used only for the content. We simply reuse Blaze._getTemplate.\n# TODO: How to pass args?\n#       Maybe simply by using Spacebars nested expressions (https://github.com/meteor/meteor/pull/4101)?\n#       Template.dynamic template=\"...\" data=(args ...)? But this exposes the fact that args are passed as data context.\n#       Maybe we should simply override Template.dynamic and add \"args\" argument?\n# TODO: This can be removed once https://github.com/meteor/meteor/pull/4036 is merged in.\nTemplate.__dynamicWithDataContext.__helpers.set 'chooseTemplate', (name) ->\n  Blaze._getTemplate name, =>\n    Template.instance()\n\nargumentsConstructor = ->\n  # This class should never really be created.\n  assert false\n\n# TODO: Find a way to pass arguments to the component without having to introduce one intermediary data context into the data context hierarchy.\n#       (In fact two data contexts, because we add one more when restoring the original one.)\nTemplate.registerHelper 'args', ->\n  obj = {}\n  # We use custom constructor to know that it is not a real data context.\n  obj.constructor = argumentsConstructor\n  obj._arguments = arguments\n  obj\n\nshare.EVENT_HANDLER_REGEX = /^on[A-Z]/\n\nshare.isEventHandler = (fun) ->\n  _.isFunction(fun) and fun.eventHandler\n\n# When event handlers are provided directly as args they are not passed through\n# Spacebars.event by the template compiler, so we have to do it ourselves.\noriginalFlattenAttributes = HTML.flattenAttributes\nHTML.flattenAttributes = (attrs) ->\n  if attrs = originalFlattenAttributes attrs\n    for name, value of attrs when share.EVENT_HANDLER_REGEX.test name\n      # Already processed by Spacebars.event.\n      continue if share.isEventHandler value\n      continue if _.isArray(value) and _.some value, share.isEventHandler\n\n      # When event handlers are provided directly as args,\n      # we require them to be just event handlers.\n      if _.isArray value\n        attrs[name] = _.map value, Spacebars.event\n      else\n        attrs[name] = Spacebars.event value\n\n  attrs\n\nSpacebars.event = (eventHandler, args...) ->\n  throw new Error \"Event handler not a function: #{eventHandler}\" unless _.isFunction eventHandler\n\n  # Execute all arguments.\n  args = Spacebars.mustacheImpl ((xs...) -> xs), args...\n\n  fun = (event, eventArgs...) ->\n    currentView = Blaze.getView event.currentTarget\n    wrapViewAndTemplate currentView, ->\n      # We do not have to bind \"this\" because event handlers are resolved\n      # as template helpers and are already bound. We bind event handlers\n      # in dynamic attributes already as well.\n      eventHandler.apply null, [event].concat args, eventArgs\n\n  fun.eventHandler = true\n\n  fun\n\n# When converting the component to the static HTML, remove all event handlers.\noriginalVisitTag = HTML.ToHTMLVisitor::visitTag\nHTML.ToHTMLVisitor::visitTag = (tag) ->\n  if attrs = tag.attrs\n    attrs = HTML.flattenAttributes attrs\n    for name of attrs when share.EVENT_HANDLER_REGEX.test name\n      delete attrs[name]\n    tag.attrs = attrs\n\n  originalVisitTag.call @, tag\n\ncurrentViewIfRendering = ->\n  view = Blaze.currentView\n  if view?._isInRender\n    view\n  else\n    null\n\ncontentAsFunc = (content) ->\n  # We do not check content for validity.\n\n  if !_.isFunction content\n    return ->\n      content\n\n  content\n\ncontentAsView = (content) ->\n  # We do not check content for validity.\n\n  if content instanceof Blaze.Template\n    content.constructView()\n  else if content instanceof Blaze.View\n    content\n  else\n    Blaze.View 'render', contentAsFunc content\n\nHTMLJSExpander = Blaze._HTMLJSExpander.extend()\nHTMLJSExpander.def\n  # Based on Blaze._HTMLJSExpander, but calls our expandView.\n  visitObject: (x) ->\n    if x instanceof Blaze.Template\n      x = x.constructView()\n    if x instanceof Blaze.View\n      return expandView x, @parentView\n\n    HTML.TransformingVisitor.prototype.visitObject.call @, x\n\n# Based on Blaze._expand, but uses our HTMLJSExpander.\nexpand = (htmljs, parentView) ->\n  parentView = parentView or currentViewIfRendering()\n\n  (new HTMLJSExpander parentView: parentView).visit htmljs\n\n# Based on Blaze._expandView, but with flushing.\nexpandView = (view, parentView) ->\n  Blaze._createView view, parentView, true\n\n  view._isInRender = true\n  htmljs = Blaze._withCurrentView view, ->\n    view._render()\n  view._isInRender = false\n\n  Tracker.flush()\n\n  result = expand htmljs, view\n\n  Tracker.flush()\n\n  if Tracker.active\n    Tracker.onInvalidate ->\n      Blaze._destroyView view\n  else\n    Blaze._destroyView view\n\n  Tracker.flush()\n\n  result\n\nclass BlazeComponent extends BaseComponent\n  # TODO: Figure out how to do at the BaseComponent level?\n  @getComponentForElement: (domElement) ->\n    return null unless domElement\n\n    # This uses the same check if the argument is a DOM element that Blaze._DOMRange.forElement does.\n    throw new Error \"Expected DOM element.\" unless domElement.nodeType is Node.ELEMENT_NODE\n\n    # For DOM elements we want to return the component which matches the template\n    # with that DOM element and not the component closest in the component tree.\n    # So we skip the block helpers. (If DOM element is rendered by the block helper\n    # this will find that block helper template/component.)\n    templateInstance = getTemplateInstanceFunction Blaze.getView(domElement), true\n    templateInstanceToComponent templateInstance, true\n\n  mixins: ->\n    []\n\n  # When a component is used as a mixin, createMixins will call this method to set the parent\n  # component using this mixin. Extend this method if you want to do any action when parent is\n  # set, for example, add dependency mixins to the parent. Make sure you call super as well.\n  mixinParent: (mixinParent) ->\n    @_componentInternals ?= {}\n\n    # Setter.\n    if mixinParent\n      @_componentInternals.mixinParent = mixinParent\n      # To allow chaining.\n      return @\n\n    # Getter.\n    @_componentInternals.mixinParent or null\n\n  requireMixin: (nameOrMixin) ->\n    assert @_componentInternals?.mixins\n\n    Tracker.nonreactive =>\n      # Do not do anything if mixin is already required. This allows multiple mixins to call requireMixin\n      # in mixinParent method to add dependencies, but if dependencies are already there, nothing happens.\n      return if @getMixin nameOrMixin\n\n      if _.isString nameOrMixin\n        # It could be that the component is not a real instance of the BlazeComponent class,\n        # so it might not have a constructor pointing back to a BlazeComponent subclass.\n        if @constructor.getComponent\n          mixinInstanceComponent = @constructor.getComponent nameOrMixin\n        else\n          mixinInstanceComponent = BlazeComponent.getComponent nameOrMixin\n        throw new Error \"Unknown mixin '#{nameOrMixin}'.\" unless mixinInstanceComponent\n        mixinInstance = new mixinInstanceComponent()\n      else if _.isFunction nameOrMixin\n        mixinInstance = new nameOrMixin()\n      else\n        mixinInstance = nameOrMixin\n\n      # We add mixin before we call mixinParent so that dependencies come after this mixin,\n      # and that we prevent possible infinite loops because of circular dependencies.\n      # TODO: For now we do not provide an official API to add dependencies before the mixin itself.\n      @_componentInternals.mixins.push mixinInstance\n\n      # We allow mixins to not be components, so methods are not necessary available.\n\n      # Set mixin parent.\n      if mixinInstance.mixinParent\n        mixinInstance.mixinParent @\n\n      # Maybe mixin has its own mixins as well.\n      mixinInstance.createMixins?()\n\n      @_componentInternals.templateInstance ?= new ReactiveField null, (a, b) -> a is b\n\n      # If a mixin is adding a dependency using requireMixin after its mixinParent class (for example, in onCreate)\n      # and this is this dependency mixin, the view might already be created or rendered and callbacks were\n      # already called, so we should call them manually here as well. But only if he view has not been destroyed\n      # already. For those mixins we do not call anything, there is little use for them now.\n      unless @_componentInternals.templateInstance()?.view.isDestroyed\n        mixinInstance.onCreated?() if not @_componentInternals.inOnCreated and @_componentInternals.templateInstance()?.view.isCreated\n        mixinInstance.onRendered?() if not @_componentInternals.inOnRendered and @_componentInternals.templateInstance()?.view.isRendered\n\n    # To allow chaining.\n    @\n\n  # Method to instantiate all mixins.\n  createMixins: ->\n    @_componentInternals ?= {}\n\n    # To allow calling it multiple times, but non-first calls are simply ignored.\n    return if @_componentInternals.mixins\n    @_componentInternals.mixins = []\n\n    for mixin in @mixins()\n      @requireMixin mixin\n\n    # To allow chaining.\n    @\n\n  getMixin: (nameOrMixin) ->\n    assert @_componentInternals?.mixins\n\n    if _.isString nameOrMixin\n      for mixin in @_componentInternals.mixins\n        # We do not require mixins to be components, but if they are, they can\n        # be referenced based on their component name.\n        mixinComponentName = mixin.componentName?() or null\n        return mixin if mixinComponentName and mixinComponentName is nameOrMixin\n\n    else\n      for mixin in @_componentInternals.mixins\n        # nameOrMixin is a class.\n        if mixin.constructor is nameOrMixin\n          return mixin\n\n        # nameOrMixin is an instance, or something else.\n        else if mixin is nameOrMixin\n          return mixin\n\n    null\n\n  # Calls the component (if afterComponentOrMixin is null) or the first next mixin\n  # after afterComponentOrMixin it finds, and returns the result.\n  callFirstWith: (afterComponentOrMixin, propertyName, args...) ->\n    mixin = @getFirstWith afterComponentOrMixin, propertyName\n\n    # TODO: Should we throw an error here? Something like calling a function which does not exist?\n    return unless mixin\n\n    if _.isFunction mixin[propertyName]\n      return mixin[propertyName] args...\n    else\n      return mixin[propertyName]\n\n  getFirstWith: (afterComponentOrMixin, propertyName) ->\n    assert @_componentInternals?.mixins\n\n    # If afterComponentOrMixin is not provided, we start with the component.\n    if not afterComponentOrMixin\n      return @ if propertyName of @\n      # And continue with mixins.\n      found = true\n    # If afterComponentOrMixin is the component, we start with mixins.\n    else if afterComponentOrMixin and afterComponentOrMixin is @\n      found = true\n    else\n      found = false\n\n    # TODO: Implement with a map between mixin -> position, so that we do not have to seek to find a mixin.\n    for mixin in @_componentInternals.mixins\n      return mixin if found and propertyName of mixin\n\n      found = true if mixin is afterComponentOrMixin\n\n    null\n\n  # This class method more or less just creates an instance of a component and calls its renderComponent\n  # method. But because we want to allow passing arguments to the component in templates, we have some\n  # complicated code around to extract and pass those arguments. It is similar to how data context is\n  # passed to block helpers. In a data context visible only to the block helper template.\n  # TODO: This could be made less hacky. See https://github.com/meteor/meteor/issues/3913\n  @renderComponent: (parentComponent) ->\n    Tracker.nonreactive =>\n      componentClass = @\n\n      if Blaze.currentView\n        # We check data context in a non-reactive way, because we want just to peek into it\n        # and determine if data context contains component arguments or not. And while\n        # component arguments might change through time, the fact that they are there at\n        # all or not (\"args\" template helper was used or not) does not change through time.\n        # So we can check that non-reactively.\n        data = Template.currentData()\n      else\n        # There is no current view when there is no data context yet, thus also no arguments\n        # were provided through \"args\" template helper, so we just continue normally.\n        data = null\n\n      if data?.constructor isnt argumentsConstructor\n        # So that currentComponent in the constructor can return the component\n        # inside which this component has been constructed.\n        return wrapViewAndTemplate Blaze.currentView, =>\n          component = new componentClass()\n\n          return component.renderComponent parentComponent\n\n      # Arguments were provided through \"args\" template helper.\n\n      # We want to reactively depend on the data context for arguments, so we return a function\n      # instead of a template. Function will be run inside an autorun, a reactive context.\n      ->\n        assert Tracker.active\n\n        # We cannot use Template.getData() inside a normal autorun because current view is not defined inside\n        # a normal autorun. But we do not really have to depend reactively on the current view, only on the\n        # data context of a known (the closest Blaze.With) view. So we get this view by ourselves.\n        currentWith = Blaze.getView 'with'\n\n        # By default dataVar in the Blaze.With view uses ReactiveVar with default equality function which\n        # sees all objects as different. So invalidations are triggered for every data context assignments\n        # even if data has not really changed. This is why wrap it into a ComputedField with EJSON.equals.\n        # Because it uses EJSON.equals it will invalidate our function only if really changes.\n        # See https://github.com/meteor/meteor/issues/4073\n        reactiveArguments = new ComputedField ->\n          data = currentWith.dataVar.get()\n          assert.equal data?.constructor, argumentsConstructor\n          data._arguments\n        ,\n          EJSON.equals\n\n        # Here we register a reactive dependency on the ComputedField.\n        nonreactiveArguments = reactiveArguments()\n\n        Tracker.nonreactive ->\n          # Arguments were passed in as a data context. We want currentData in the constructor to return the\n          # original (parent) data context. Like we were not passing in arguments as a data context.\n          template = Blaze._withCurrentView Blaze.currentView.parentView.parentView, =>\n            # So that currentComponent in the constructor can return the component\n            # inside which this component has been constructed.\n            return wrapViewAndTemplate Blaze.currentView, =>\n              # Use arguments for the constructor.\n              component = new componentClass nonreactiveArguments...\n\n              return component.renderComponent parentComponent\n\n          # It has to be the first callback so that other have a correct data context.\n          registerFirstCreatedHook template, ->\n            # Arguments were passed in as a data context. Restore original (parent) data\n            # context. Same logic as in Blaze._InOuterTemplateScope.\n            @view.originalParentView = @view.parentView\n            @view.parentView = @view.parentView.parentView.parentView\n\n          template\n\n  renderComponent: (parentComponent) ->\n    # To make sure we do not introduce any reactive dependency. This is a conscious design decision.\n    # Reactivity should be changing data context, but components should be more stable, only changing\n    # when structure change in rendered DOM. You can change the component you are including (or pass\n    # different arguments) reactively though.\n    Tracker.nonreactive =>\n      component = @\n\n      # If mixins have not yet been created.\n      component.createMixins()\n\n      templateBase = getTemplateBase component\n\n      # Create a new component template based on the Blaze template. We want our own template\n      # because the same Blaze template could be reused between multiple components.\n      # TODO: Should we cache these templates based on (componentName, templateBase) pair? We could use two levels of ES2015 Maps, componentName -> templateBase -> template. What about component arguments changing?\n      template = new Blaze.Template \"BlazeComponent.#{component.componentName() or 'unnamed'}\", templateBase.renderFunction\n\n      # We lookup preexisting template helpers in Blaze._getTemplateHelper, if the component does not have\n      # a property with the same name. Preexisting event handlers and life-cycle hooks are taken care of\n      # in the related methods in the base class.\n\n      component._componentInternals ?= {}\n      component._componentInternals.templateBase = templateBase\n\n      registerHooks template,\n        onCreated: ->\n          # @ is a template instance.\n\n          if parentComponent\n            # component.parentComponent is reactive, so we use Tracker.nonreactive just to make sure we do not leak any reactivity here.\n            Tracker.nonreactive =>\n              # TODO: Should we support that the same component can be rendered multiple times in parallel? How could we do that? For different component parents or only the same one?\n              assert not component.parentComponent()\n\n              # We set the parent only when the component is created, not just constructed.\n              component.parentComponent parentComponent\n              parentComponent.addChildComponent component\n\n          @view._onViewRendered =>\n            # Attach events the first time template instance renders.\n            return unless @view.renderCount is 1\n\n            # We first add event handlers from the component, then mixins.\n            componentOrMixin = null\n            while componentOrMixin = @component.getFirstWith componentOrMixin, 'events'\n              addEvents @view, componentOrMixin\n\n          @component = component\n\n          # TODO: Should we support that the same component can be rendered multiple times in parallel? How could we do that? For different component parents or only the same one?\n          assert not Tracker.nonreactive => @component._componentInternals.templateInstance?()\n\n          @component._componentInternals.templateInstance ?= new ReactiveField @, (a, b) -> a is b\n          @component._componentInternals.templateInstance @\n\n          @component._componentInternals.isCreated ?= new ReactiveField true\n          @component._componentInternals.isCreated true\n\n          # Maybe we are re-rendering the component. So let's initialize variables just to be sure.\n\n          @component._componentInternals.isRendered ?= new ReactiveField false\n          @component._componentInternals.isRendered false\n\n          @component._componentInternals.isDestroyed ?= new ReactiveField false\n          @component._componentInternals.isDestroyed false\n\n          try\n            # We have to know if we should call onCreated on the mixin inside the requireMixin or not. We want to call\n            # it only once. If it requireMixin is called from onCreated of another mixin, then it will be added at the\n            # end and we will get it here at the end. So we should not call onCreated inside requireMixin because then\n            # onCreated would be called twice.\n            @component._componentInternals.inOnCreated = true\n            componentOrMixin = null\n            while componentOrMixin = @component.getFirstWith componentOrMixin, 'onCreated'\n              componentOrMixin.onCreated()\n          finally\n            delete @component._componentInternals.inOnCreated\n\n        onRendered: ->\n          # @ is a template instance.\n\n          @component._componentInternals.isRendered ?= new ReactiveField true\n          @component._componentInternals.isRendered true\n\n          Tracker.nonreactive =>\n            assert.equal @component._componentInternals.isCreated(), true\n\n          try\n            # Same as for onCreated above.\n            @component._componentInternals.inOnRendered = true\n            componentOrMixin = null\n            while componentOrMixin = @component.getFirstWith componentOrMixin, 'onRendered'\n              componentOrMixin.onRendered()\n          finally\n            delete @component._componentInternals.inOnRendered\n\n        onDestroyed: ->\n          @autorun (computation) =>\n            # @ is a template instance.\n\n            # We wait for all children components to be destroyed first.\n            # See https://github.com/meteor/meteor/issues/4166\n            return if @component.childComponents().length\n            computation.stop()\n\n            Tracker.nonreactive =>\n              assert.equal @component._componentInternals.isCreated(), true\n\n              @component._componentInternals.isCreated false\n\n              @component._componentInternals.isRendered ?= new ReactiveField false\n              @component._componentInternals.isRendered false\n\n              @component._componentInternals.isDestroyed ?= new ReactiveField true\n              @component._componentInternals.isDestroyed true\n\n              componentOrMixin = null\n              while componentOrMixin = @component.getFirstWith componentOrMixin, 'onDestroyed'\n                componentOrMixin.onDestroyed()\n\n              if parentComponent\n                # The component has been destroyed, clear up the parent.\n                component.parentComponent null\n                parentComponent.removeChildComponent component\n\n              # Remove the reference so that it is clear that template instance is not available anymore.\n              @component._componentInternals.templateInstance null\n\n      template\n\n  removeComponent: ->\n    Blaze.remove @_componentInternals.templateInstance().view if @isRendered()\n\n  @renderComponentToHTML: (parentComponent, parentView, data) ->\n    component = Tracker.nonreactive =>\n      componentClass = @\n\n      parentView = parentView or currentViewIfRendering() or (parentComponent?.isRendered() and parentComponent._componentInternals.templateInstance().view) or null\n\n      wrapViewAndTemplate parentView, =>\n        new componentClass()\n\n    if arguments.length > 2\n      component.renderComponentToHTML parentComponent, parentView, data\n    else\n      component.renderComponentToHTML parentComponent, parentView\n\n  renderComponentToHTML: (parentComponent, parentView, data) ->\n    template = Tracker.nonreactive =>\n      parentView = parentView or currentViewIfRendering() or (parentComponent?.isRendered() and parentComponent._componentInternals.templateInstance().view) or null\n\n      wrapViewAndTemplate parentView, =>\n        @renderComponent parentComponent\n\n    if arguments.length > 2\n      expandedView = expandView Blaze._TemplateWith(data, contentAsFunc template), parentView\n    else\n      expandedView = expandView contentAsView(template), parentView\n\n    HTML.toHTML expandedView\n\n  template: ->\n    @callFirstWith(@, 'template') or @constructor.componentName()\n\n  onCreated: ->\n    callTemplateBaseHooks @, 'created'\n\n  onRendered: ->\n    callTemplateBaseHooks @, 'rendered'\n\n  onDestroyed: ->\n    callTemplateBaseHooks @, 'destroyed'\n\n  isCreated: ->\n    @_componentInternals ?= {}\n    @_componentInternals.isCreated ?= new ReactiveField false\n\n    @_componentInternals.isCreated()\n\n  isRendered: ->\n    @_componentInternals ?= {}\n    @_componentInternals.isRendered ?= new ReactiveField false\n\n    @_componentInternals.isRendered()\n\n  isDestroyed: ->\n    @_componentInternals ?= {}\n    @_componentInternals.isDestroyed ?= new ReactiveField false\n\n    @_componentInternals.isDestroyed()\n\n  insertDOMElement: (parent, node, before) ->\n    before ?= null\n    if parent and node and (node.parentNode isnt parent or node.nextSibling isnt before)\n      parent.insertBefore node, before\n\n    return\n\n  moveDOMElement: (parent, node, before) ->\n    before ?= null\n    if parent and node and (node.parentNode isnt parent or node.nextSibling isnt before)\n      parent.insertBefore node, before\n\n    return\n\n  removeDOMElement: (parent, node) ->\n    if parent and node and node.parentNode is parent\n      parent.removeChild node\n\n    return\n\n  events: ->\n    @_componentInternals ?= {}\n\n    # In mixins we do not have a template instance. There is also\n    # no reason for a template instance to extend a Blaze template.\n    return [] unless @_componentInternals.templateInstance\n\n    view = Tracker.nonreactive =>\n      @_componentInternals.templateInstance().view\n    # We skip block helpers to match Blaze behavior.\n    templateInstance = getTemplateInstanceFunction view, true\n\n    for events in @_componentInternals.templateBase.__eventMaps\n      eventMap = {}\n\n      for spec, handler of events\n        do (spec, handler) ->\n          eventMap[spec] = (args...) ->\n            # In template event handlers view and template instance are not based on the current target\n            # (like Blaze Components event handlers are) but it is based on the template-level view.\n            # In a way we are reverting here what addEvents does.\n            withTemplateInstanceFunc templateInstance, ->\n              Blaze._withCurrentView view, ->\n                handler.apply view, args\n\n      eventMap\n\n  # Component-level data context. Reactive. Use this to always get the\n  # top-level data context used to render the component. If path is\n  # provided, it returns only the value under that path, with reactivity\n  # limited to changes of that value only.\n  data: (path, equalsFunc) ->\n    @_componentInternals ?= {}\n    @_componentInternals.templateInstance ?= new ReactiveField null, (a, b) -> a is b\n\n    if view = @_componentInternals.templateInstance()?.view\n      if path?\n        return DataLookup.get =>\n          Blaze.getData view\n        ,\n          path, equalsFunc\n      else\n        return Blaze.getData view\n\n    undefined\n\n  # Caller-level data context. Reactive. Use this to get in event handlers the data\n  # context at the place where event originated (target context). In template helpers\n  # the data context where template helpers were called. In onCreated, onRendered,\n  # and onDestroyed, the same as @data(). Inside a template this is the same as this.\n  # If path is provided, it returns only the value under that path, with reactivity\n  # limited to changes of that value only. Moreover, if path is provided is also\n  # looks into the current lexical scope data.\n  @currentData: (path, equalsFunc) ->\n    return undefined unless Blaze.currentView\n\n    currentView = Blaze.currentView\n\n    if _.isString path\n      path = path.split '.'\n    else if not _.isArray path\n      return Blaze.getData currentView\n\n    DataLookup.get =>\n      if Blaze._lexicalBindingLookup and lexicalData = Blaze._lexicalBindingLookup currentView, path[0]\n        # We return custom data object so that we can reuse the same\n        # lookup logic for both lexical and the normal data context case.\n        result = {}\n        result[path[0]] = lexicalData\n        return result\n\n      Blaze.getData currentView\n    ,\n      path, equalsFunc\n\n  # Method should never be overridden. The implementation should always be exactly the same as class method implementation.\n  currentData: (path, equalsFunc) ->\n    @constructor.currentData path, equalsFunc\n\n  # Useful in templates to get a reference to the component.\n  component: ->\n    @\n\n  # Caller-level component. In most cases the same as @, but in event handlers\n  # it returns the component at the place where event originated (target component).\n  # Inside template content wrapped with a block helper component, it is the closest\n  # block helper component.\n  @currentComponent: ->\n    # We are not skipping block helpers because one of main reasons for @currentComponent()\n    # is that we can get hold of the block helper component instance.\n    templateInstance = getTemplateInstanceFunction Blaze.currentView, false\n    templateInstanceToComponent templateInstance, false\n\n  # Method should never be overridden. The implementation should always be exactly the same as class method implementation.\n  currentComponent: ->\n    @constructor.currentComponent()\n\n  firstNode: ->\n    return @_componentInternals.templateInstance().view._domrange.firstNode() if @isRendered()\n\n    undefined\n\n  lastNode: ->\n    return @_componentInternals.templateInstance().view._domrange.lastNode() if @isRendered()\n\n    undefined\n\n  # The same as it would be generated automatically, only that the runFunc gets bound to the component.\n  autorun: (runFunc) ->\n    templateInstance = Tracker.nonreactive =>\n      @_componentInternals?.templateInstance?()\n\n    throw new Error \"The component has to be created before calling 'autorun'.\" unless templateInstance\n\n    templateInstance.autorun _.bind runFunc, @\n\nSUPPORTS_REACTIVE_INSTANCE = [\n  'subscriptionsReady'\n]\n\nREQUIRE_RENDERED_INSTANCE = [\n  '$',\n  'find',\n  'findAll'\n]\n\n# We copy utility methods ($, findAll, subscribe, etc.) from the template instance prototype,\n# if a method with the same name does not exist already.\nfor methodName, method of (Blaze.TemplateInstance::) when methodName not of (BlazeComponent::)\n  do (methodName, method) ->\n    if methodName in SUPPORTS_REACTIVE_INSTANCE\n      BlazeComponent::[methodName] = (args...) ->\n        @_componentInternals ?= {}\n        @_componentInternals.templateInstance ?= new ReactiveField null, (a, b) -> a is b\n\n        if templateInstance = @_componentInternals.templateInstance()\n          return templateInstance[methodName] args...\n\n        undefined\n\n    else if methodName in REQUIRE_RENDERED_INSTANCE\n      BlazeComponent::[methodName] = (args...) ->\n        return @_componentInternals.templateInstance()[methodName] args... if @isRendered()\n\n        undefined\n\n    else\n      BlazeComponent::[methodName] = (args...) ->\n        templateInstance = Tracker.nonreactive =>\n          @_componentInternals?.templateInstance?()\n\n        throw new Error \"The component has to be created before calling '#{methodName}'.\" unless templateInstance\n\n        templateInstance[methodName] args...\n"]}}