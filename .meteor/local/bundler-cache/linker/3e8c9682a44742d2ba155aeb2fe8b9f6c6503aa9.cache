[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar humanize, MongoObject, Utility, SimpleSchema, doValidation1, doValidation2, SimpleSchemaValidationContext;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/string-polyfills.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (!String.prototype.startsWith) {                                                                                    // 1\n  String.prototype.startsWith = function(searchString, position) {                                                     // 2\n    position = position || 0;                                                                                          // 3\n    return this.indexOf(searchString, position) === position;                                                          // 4\n  };                                                                                                                   // 5\n}                                                                                                                      // 6\n                                                                                                                       // 7\nif (!String.prototype.trim) {                                                                                          // 8\n  String.prototype.trim = function () {                                                                                // 9\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');                                                     // 10\n  };                                                                                                                   // 11\n}                                                                                                                      // 12\n                                                                                                                       // 13\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/string-humanize.js                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/*                                                                                                                     // 1\n  Code source:                                                                                                         // 2\n    https://github.com/jxson/string-humanize                                                                           // 3\n    https://github.com/jxson/string-capitalize                                                                         // 4\n */                                                                                                                    // 5\n                                                                                                                       // 6\nfunction capitalize(string){                                                                                           // 7\n  string = string || '';                                                                                               // 8\n  string = string.trim();                                                                                              // 9\n                                                                                                                       // 10\n  if (string[0]) {                                                                                                     // 11\n    string = string[0].toUpperCase() + string.substr(1).toLowerCase();                                                 // 12\n  }                                                                                                                    // 13\n                                                                                                                       // 14\n  return string;                                                                                                       // 15\n}                                                                                                                      // 16\n                                                                                                                       // 17\nhumanize = function humanize(string){                                                                                  // 18\n  string = string || '';                                                                                               // 19\n  string = string.toString(); // might be a number                                                                     // 20\n  string = string.trim();                                                                                              // 21\n  string = string.replace(extname(string), '');                                                                        // 22\n  string = underscore(string);                                                                                         // 23\n  string = string.replace(/[\\W_]+/g, ' ');                                                                             // 24\n                                                                                                                       // 25\n  return capitalize(string);                                                                                           // 26\n}                                                                                                                      // 27\n                                                                                                                       // 28\n                                                                                                                       // 29\nfunction underscore(string){                                                                                           // 30\n  string = string || '';                                                                                               // 31\n  string = string.toString(); // might be a number                                                                     // 32\n  string = string.trim();                                                                                              // 33\n  string = string.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2');                                                              // 34\n  string = string.replace(/[-\\s]+/g, '_').toLowerCase();                                                               // 35\n                                                                                                                       // 36\n  return string;                                                                                                       // 37\n}                                                                                                                      // 38\n                                                                                                                       // 39\nfunction extname(string){                                                                                              // 40\n  var index = string.lastIndexOf('.');                                                                                 // 41\n  var ext = string.substring(index, string.length);                                                                    // 42\n                                                                                                                       // 43\n  return (index === -1) ? '' : ext;                                                                                    // 44\n}                                                                                                                      // 45\n                                                                                                                       // 46\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/mongo-object.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global MongoObject:true */                                                                                          // 1\n                                                                                                                       // 2\n                                                                                                                       // 3\nvar isObject = function(obj) {                                                                                         // 4\n  return obj === Object(obj);                                                                                          // 5\n};                                                                                                                     // 6\n                                                                                                                       // 7\n// getPrototypeOf polyfill                                                                                             // 8\nif (typeof Object.getPrototypeOf !== \"function\") {                                                                     // 9\n  if (typeof \"\".__proto__ === \"object\") {                                                                              // 10\n    Object.getPrototypeOf = function(object) {                                                                         // 11\n      return object.__proto__;                                                                                         // 12\n    };                                                                                                                 // 13\n  } else {                                                                                                             // 14\n    Object.getPrototypeOf = function(object) {                                                                         // 15\n      // May break if the constructor has been tampered with                                                           // 16\n      return object.constructor.prototype;                                                                             // 17\n    };                                                                                                                 // 18\n  }                                                                                                                    // 19\n}                                                                                                                      // 20\n                                                                                                                       // 21\n/* Tests whether \"obj\" is an Object as opposed to                                                                      // 22\n * something that inherits from Object                                                                                 // 23\n *                                                                                                                     // 24\n * @param {any} obj                                                                                                    // 25\n * @returns {Boolean}                                                                                                  // 26\n */                                                                                                                    // 27\nvar isBasicObject = function(obj) {                                                                                    // 28\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;                                             // 29\n};                                                                                                                     // 30\n                                                                                                                       // 31\n/* Takes a specific string that uses mongo-style dot notation                                                          // 32\n * and returns a generic string equivalent. Replaces all numeric                                                       // 33\n * \"pieces\" with a dollar sign ($).                                                                                    // 34\n *                                                                                                                     // 35\n * @param {type} name                                                                                                  // 36\n * @returns {unresolved}                                                                                               // 37\n */                                                                                                                    // 38\nvar makeGeneric = function makeGeneric(name) {                                                                         // 39\n  if (typeof name !== \"string\") {                                                                                      // 40\n    return null;                                                                                                       // 41\n  }                                                                                                                    // 42\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+$/g, '.$');                                               // 43\n};                                                                                                                     // 44\n                                                                                                                       // 45\nvar appendAffectedKey = function appendAffectedKey(affectedKey, key) {                                                 // 46\n  if (key === \"$each\") {                                                                                               // 47\n    return affectedKey;                                                                                                // 48\n  } else {                                                                                                             // 49\n    return (affectedKey ? affectedKey + \".\" + key : key);                                                              // 50\n  }                                                                                                                    // 51\n};                                                                                                                     // 52\n                                                                                                                       // 53\n// Extracts operator piece, if present, from position string                                                           // 54\nvar extractOp = function extractOp(position) {                                                                         // 55\n  var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));                                                   // 56\n  return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;                                     // 57\n};                                                                                                                     // 58\n                                                                                                                       // 59\n/*                                                                                                                     // 60\n * @constructor                                                                                                        // 61\n * @param {Object} objOrModifier                                                                                       // 62\n * @param {string[]} blackBoxKeys - A list of the names of keys that shouldn't be traversed                            // 63\n * @returns {undefined}                                                                                                // 64\n *                                                                                                                     // 65\n * Creates a new MongoObject instance. The object passed as the first argument                                         // 66\n * will be modified in place by calls to instance methods. Also, immediately                                           // 67\n * upon creation of the instance, the object will have any `undefined` keys                                            // 68\n * removed recursively.                                                                                                // 69\n */                                                                                                                    // 70\nMongoObject = function(objOrModifier, blackBoxKeys) {                                                                  // 71\n  var self = this;                                                                                                     // 72\n  self._obj = objOrModifier;                                                                                           // 73\n  self._affectedKeys = {};                                                                                             // 74\n  self._genericAffectedKeys = {};                                                                                      // 75\n  self._parentPositions = [];                                                                                          // 76\n  self._positionsInsideArrays = [];                                                                                    // 77\n  self._objectPositions = [];                                                                                          // 78\n                                                                                                                       // 79\n  function parseObj(val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {                            // 80\n                                                                                                                       // 81\n    // Adjust for first-level modifier operators                                                                       // 82\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {                                             // 83\n      operator = affectedKey;                                                                                          // 84\n      affectedKey = null;                                                                                              // 85\n    }                                                                                                                  // 86\n                                                                                                                       // 87\n    var affectedKeyIsBlackBox = false;                                                                                 // 88\n    var affectedKeyGeneric;                                                                                            // 89\n    var stop = false;                                                                                                  // 90\n    if (affectedKey) {                                                                                                 // 91\n                                                                                                                       // 92\n      // Adjust for $push and $addToSet and $pull and $pop                                                             // 93\n      if (!adjusted) {                                                                                                 // 94\n        if (operator === \"$push\" || operator === \"$addToSet\" || operator === \"$pop\") {                                 // 95\n          // Adjust for $each                                                                                          // 96\n          // We can simply jump forward and pretend like the $each array                                               // 97\n          // is the array for the field. This has the added benefit of                                                 // 98\n          // skipping past any $slice, which we also don't care about.                                                 // 99\n          if (isBasicObject(val) && \"$each\" in val) {                                                                  // 100\n            val = val.$each;                                                                                           // 101\n            currentPosition = currentPosition + \"[$each]\";                                                             // 102\n          } else {                                                                                                     // 103\n            affectedKey = affectedKey + \".0\";                                                                          // 104\n          }                                                                                                            // 105\n          adjusted = true;                                                                                             // 106\n        } else if (operator === \"$pull\") {                                                                             // 107\n          affectedKey = affectedKey + \".0\";                                                                            // 108\n          if (isBasicObject(val)) {                                                                                    // 109\n            stop = true;                                                                                               // 110\n          }                                                                                                            // 111\n          adjusted = true;                                                                                             // 112\n        }                                                                                                              // 113\n      }                                                                                                                // 114\n                                                                                                                       // 115\n      // Make generic key                                                                                              // 116\n      affectedKeyGeneric = makeGeneric(affectedKey);                                                                   // 117\n                                                                                                                       // 118\n      // Determine whether affected key should be treated as a black box                                               // 119\n      affectedKeyIsBlackBox = _.contains(blackBoxKeys, affectedKeyGeneric);                                            // 120\n                                                                                                                       // 121\n      // Mark that this position affects this generic and non-generic key                                              // 122\n      if (currentPosition) {                                                                                           // 123\n        self._affectedKeys[currentPosition] = affectedKey;                                                             // 124\n        self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;                                               // 125\n                                                                                                                       // 126\n        // If we're within an array, mark this position so we can omit it from flat docs                               // 127\n        isWithinArray && self._positionsInsideArrays.push(currentPosition);                                            // 128\n      }                                                                                                                // 129\n    }                                                                                                                  // 130\n                                                                                                                       // 131\n    if (stop) {                                                                                                        // 132\n      return;                                                                                                          // 133\n    }                                                                                                                  // 134\n                                                                                                                       // 135\n    // Loop through arrays                                                                                             // 136\n    if (_.isArray(val) && !_.isEmpty(val)) {                                                                           // 137\n      if (currentPosition) {                                                                                           // 138\n        // Mark positions with arrays that should be ignored when we want endpoints only                               // 139\n        self._parentPositions.push(currentPosition);                                                                   // 140\n      }                                                                                                                // 141\n                                                                                                                       // 142\n      // Loop                                                                                                          // 143\n      _.each(val, function(v, i) {                                                                                     // 144\n        parseObj(v, (currentPosition ? currentPosition + \"[\" + i + \"]\" : i), affectedKey + '.' + i, operator, adjusted, true);\n      });                                                                                                              // 146\n    }                                                                                                                  // 147\n                                                                                                                       // 148\n    // Loop through object keys, only for basic objects,                                                               // 149\n    // but always for the passed-in object, even if it                                                                 // 150\n    // is a custom object.                                                                                             // 151\n    else if ((isBasicObject(val) && !affectedKeyIsBlackBox) || !currentPosition) {                                     // 152\n      if (currentPosition && !_.isEmpty(val)) {                                                                        // 153\n        // Mark positions with objects that should be ignored when we want endpoints only                              // 154\n        self._parentPositions.push(currentPosition);                                                                   // 155\n        // Mark positions with objects that should be left out of flat docs.                                           // 156\n        self._objectPositions.push(currentPosition);                                                                   // 157\n      }                                                                                                                // 158\n      // Loop                                                                                                          // 159\n      _.each(val, function(v, k) {                                                                                     // 160\n        if (v === void 0) {                                                                                            // 161\n          delete val[k];                                                                                               // 162\n        } else if (k !== \"$slice\") {                                                                                   // 163\n          parseObj(v, (currentPosition ? currentPosition + \"[\" + k + \"]\" : k), appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\n        }                                                                                                              // 165\n      });                                                                                                              // 166\n    }                                                                                                                  // 167\n                                                                                                                       // 168\n  }                                                                                                                    // 169\n  parseObj(self._obj);                                                                                                 // 170\n                                                                                                                       // 171\n  function reParseObj() {                                                                                              // 172\n    self._affectedKeys = {};                                                                                           // 173\n    self._genericAffectedKeys = {};                                                                                    // 174\n    self._parentPositions = [];                                                                                        // 175\n    self._positionsInsideArrays = [];                                                                                  // 176\n    self._objectPositions = [];                                                                                        // 177\n    parseObj(self._obj);                                                                                               // 178\n  }                                                                                                                    // 179\n                                                                                                                       // 180\n  /**                                                                                                                  // 181\n   * @method MongoObject.forEachNode                                                                                   // 182\n   * @param {Function} func                                                                                            // 183\n   * @param {Object} [options]                                                                                         // 184\n   * @param {Boolean} [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n   * @returns {undefined}                                                                                              // 186\n   *                                                                                                                   // 187\n   * Runs a function for each endpoint node in the object tree, including all items in every array.                    // 188\n   * The function arguments are                                                                                        // 189\n   * (1) the value at this node                                                                                        // 190\n   * (2) a string representing the node position                                                                       // 191\n   * (3) the representation of what would be changed in mongo, using mongo dot notation                                // 192\n   * (4) the generic equivalent of argument 3, with \"$\" instead of numeric pieces                                      // 193\n   */                                                                                                                  // 194\n  self.forEachNode = function(func, options) {                                                                         // 195\n    if (typeof func !== \"function\") {                                                                                  // 196\n      throw new Error(\"filter requires a loop function\");                                                              // 197\n    }                                                                                                                  // 198\n                                                                                                                       // 199\n    options = _.extend({                                                                                               // 200\n      endPointsOnly: true                                                                                              // 201\n    }, options);                                                                                                       // 202\n                                                                                                                       // 203\n    var updatedValues = {};                                                                                            // 204\n    _.each(self._affectedKeys, function(affectedKey, position) {                                                       // 205\n      if (options.endPointsOnly && _.contains(self._parentPositions, position)) {                                      // 206\n        return; //only endpoints                                                                                       // 207\n      }                                                                                                                // 208\n      func.call({                                                                                                      // 209\n        value: self.getValueForPosition(position),                                                                     // 210\n        operator: extractOp(position),                                                                                 // 211\n        position: position,                                                                                            // 212\n        key: affectedKey,                                                                                              // 213\n        genericKey: self._genericAffectedKeys[position],                                                               // 214\n        updateValue: function(newVal) {                                                                                // 215\n          updatedValues[position] = newVal;                                                                            // 216\n        },                                                                                                             // 217\n        remove: function() {                                                                                           // 218\n          updatedValues[position] = void 0;                                                                            // 219\n        }                                                                                                              // 220\n      });                                                                                                              // 221\n    });                                                                                                                // 222\n                                                                                                                       // 223\n    // Actually update/remove values as instructed                                                                     // 224\n    _.each(updatedValues, function(newVal, position) {                                                                 // 225\n      self.setValueForPosition(position, newVal);                                                                      // 226\n    });                                                                                                                // 227\n                                                                                                                       // 228\n  };                                                                                                                   // 229\n                                                                                                                       // 230\n  self.getValueForPosition = function(position) {                                                                      // 231\n    var subkey, subkeys = position.split(\"[\"), current = self._obj;                                                    // 232\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {                                                                // 233\n      subkey = subkeys[i];                                                                                             // 234\n      // If the subkey ends in \"]\", remove the ending                                                                  // 235\n      if (subkey.slice(-1) === \"]\") {                                                                                  // 236\n        subkey = subkey.slice(0, -1);                                                                                  // 237\n      }                                                                                                                // 238\n      current = current[subkey];                                                                                       // 239\n      if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {                                              // 240\n        return;                                                                                                        // 241\n      }                                                                                                                // 242\n    }                                                                                                                  // 243\n    return current;                                                                                                    // 244\n  };                                                                                                                   // 245\n                                                                                                                       // 246\n  /**                                                                                                                  // 247\n   * @method MongoObject.prototype.setValueForPosition                                                                 // 248\n   * @param {String} position                                                                                          // 249\n   * @param {Any} value                                                                                                // 250\n   * @returns {undefined}                                                                                              // 251\n   */                                                                                                                  // 252\n  self.setValueForPosition = function(position, value) {                                                               // 253\n    var nextPiece, subkey, subkeys = position.split(\"[\"), current = self._obj;                                         // 254\n                                                                                                                       // 255\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {                                                                // 256\n      subkey = subkeys[i];                                                                                             // 257\n      // If the subkey ends in \"]\", remove the ending                                                                  // 258\n      if (subkey.slice(-1) === \"]\") {                                                                                  // 259\n        subkey = subkey.slice(0, -1);                                                                                  // 260\n      }                                                                                                                // 261\n      // If we've reached the key in the object tree that needs setting or                                             // 262\n      // deleting, do it.                                                                                              // 263\n      if (i === ln - 1) {                                                                                              // 264\n        current[subkey] = value;                                                                                       // 265\n        //if value is undefined, delete the property                                                                   // 266\n        if (value === void 0) {                                                                                        // 267\n          delete current[subkey];                                                                                      // 268\n        }                                                                                                              // 269\n      }                                                                                                                // 270\n      // Otherwise attempt to keep moving deeper into the object.                                                      // 271\n      else {                                                                                                           // 272\n        // If we're setting (as opposed to deleting) a key and we hit a place                                          // 273\n        // in the ancestor chain where the keys are not yet created, create them.                                      // 274\n        if (current[subkey] === void 0 && value !== void 0) {                                                          // 275\n          //see if the next piece is a number                                                                          // 276\n          nextPiece = subkeys[i + 1];                                                                                  // 277\n          nextPiece = parseInt(nextPiece, 10);                                                                         // 278\n          current[subkey] = isNaN(nextPiece) ? {} : [];                                                                // 279\n        }                                                                                                              // 280\n                                                                                                                       // 281\n        // Move deeper into the object                                                                                 // 282\n        current = current[subkey];                                                                                     // 283\n                                                                                                                       // 284\n        // If we can go no further, then quit                                                                          // 285\n        if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {                                            // 286\n          return;                                                                                                      // 287\n        }                                                                                                              // 288\n      }                                                                                                                // 289\n    }                                                                                                                  // 290\n                                                                                                                       // 291\n    reParseObj();                                                                                                      // 292\n  };                                                                                                                   // 293\n                                                                                                                       // 294\n  /**                                                                                                                  // 295\n   * @method MongoObject.prototype.removeValueForPosition                                                              // 296\n   * @param {String} position                                                                                          // 297\n   * @returns {undefined}                                                                                              // 298\n   */                                                                                                                  // 299\n  self.removeValueForPosition = function(position) {                                                                   // 300\n    self.setValueForPosition(position, void 0);                                                                        // 301\n  };                                                                                                                   // 302\n                                                                                                                       // 303\n  /**                                                                                                                  // 304\n   * @method MongoObject.prototype.getKeyForPosition                                                                   // 305\n   * @param {String} position                                                                                          // 306\n   * @returns {undefined}                                                                                              // 307\n   */                                                                                                                  // 308\n  self.getKeyForPosition = function(position) {                                                                        // 309\n    return self._affectedKeys[position];                                                                               // 310\n  };                                                                                                                   // 311\n                                                                                                                       // 312\n  /**                                                                                                                  // 313\n   * @method MongoObject.prototype.getGenericKeyForPosition                                                            // 314\n   * @param {String} position                                                                                          // 315\n   * @returns {undefined}                                                                                              // 316\n   */                                                                                                                  // 317\n  self.getGenericKeyForPosition = function(position) {                                                                 // 318\n    return self._genericAffectedKeys[position];                                                                        // 319\n  };                                                                                                                   // 320\n                                                                                                                       // 321\n  /**                                                                                                                  // 322\n   * @method MongoObject.getInfoForKey                                                                                 // 323\n   * @param {String} key - Non-generic key                                                                             // 324\n   * @returns {undefined|Object}                                                                                       // 325\n   *                                                                                                                   // 326\n   * Returns the value and operator of the requested non-generic key.                                                  // 327\n   * Example: {value: 1, operator: \"$pull\"}                                                                            // 328\n   */                                                                                                                  // 329\n  self.getInfoForKey = function(key) {                                                                                 // 330\n    // Get the info                                                                                                    // 331\n    var position = self.getPositionForKey(key);                                                                        // 332\n    if (position) {                                                                                                    // 333\n      return {                                                                                                         // 334\n        value: self.getValueForPosition(position),                                                                     // 335\n        operator: extractOp(position)                                                                                  // 336\n      };                                                                                                               // 337\n    }                                                                                                                  // 338\n                                                                                                                       // 339\n    // If we haven't returned yet, check to see if there is an array value                                             // 340\n    // corresponding to this key                                                                                       // 341\n    // We find the first item within the array, strip the last piece off the                                           // 342\n    // position string, and then return whatever is at that new position in                                            // 343\n    // the original object.                                                                                            // 344\n    var positions = self.getPositionsForGenericKey(key + \".$\"), p, v;                                                  // 345\n    for (var i = 0, ln = positions.length; i < ln; i++) {                                                              // 346\n      p = positions[i];                                                                                                // 347\n      v = self.getValueForPosition(p) || self.getValueForPosition(p.slice(0, p.lastIndexOf(\"[\")));                     // 348\n      if (v) {                                                                                                         // 349\n        return {                                                                                                       // 350\n          value: v,                                                                                                    // 351\n          operator: extractOp(p)                                                                                       // 352\n        };                                                                                                             // 353\n      }                                                                                                                // 354\n    }                                                                                                                  // 355\n  };                                                                                                                   // 356\n                                                                                                                       // 357\n  /**                                                                                                                  // 358\n   * @method MongoObject.getPositionForKey                                                                             // 359\n   * @param {String} key - Non-generic key                                                                             // 360\n   * @returns {undefined|String} Position string                                                                       // 361\n   *                                                                                                                   // 362\n   * Returns the position string for the place in the object that                                                      // 363\n   * affects the requested non-generic key.                                                                            // 364\n   * Example: 'foo[bar][0]'                                                                                            // 365\n   */                                                                                                                  // 366\n  self.getPositionForKey = function(key) {                                                                             // 367\n    // Get the info                                                                                                    // 368\n    for (var position in self._affectedKeys) {                                                                         // 369\n      if (self._affectedKeys.hasOwnProperty(position)) {                                                               // 370\n        if (self._affectedKeys[position] === key) {                                                                    // 371\n          // We return the first one we find. While it's                                                               // 372\n          // possible that multiple update operators could                                                             // 373\n          // affect the same non-generic key, we'll assume that's not the case.                                        // 374\n          return position;                                                                                             // 375\n        }                                                                                                              // 376\n      }                                                                                                                // 377\n    }                                                                                                                  // 378\n                                                                                                                       // 379\n    // If we haven't returned yet, we need to check for affected keys                                                  // 380\n  };                                                                                                                   // 381\n                                                                                                                       // 382\n  /**                                                                                                                  // 383\n   * @method MongoObject.getPositionsForGenericKey                                                                     // 384\n   * @param {String} key - Generic key                                                                                 // 385\n   * @returns {String[]} Array of position strings                                                                     // 386\n   *                                                                                                                   // 387\n   * Returns an array of position strings for the places in the object that                                            // 388\n   * affect the requested generic key.                                                                                 // 389\n   * Example: ['foo[bar][0]']                                                                                          // 390\n   */                                                                                                                  // 391\n  self.getPositionsForGenericKey = function(key) {                                                                     // 392\n    // Get the info                                                                                                    // 393\n    var list = [];                                                                                                     // 394\n    for (var position in self._genericAffectedKeys) {                                                                  // 395\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 396\n        if (self._genericAffectedKeys[position] === key) {                                                             // 397\n          list.push(position);                                                                                         // 398\n        }                                                                                                              // 399\n      }                                                                                                                // 400\n    }                                                                                                                  // 401\n                                                                                                                       // 402\n    return list;                                                                                                       // 403\n  };                                                                                                                   // 404\n                                                                                                                       // 405\n  /**                                                                                                                  // 406\n   * @deprecated Use getInfoForKey                                                                                     // 407\n   * @method MongoObject.getValueForKey                                                                                // 408\n   * @param {String} key - Non-generic key                                                                             // 409\n   * @returns {undefined|Any}                                                                                          // 410\n   *                                                                                                                   // 411\n   * Returns the value of the requested non-generic key                                                                // 412\n   */                                                                                                                  // 413\n  self.getValueForKey = function(key) {                                                                                // 414\n    var position = self.getPositionForKey(key);                                                                        // 415\n    if (position) {                                                                                                    // 416\n      return self.getValueForPosition(position);                                                                       // 417\n    }                                                                                                                  // 418\n  };                                                                                                                   // 419\n                                                                                                                       // 420\n  /**                                                                                                                  // 421\n   * @method MongoObject.prototype.addKey                                                                              // 422\n   * @param {String} key - Key to set                                                                                  // 423\n   * @param {Any} val - Value to give this key                                                                         // 424\n   * @param {String} op - Operator under which to set it, or `null` for a non-modifier object                          // 425\n   * @returns {undefined}                                                                                              // 426\n   *                                                                                                                   // 427\n   * Adds `key` with value `val` under operator `op` to the source object.                                             // 428\n   */                                                                                                                  // 429\n  self.addKey = function(key, val, op) {                                                                               // 430\n    var position = op ? op + \"[\" + key + \"]\" : MongoObject._keyToPosition(key);                                        // 431\n    self.setValueForPosition(position, val);                                                                           // 432\n  };                                                                                                                   // 433\n                                                                                                                       // 434\n  /**                                                                                                                  // 435\n   * @method MongoObject.prototype.removeGenericKeys                                                                   // 436\n   * @param {String[]} keys                                                                                            // 437\n   * @returns {undefined}                                                                                              // 438\n   *                                                                                                                   // 439\n   * Removes anything that affects any of the generic keys in the list                                                 // 440\n   */                                                                                                                  // 441\n  self.removeGenericKeys = function(keys) {                                                                            // 442\n    for (var position in self._genericAffectedKeys) {                                                                  // 443\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 444\n        if (_.contains(keys, self._genericAffectedKeys[position])) {                                                   // 445\n          self.removeValueForPosition(position);                                                                       // 446\n        }                                                                                                              // 447\n      }                                                                                                                // 448\n    }                                                                                                                  // 449\n  };                                                                                                                   // 450\n                                                                                                                       // 451\n  /**                                                                                                                  // 452\n   * @method MongoObject.removeGenericKey                                                                              // 453\n   * @param {String} key                                                                                               // 454\n   * @returns {undefined}                                                                                              // 455\n   *                                                                                                                   // 456\n   * Removes anything that affects the requested generic key                                                           // 457\n   */                                                                                                                  // 458\n  self.removeGenericKey = function(key) {                                                                              // 459\n    for (var position in self._genericAffectedKeys) {                                                                  // 460\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 461\n        if (self._genericAffectedKeys[position] === key) {                                                             // 462\n          self.removeValueForPosition(position);                                                                       // 463\n        }                                                                                                              // 464\n      }                                                                                                                // 465\n    }                                                                                                                  // 466\n  };                                                                                                                   // 467\n                                                                                                                       // 468\n  /**                                                                                                                  // 469\n   * @method MongoObject.removeKey                                                                                     // 470\n   * @param {String} key                                                                                               // 471\n   * @returns {undefined}                                                                                              // 472\n   *                                                                                                                   // 473\n   * Removes anything that affects the requested non-generic key                                                       // 474\n   */                                                                                                                  // 475\n  self.removeKey = function(key) {                                                                                     // 476\n    // We don't use getPositionForKey here because we want to be sure to                                               // 477\n    // remove for all positions if there are multiple.                                                                 // 478\n    for (var position in self._affectedKeys) {                                                                         // 479\n      if (self._affectedKeys.hasOwnProperty(position)) {                                                               // 480\n        if (self._affectedKeys[position] === key) {                                                                    // 481\n          self.removeValueForPosition(position);                                                                       // 482\n        }                                                                                                              // 483\n      }                                                                                                                // 484\n    }                                                                                                                  // 485\n  };                                                                                                                   // 486\n                                                                                                                       // 487\n  /**                                                                                                                  // 488\n   * @method MongoObject.removeKeys                                                                                    // 489\n   * @param {String[]} keys                                                                                            // 490\n   * @returns {undefined}                                                                                              // 491\n   *                                                                                                                   // 492\n   * Removes anything that affects any of the non-generic keys in the list                                             // 493\n   */                                                                                                                  // 494\n  self.removeKeys = function(keys) {                                                                                   // 495\n    for (var i = 0, ln = keys.length; i < ln; i++) {                                                                   // 496\n      self.removeKey(keys[i]);                                                                                         // 497\n    }                                                                                                                  // 498\n  };                                                                                                                   // 499\n                                                                                                                       // 500\n  /**                                                                                                                  // 501\n   * @method MongoObject.filterGenericKeys                                                                             // 502\n   * @param {Function} test - Test function                                                                            // 503\n   * @returns {undefined}                                                                                              // 504\n   *                                                                                                                   // 505\n   * Passes all affected keys to a test function, which                                                                // 506\n   * should return false to remove whatever is affecting that key                                                      // 507\n   */                                                                                                                  // 508\n  self.filterGenericKeys = function(test) {                                                                            // 509\n    var gk, checkedKeys = [], keysToRemove = [];                                                                       // 510\n    for (var position in self._genericAffectedKeys) {                                                                  // 511\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 512\n        gk = self._genericAffectedKeys[position];                                                                      // 513\n        if (!_.contains(checkedKeys, gk)) {                                                                            // 514\n          checkedKeys.push(gk);                                                                                        // 515\n          if (gk && !test(gk)) {                                                                                       // 516\n            keysToRemove.push(gk);                                                                                     // 517\n          }                                                                                                            // 518\n        }                                                                                                              // 519\n      }                                                                                                                // 520\n    }                                                                                                                  // 521\n                                                                                                                       // 522\n    _.each(keysToRemove, function(key) {                                                                               // 523\n      self.removeGenericKey(key);                                                                                      // 524\n    });                                                                                                                // 525\n  };                                                                                                                   // 526\n                                                                                                                       // 527\n  /**                                                                                                                  // 528\n   * @method MongoObject.setValueForKey                                                                                // 529\n   * @param {String} key                                                                                               // 530\n   * @param {Any} val                                                                                                  // 531\n   * @returns {undefined}                                                                                              // 532\n   *                                                                                                                   // 533\n   * Sets the value for every place in the object that affects                                                         // 534\n   * the requested non-generic key                                                                                     // 535\n   */                                                                                                                  // 536\n  self.setValueForKey = function(key, val) {                                                                           // 537\n    // We don't use getPositionForKey here because we want to be sure to                                               // 538\n    // set the value for all positions if there are multiple.                                                          // 539\n    for (var position in self._affectedKeys) {                                                                         // 540\n      if (self._affectedKeys.hasOwnProperty(position)) {                                                               // 541\n        if (self._affectedKeys[position] === key) {                                                                    // 542\n          self.setValueForPosition(position, val);                                                                     // 543\n        }                                                                                                              // 544\n      }                                                                                                                // 545\n    }                                                                                                                  // 546\n  };                                                                                                                   // 547\n                                                                                                                       // 548\n  /**                                                                                                                  // 549\n   * @method MongoObject.setValueForGenericKey                                                                         // 550\n   * @param {String} key                                                                                               // 551\n   * @param {Any} val                                                                                                  // 552\n   * @returns {undefined}                                                                                              // 553\n   *                                                                                                                   // 554\n   * Sets the value for every place in the object that affects                                                         // 555\n   * the requested generic key                                                                                         // 556\n   */                                                                                                                  // 557\n  self.setValueForGenericKey = function(key, val) {                                                                    // 558\n    // We don't use getPositionForKey here because we want to be sure to                                               // 559\n    // set the value for all positions if there are multiple.                                                          // 560\n    for (var position in self._genericAffectedKeys) {                                                                  // 561\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 562\n        if (self._genericAffectedKeys[position] === key) {                                                             // 563\n          self.setValueForPosition(position, val);                                                                     // 564\n        }                                                                                                              // 565\n      }                                                                                                                // 566\n    }                                                                                                                  // 567\n  };                                                                                                                   // 568\n                                                                                                                       // 569\n  /**                                                                                                                  // 570\n   * @method MongoObject.getObject                                                                                     // 571\n   * @returns {Object}                                                                                                 // 572\n   *                                                                                                                   // 573\n   * Get the source object, potentially modified by other method calls on this                                         // 574\n   * MongoObject instance.                                                                                             // 575\n   */                                                                                                                  // 576\n  self.getObject = function() {                                                                                        // 577\n    return self._obj;                                                                                                  // 578\n  };                                                                                                                   // 579\n                                                                                                                       // 580\n  /**                                                                                                                  // 581\n   * @method MongoObject.getFlatObject                                                                                 // 582\n   * @returns {Object}                                                                                                 // 583\n   *                                                                                                                   // 584\n   * Gets a flat object based on the MongoObject instance.                                                             // 585\n   * In a flat object, the key is the name of the non-generic affectedKey,                                             // 586\n   * with mongo dot notation if necessary, and the value is the value for                                              // 587\n   * that key.                                                                                                         // 588\n   *                                                                                                                   // 589\n   * With `keepArrays: true`, we don't flatten within arrays. Currently                                                // 590\n   * MongoDB does not see a key such as `a.0.b` and automatically assume                                               // 591\n   * an array. Instead it would create an object with key \"0\" if there                                                 // 592\n   * wasn't already an array saved as the value of `a`, which is rarely                                                // 593\n   * if ever what we actually want. To avoid this confusion, we                                                        // 594\n   * set entire arrays.                                                                                                // 595\n   */                                                                                                                  // 596\n  self.getFlatObject = function(options) {                                                                             // 597\n    options = options || {};                                                                                           // 598\n    var newObj = {};                                                                                                   // 599\n    _.each(self._affectedKeys, function(affectedKey, position) {                                                       // 600\n      if (typeof affectedKey === \"string\" &&                                                                           // 601\n        (options.keepArrays === true && !_.contains(self._positionsInsideArrays, position) && !_.contains(self._objectPositions, position)) ||\n        (!options.keepArrays && !_.contains(self._parentPositions, position))                                          // 603\n        ) {                                                                                                            // 604\n        newObj[affectedKey] = self.getValueForPosition(position);                                                      // 605\n      }                                                                                                                // 606\n    });                                                                                                                // 607\n    return newObj;                                                                                                     // 608\n  };                                                                                                                   // 609\n                                                                                                                       // 610\n  /**                                                                                                                  // 611\n   * @method MongoObject.affectsKey                                                                                    // 612\n   * @param {String} key                                                                                               // 613\n   * @returns {Object}                                                                                                 // 614\n   *                                                                                                                   // 615\n   * Returns true if the non-generic key is affected by this object                                                    // 616\n   */                                                                                                                  // 617\n  self.affectsKey = function(key) {                                                                                    // 618\n    return !!self.getPositionForKey(key);                                                                              // 619\n  };                                                                                                                   // 620\n                                                                                                                       // 621\n  /**                                                                                                                  // 622\n   * @method MongoObject.affectsGenericKey                                                                             // 623\n   * @param {String} key                                                                                               // 624\n   * @returns {Object}                                                                                                 // 625\n   *                                                                                                                   // 626\n   * Returns true if the generic key is affected by this object                                                        // 627\n   */                                                                                                                  // 628\n  self.affectsGenericKey = function(key) {                                                                             // 629\n    for (var position in self._genericAffectedKeys) {                                                                  // 630\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 631\n        if (self._genericAffectedKeys[position] === key) {                                                             // 632\n          return true;                                                                                                 // 633\n        }                                                                                                              // 634\n      }                                                                                                                // 635\n    }                                                                                                                  // 636\n    return false;                                                                                                      // 637\n  };                                                                                                                   // 638\n                                                                                                                       // 639\n  /**                                                                                                                  // 640\n   * @method MongoObject.affectsGenericKeyImplicit                                                                     // 641\n   * @param {String} key                                                                                               // 642\n   * @returns {Object}                                                                                                 // 643\n   *                                                                                                                   // 644\n   * Like affectsGenericKey, but will return true if a child key is affected                                           // 645\n   */                                                                                                                  // 646\n  self.affectsGenericKeyImplicit = function(key) {                                                                     // 647\n    for (var position in self._genericAffectedKeys) {                                                                  // 648\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {                                                        // 649\n        var affectedKey = self._genericAffectedKeys[position];                                                         // 650\n                                                                                                                       // 651\n        // If the affected key is the test key                                                                         // 652\n        if (affectedKey === key) {                                                                                     // 653\n          return true;                                                                                                 // 654\n        }                                                                                                              // 655\n                                                                                                                       // 656\n        // If the affected key implies the test key because the affected key                                           // 657\n        // starts with the test key followed by a period                                                               // 658\n        if (affectedKey.substring(0, key.length + 1) === key + \".\") {                                                  // 659\n          return true;                                                                                                 // 660\n        }                                                                                                              // 661\n                                                                                                                       // 662\n        // If the affected key implies the test key because the affected key                                           // 663\n        // starts with the test key and the test key ends with \".$\"                                                    // 664\n        var lastTwo = key.slice(-2);                                                                                   // 665\n        if (lastTwo === \".$\" && key.slice(0, -2) === affectedKey) {                                                    // 666\n          return true;                                                                                                 // 667\n        }                                                                                                              // 668\n      }                                                                                                                // 669\n    }                                                                                                                  // 670\n    return false;                                                                                                      // 671\n  };                                                                                                                   // 672\n};                                                                                                                     // 673\n                                                                                                                       // 674\n/** Takes a string representation of an object key and its value                                                       // 675\n *  and updates \"obj\" to contain that key with that value.                                                             // 676\n *                                                                                                                     // 677\n *  Example keys and results if val is 1:                                                                              // 678\n *    \"a\" -> {a: 1}                                                                                                    // 679\n *    \"a[b]\" -> {a: {b: 1}}                                                                                            // 680\n *    \"a[b][0]\" -> {a: {b: [1]}}                                                                                       // 681\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}                                                                                  // 682\n */                                                                                                                    // 683\n                                                                                                                       // 684\n/** Takes a string representation of an object key and its value                                                       // 685\n *  and updates \"obj\" to contain that key with that value.                                                             // 686\n *                                                                                                                     // 687\n *  Example keys and results if val is 1:                                                                              // 688\n *    \"a\" -> {a: 1}                                                                                                    // 689\n *    \"a[b]\" -> {a: {b: 1}}                                                                                            // 690\n *    \"a[b][0]\" -> {a: {b: [1]}}                                                                                       // 691\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}                                                                                  // 692\n *                                                                                                                     // 693\n * @param {any} val                                                                                                    // 694\n * @param {String} key                                                                                                 // 695\n * @param {Object} obj                                                                                                 // 696\n * @returns {undefined}                                                                                                // 697\n */                                                                                                                    // 698\nMongoObject.expandKey = function(val, key, obj) {                                                                      // 699\n  var nextPiece, subkey, subkeys = key.split(\"[\"), current = obj;                                                      // 700\n  for (var i = 0, ln = subkeys.length; i < ln; i++) {                                                                  // 701\n    subkey = subkeys[i];                                                                                               // 702\n    if (subkey.slice(-1) === \"]\") {                                                                                    // 703\n      subkey = subkey.slice(0, -1);                                                                                    // 704\n    }                                                                                                                  // 705\n    if (i === ln - 1) {                                                                                                // 706\n      //last iteration; time to set the value; always overwrite                                                        // 707\n      current[subkey] = val;                                                                                           // 708\n      //if val is undefined, delete the property                                                                       // 709\n      if (val === void 0) {                                                                                            // 710\n        delete current[subkey];                                                                                        // 711\n      }                                                                                                                // 712\n    } else {                                                                                                           // 713\n      //see if the next piece is a number                                                                              // 714\n      nextPiece = subkeys[i + 1];                                                                                      // 715\n      nextPiece = parseInt(nextPiece, 10);                                                                             // 716\n      if (!current[subkey]) {                                                                                          // 717\n        current[subkey] = isNaN(nextPiece) ? {} : [];                                                                  // 718\n      }                                                                                                                // 719\n    }                                                                                                                  // 720\n    current = current[subkey];                                                                                         // 721\n  }                                                                                                                    // 722\n};                                                                                                                     // 723\n                                                                                                                       // 724\nMongoObject._keyToPosition = function keyToPosition(key, wrapAll) {                                                    // 725\n  var position = '';                                                                                                   // 726\n  _.each(key.split(\".\"), function (piece, i) {                                                                         // 727\n    if (i === 0 && !wrapAll) {                                                                                         // 728\n      position += piece;                                                                                               // 729\n    } else {                                                                                                           // 730\n      position += \"[\" + piece + \"]\";                                                                                   // 731\n    }                                                                                                                  // 732\n  });                                                                                                                  // 733\n  return position;                                                                                                     // 734\n};                                                                                                                     // 735\n                                                                                                                       // 736\n/**                                                                                                                    // 737\n * @method MongoObject._positionToKey                                                                                  // 738\n * @param {String} position                                                                                            // 739\n * @returns {String} The key that this position in an object would affect.                                             // 740\n *                                                                                                                     // 741\n * This is different from MongoObject.prototype.getKeyForPosition in that                                              // 742\n * this method does not depend on the requested position actually being                                                // 743\n * present in any particular MongoObject.                                                                              // 744\n */                                                                                                                    // 745\nMongoObject._positionToKey = function positionToKey(position) {                                                        // 746\n  //XXX Probably a better way to do this, but this is                                                                  // 747\n  //foolproof for now.                                                                                                 // 748\n  var mDoc = new MongoObject({});                                                                                      // 749\n  mDoc.setValueForPosition(position, 1); //value doesn't matter                                                        // 750\n  var key = mDoc.getKeyForPosition(position);                                                                          // 751\n  mDoc = null;                                                                                                         // 752\n  return key;                                                                                                          // 753\n};                                                                                                                     // 754\n                                                                                                                       // 755\n                                                                                                                       // 756\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-utility.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility:true */                                                                                              // 1\n                                                                                                                       // 2\nUtility = {                                                                                                            // 3\n  appendAffectedKey: function appendAffectedKey(affectedKey, key) {                                                    // 4\n    if (key === \"$each\") {                                                                                             // 5\n      return affectedKey;                                                                                              // 6\n    } else {                                                                                                           // 7\n      return (affectedKey ? affectedKey + \".\" + key : key);                                                            // 8\n    }                                                                                                                  // 9\n  },                                                                                                                   // 10\n  shouldCheck: function shouldCheck(key) {                                                                             // 11\n    if (key === \"$pushAll\") {                                                                                          // 12\n      throw new Error(\"$pushAll is not supported; use $push + $each\");                                                 // 13\n    }                                                                                                                  // 14\n    return !_.contains([\"$pull\", \"$pullAll\", \"$pop\", \"$slice\"], key);                                                  // 15\n  },                                                                                                                   // 16\n  errorObject: function errorObject(errorType, keyName, keyValue) {                                                    // 17\n    return {name: keyName, type: errorType, value: keyValue};                                                          // 18\n  },                                                                                                                   // 19\n  // Tests whether it's an Object as opposed to something that inherits from Object                                    // 20\n  isBasicObject: function isBasicObject(obj) {                                                                         // 21\n    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;                                         // 22\n  },                                                                                                                   // 23\n  // The latest Safari returns false for Uint8Array, etc. instanceof Function                                          // 24\n  // unlike other browsers.                                                                                            // 25\n  safariBugFix: function safariBugFix(type) {                                                                          // 26\n    return (typeof Uint8Array !== \"undefined\" && type === Uint8Array) ||                                               // 27\n      (typeof Uint16Array !== \"undefined\" && type === Uint16Array) ||                                                  // 28\n      (typeof Uint32Array !== \"undefined\" && type === Uint32Array) ||                                                  // 29\n      (typeof Uint8ClampedArray !== \"undefined\" && type === Uint8ClampedArray);                                        // 30\n  },                                                                                                                   // 31\n  isNotNullOrUndefined: function isNotNullOrUndefined(val) {                                                           // 32\n    return val !== void 0 && val !== null;                                                                             // 33\n  },                                                                                                                   // 34\n  // Extracts operator piece, if present, from position string                                                         // 35\n  extractOp: function extractOp(position) {                                                                            // 36\n    var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));                                                 // 37\n    return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;                                   // 38\n  },                                                                                                                   // 39\n  deleteIfPresent: function deleteIfPresent(obj, key) {                                                                // 40\n    if (key in obj) {                                                                                                  // 41\n      delete obj[key];                                                                                                 // 42\n    }                                                                                                                  // 43\n  },                                                                                                                   // 44\n  looksLikeModifier: function looksLikeModifier(obj) {                                                                 // 45\n    for (var key in obj) {                                                                                             // 46\n      if (obj.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {                                                    // 47\n        return true;                                                                                                   // 48\n      }                                                                                                                // 49\n    }                                                                                                                  // 50\n    return false;                                                                                                      // 51\n  },                                                                                                                   // 52\n  dateToDateString: function dateToDateString(date) {                                                                  // 53\n    var m = (date.getUTCMonth() + 1);                                                                                  // 54\n    if (m < 10) {                                                                                                      // 55\n      m = \"0\" + m;                                                                                                     // 56\n    }                                                                                                                  // 57\n    var d = date.getUTCDate();                                                                                         // 58\n    if (d < 10) {                                                                                                      // 59\n      d = \"0\" + d;                                                                                                     // 60\n    }                                                                                                                  // 61\n    return date.getUTCFullYear() + '-' + m + '-' + d;                                                                  // 62\n  }                                                                                                                    // 63\n};                                                                                                                     // 64\n                                                                                                                       // 65\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema.js                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global SimpleSchema:true */                                                                                         // 1\n/* global SimpleSchemaValidationContext */                                                                             // 2\n/* global MongoObject */                                                                                               // 3\n/* global Utility */                                                                                                   // 4\n                                                                                                                       // 5\nvar schemaDefinition = {                                                                                               // 6\n  type: Match.Any,                                                                                                     // 7\n  label: Match.Optional(Match.OneOf(String, Function)),                                                                // 8\n  optional: Match.Optional(Match.OneOf(Boolean, Function)),                                                            // 9\n  min: Match.Optional(Match.OneOf(Number, Date, Function)),                                                            // 10\n  max: Match.Optional(Match.OneOf(Number, Date, Function)),                                                            // 11\n  minCount: Match.Optional(Match.OneOf(Number, Function)),                                                             // 12\n  maxCount: Match.Optional(Match.OneOf(Number, Function)),                                                             // 13\n  allowedValues: Match.Optional(Match.OneOf([Match.Any], Function)),                                                   // 14\n  decimal: Match.Optional(Boolean),                                                                                    // 15\n  exclusiveMax: Match.Optional(Boolean),                                                                               // 16\n  exclusiveMin: Match.Optional(Boolean),                                                                               // 17\n  regEx: Match.Optional(Match.OneOf(RegExp, [RegExp])),                                                                // 18\n  custom: Match.Optional(Function),                                                                                    // 19\n  blackbox: Match.Optional(Boolean),                                                                                   // 20\n  autoValue: Match.Optional(Function),                                                                                 // 21\n  defaultValue: Match.Optional(Match.Any),                                                                             // 22\n  trim: Match.Optional(Boolean)                                                                                        // 23\n};                                                                                                                     // 24\n                                                                                                                       // 25\n/*                                                                                                                     // 26\n * PRIVATE FUNCTIONS                                                                                                   // 27\n */                                                                                                                    // 28\n                                                                                                                       // 29\n//called by clean()                                                                                                    // 30\nvar typeconvert = function(value, type) {                                                                              // 31\n  var parsedDate;                                                                                                      // 32\n                                                                                                                       // 33\n  if (_.isArray(value) || (_.isObject(value) && !(value instanceof Date))) {                                           // 34\n    return value; //can't and shouldn't convert arrays or objects                                                      // 35\n  }                                                                                                                    // 36\n  if (type === String) {                                                                                               // 37\n    if (typeof value !== \"undefined\" && value !== null && typeof value !== \"string\") {                                 // 38\n      return value.toString();                                                                                         // 39\n    }                                                                                                                  // 40\n    return value;                                                                                                      // 41\n  }                                                                                                                    // 42\n  if (type === Number) {                                                                                               // 43\n    if (typeof value === \"string\" && !_.isEmpty(value)) {                                                              // 44\n      //try to convert numeric strings to numbers                                                                      // 45\n      var numberVal = Number(value);                                                                                   // 46\n      if (!isNaN(numberVal)) {                                                                                         // 47\n        return numberVal;                                                                                              // 48\n      } else {                                                                                                         // 49\n        return value; //leave string; will fail validation                                                             // 50\n      }                                                                                                                // 51\n    }                                                                                                                  // 52\n    return value;                                                                                                      // 53\n  }                                                                                                                    // 54\n  //                                                                                                                   // 55\n  // If target type is a Date we can safely convert from either a                                                      // 56\n  // number (Integer value representing the number of milliseconds                                                     // 57\n  // since 1 January 1970 00:00:00 UTC) or a string that can be parsed                                                 // 58\n  // by Date.                                                                                                          // 59\n  //                                                                                                                   // 60\n  if (type === Date) {                                                                                                 // 61\n    if (typeof value === \"string\") {                                                                                   // 62\n      parsedDate = Date.parse(value);                                                                                  // 63\n      if (isNaN(parsedDate) === false) {                                                                               // 64\n        return new Date(parsedDate);                                                                                   // 65\n      }                                                                                                                // 66\n    }                                                                                                                  // 67\n    if (typeof value === \"number\") {                                                                                   // 68\n      return new Date(value);                                                                                          // 69\n    }                                                                                                                  // 70\n  }                                                                                                                    // 71\n  return value;                                                                                                        // 72\n};                                                                                                                     // 73\n                                                                                                                       // 74\nvar expandSchema = function(schema) {                                                                                  // 75\n  // Flatten schema by inserting nested definitions                                                                    // 76\n  _.each(schema, function(val, key) {                                                                                  // 77\n    var dot, type;                                                                                                     // 78\n    if (!val) {                                                                                                        // 79\n      return;                                                                                                          // 80\n    }                                                                                                                  // 81\n    if (Match.test(val.type, SimpleSchema)) {                                                                          // 82\n      dot = '.';                                                                                                       // 83\n      type = val.type;                                                                                                 // 84\n      val.type = Object;                                                                                               // 85\n    } else if (Match.test(val.type, [SimpleSchema])) {                                                                 // 86\n      dot = '.$.';                                                                                                     // 87\n      type = val.type[0];                                                                                              // 88\n      val.type = [Object];                                                                                             // 89\n    } else {                                                                                                           // 90\n      return;                                                                                                          // 91\n    }                                                                                                                  // 92\n    //add child schema definitions to parent schema                                                                    // 93\n    _.each(type._schema, function(subVal, subKey) {                                                                    // 94\n      var newKey = key + dot + subKey;                                                                                 // 95\n      if (!(newKey in schema)) {                                                                                       // 96\n        schema[newKey] = subVal;                                                                                       // 97\n      }                                                                                                                // 98\n    });                                                                                                                // 99\n  });                                                                                                                  // 100\n  return schema;                                                                                                       // 101\n};                                                                                                                     // 102\n                                                                                                                       // 103\nvar adjustArrayFields = function(schema) {                                                                             // 104\n  _.each(schema, function(def, existingKey) {                                                                          // 105\n    if (_.isArray(def.type) || def.type === Array) {                                                                   // 106\n      // Copy some options to array-item definition                                                                    // 107\n      var itemKey = existingKey + \".$\";                                                                                // 108\n      if (!(itemKey in schema)) {                                                                                      // 109\n        schema[itemKey] = {};                                                                                          // 110\n      }                                                                                                                // 111\n      if (_.isArray(def.type)) {                                                                                       // 112\n        schema[itemKey].type = def.type[0];                                                                            // 113\n      }                                                                                                                // 114\n      if (def.label) {                                                                                                 // 115\n        schema[itemKey].label = def.label;                                                                             // 116\n      }                                                                                                                // 117\n      schema[itemKey].optional = true;                                                                                 // 118\n      if (typeof def.min !== \"undefined\") {                                                                            // 119\n        schema[itemKey].min = def.min;                                                                                 // 120\n      }                                                                                                                // 121\n      if (typeof def.max !== \"undefined\") {                                                                            // 122\n        schema[itemKey].max = def.max;                                                                                 // 123\n      }                                                                                                                // 124\n      if (typeof def.allowedValues !== \"undefined\") {                                                                  // 125\n        schema[itemKey].allowedValues = def.allowedValues;                                                             // 126\n      }                                                                                                                // 127\n      if (typeof def.decimal !== \"undefined\") {                                                                        // 128\n        schema[itemKey].decimal = def.decimal;                                                                         // 129\n      }                                                                                                                // 130\n      if (typeof def.exclusiveMax !== \"undefined\") {                                                                   // 131\n        schema[itemKey].exclusiveMax = def.exclusiveMax;                                                               // 132\n      }                                                                                                                // 133\n      if (typeof def.exclusiveMin !== \"undefined\") {                                                                   // 134\n        schema[itemKey].exclusiveMin = def.exclusiveMin;                                                               // 135\n      }                                                                                                                // 136\n      if (typeof def.regEx !== \"undefined\") {                                                                          // 137\n        schema[itemKey].regEx = def.regEx;                                                                             // 138\n      }                                                                                                                // 139\n      if (typeof def.blackbox !== \"undefined\") {                                                                       // 140\n        schema[itemKey].blackbox = def.blackbox;                                                                       // 141\n      }                                                                                                                // 142\n      // Remove copied options and adjust type                                                                         // 143\n      def.type = Array;                                                                                                // 144\n      _.each(['min', 'max', 'allowedValues', 'decimal', 'exclusiveMax', 'exclusiveMin', 'regEx', 'blackbox'], function(k) {\n        Utility.deleteIfPresent(def, k);                                                                               // 146\n      });                                                                                                              // 147\n    }                                                                                                                  // 148\n  });                                                                                                                  // 149\n};                                                                                                                     // 150\n                                                                                                                       // 151\n/**                                                                                                                    // 152\n * Adds implied keys.                                                                                                  // 153\n * * If schema contains a key like \"foo.$.bar\" but not \"foo\", adds \"foo\".                                              // 154\n * * If schema contains a key like \"foo\" with an array type, adds \"foo.$\".                                             // 155\n * @param {Object} schema                                                                                              // 156\n * @returns {Object} modified schema                                                                                   // 157\n */                                                                                                                    // 158\nvar addImplicitKeys = function(schema) {                                                                               // 159\n  var arrayKeysToAdd = [], objectKeysToAdd = [], newKey, key, i, ln;                                                   // 160\n                                                                                                                       // 161\n  // Pass 1 (objects)                                                                                                  // 162\n  _.each(schema, function(def, existingKey) {                                                                          // 163\n    var pos = existingKey.indexOf(\".\");                                                                                // 164\n    while (pos !== -1) {                                                                                               // 165\n      newKey = existingKey.substring(0, pos);                                                                          // 166\n                                                                                                                       // 167\n      // It's an array item; nothing to add                                                                            // 168\n      if (newKey.substring(newKey.length - 2) === \".$\") {                                                              // 169\n        pos = -1;                                                                                                      // 170\n      }                                                                                                                // 171\n      // It's an array of objects; add it with type [Object] if not already in the schema                              // 172\n      else if (existingKey.substring(pos, pos + 3) === \".$.\") {                                                        // 173\n        arrayKeysToAdd.push(newKey); // add later, since we are iterating over schema right now                        // 174\n        pos = existingKey.indexOf(\".\", pos + 3); // skip over next dot, find the one after                             // 175\n      }                                                                                                                // 176\n      // It's an object; add it with type Object if not already in the schema                                          // 177\n      else {                                                                                                           // 178\n        objectKeysToAdd.push(newKey); // add later, since we are iterating over schema right now                       // 179\n        pos = existingKey.indexOf(\".\", pos + 1); // find next dot                                                      // 180\n      }                                                                                                                // 181\n    }                                                                                                                  // 182\n  });                                                                                                                  // 183\n                                                                                                                       // 184\n  for (i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {                                                               // 185\n    key = arrayKeysToAdd[i];                                                                                           // 186\n    if (!(key in schema)) {                                                                                            // 187\n      schema[key] = {type: [Object], optional: true};                                                                  // 188\n    }                                                                                                                  // 189\n  }                                                                                                                    // 190\n                                                                                                                       // 191\n  for (i = 0, ln = objectKeysToAdd.length; i < ln; i++) {                                                              // 192\n    key = objectKeysToAdd[i];                                                                                          // 193\n    if (!(key in schema)) {                                                                                            // 194\n      schema[key] = {type: Object, optional: true};                                                                    // 195\n    }                                                                                                                  // 196\n  }                                                                                                                    // 197\n                                                                                                                       // 198\n  // Pass 2 (arrays)                                                                                                   // 199\n  adjustArrayFields(schema);                                                                                           // 200\n                                                                                                                       // 201\n  return schema;                                                                                                       // 202\n};                                                                                                                     // 203\n                                                                                                                       // 204\nvar mergeSchemas = function(schemas) {                                                                                 // 205\n                                                                                                                       // 206\n  // Merge all provided schema definitions.                                                                            // 207\n  // This is effectively a shallow clone of each object, too,                                                          // 208\n  // which is what we want since we are going to manipulate it.                                                        // 209\n  var mergedSchema = {};                                                                                               // 210\n  _.each(schemas, function(schema) {                                                                                   // 211\n                                                                                                                       // 212\n    // Create a temporary SS instance so that the internal object                                                      // 213\n    // we use for merging/extending will be fully expanded                                                             // 214\n    if (Match.test(schema, SimpleSchema)) {                                                                            // 215\n      schema = schema._schema;                                                                                         // 216\n    } else {                                                                                                           // 217\n      schema = addImplicitKeys(expandSchema(schema));                                                                  // 218\n    }                                                                                                                  // 219\n                                                                                                                       // 220\n    // Loop through and extend each individual field                                                                   // 221\n    // definition. That way you can extend and overwrite                                                               // 222\n    // base field definitions.                                                                                         // 223\n    _.each(schema, function(def, field) {                                                                              // 224\n      mergedSchema[field] = mergedSchema[field] || {};                                                                 // 225\n      _.extend(mergedSchema[field], def);                                                                              // 226\n    });                                                                                                                // 227\n                                                                                                                       // 228\n  });                                                                                                                  // 229\n                                                                                                                       // 230\n  // If we merged some schemas, do this again to make sure                                                             // 231\n  // extended definitions are pushed into array item field                                                             // 232\n  // definitions properly.                                                                                             // 233\n  schemas.length && adjustArrayFields(mergedSchema);                                                                   // 234\n                                                                                                                       // 235\n  return mergedSchema;                                                                                                 // 236\n};                                                                                                                     // 237\n                                                                                                                       // 238\n// Returns an object relating the keys in the list                                                                     // 239\n// to their parent object.                                                                                             // 240\nvar getObjectKeys = function(schema, schemaKeyList) {                                                                  // 241\n  var keyPrefix, remainingText, rKeys = {}, loopArray;                                                                 // 242\n  _.each(schema, function(definition, fieldName) {                                                                     // 243\n    if (definition.type === Object) {                                                                                  // 244\n      //object                                                                                                         // 245\n      keyPrefix = fieldName + \".\";                                                                                     // 246\n    } else {                                                                                                           // 247\n      return;                                                                                                          // 248\n    }                                                                                                                  // 249\n                                                                                                                       // 250\n    loopArray = [];                                                                                                    // 251\n    _.each(schemaKeyList, function(fieldName2) {                                                                       // 252\n      if (fieldName2.startsWith(keyPrefix)) {                                                                          // 253\n        remainingText = fieldName2.substring(keyPrefix.length);                                                        // 254\n        if (remainingText.indexOf(\".\") === -1) {                                                                       // 255\n          loopArray.push(remainingText);                                                                               // 256\n        }                                                                                                              // 257\n      }                                                                                                                // 258\n    });                                                                                                                // 259\n    rKeys[keyPrefix] = loopArray;                                                                                      // 260\n  });                                                                                                                  // 261\n  return rKeys;                                                                                                        // 262\n};                                                                                                                     // 263\n                                                                                                                       // 264\n// returns an inflected version of fieldName to use as the label                                                       // 265\nvar inflectedLabel = function(fieldName) {                                                                             // 266\n  var label = fieldName, lastPeriod = label.lastIndexOf(\".\");                                                          // 267\n  if (lastPeriod !== -1) {                                                                                             // 268\n    label = label.substring(lastPeriod + 1);                                                                           // 269\n    if (label === \"$\") {                                                                                               // 270\n      var pcs = fieldName.split(\".\");                                                                                  // 271\n      label = pcs[pcs.length - 2];                                                                                     // 272\n    }                                                                                                                  // 273\n  }                                                                                                                    // 274\n  if (label === \"_id\") {                                                                                               // 275\n    return \"ID\";                                                                                                       // 276\n  }                                                                                                                    // 277\n  return humanize(label);                                                                                              // 278\n};                                                                                                                     // 279\n                                                                                                                       // 280\n/**                                                                                                                    // 281\n * @method getAutoValues                                                                                               // 282\n * @private                                                                                                            // 283\n * @param {MongoObject} mDoc                                                                                           // 284\n * @param {Boolean} [isModifier=false] - Is it a modifier doc?                                                         // 285\n * @param {Object} [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\n * @returns {undefined}                                                                                                // 287\n *                                                                                                                     // 288\n * Updates doc with automatic values from autoValue functions or default                                               // 289\n * values from defaultValue. Modifies the referenced object in place.                                                  // 290\n */                                                                                                                    // 291\nfunction getAutoValues(mDoc, isModifier, extendedAutoValueContext) {                                                   // 292\n  var self = this;                                                                                                     // 293\n  var doneKeys = [];                                                                                                   // 294\n                                                                                                                       // 295\n  //on the client we can add the userId if not already in the custom context                                           // 296\n  if (Meteor.isClient && extendedAutoValueContext.userId === void 0) {                                                 // 297\n    extendedAutoValueContext.userId = (Meteor.userId && Meteor.userId()) || null;                                      // 298\n  }                                                                                                                    // 299\n                                                                                                                       // 300\n  function runAV(func) {                                                                                               // 301\n    var affectedKey = this.key;                                                                                        // 302\n    // If already called for this key, skip it                                                                         // 303\n    if (_.contains(doneKeys, affectedKey)) {                                                                           // 304\n      return;                                                                                                          // 305\n    }                                                                                                                  // 306\n    var lastDot = affectedKey.lastIndexOf('.');                                                                        // 307\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);                                     // 308\n    var doUnset = false;                                                                                               // 309\n    var autoValue = func.call(_.extend({                                                                               // 310\n      isSet: (this.value !== void 0),                                                                                  // 311\n      unset: function() {                                                                                              // 312\n        doUnset = true;                                                                                                // 313\n      },                                                                                                               // 314\n      value: this.value,                                                                                               // 315\n      operator: this.operator,                                                                                         // 316\n      field: function(fName) {                                                                                         // 317\n        var keyInfo = mDoc.getInfoForKey(fName) || {};                                                                 // 318\n        return {                                                                                                       // 319\n          isSet: (keyInfo.value !== void 0),                                                                           // 320\n          value: keyInfo.value,                                                                                        // 321\n          operator: keyInfo.operator || null                                                                           // 322\n        };                                                                                                             // 323\n      },                                                                                                               // 324\n      siblingField: function(fName) {                                                                                  // 325\n        var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};                                               // 326\n        return {                                                                                                       // 327\n          isSet: (keyInfo.value !== void 0),                                                                           // 328\n          value: keyInfo.value,                                                                                        // 329\n          operator: keyInfo.operator || null                                                                           // 330\n        };                                                                                                             // 331\n      }                                                                                                                // 332\n    }, extendedAutoValueContext || {}), mDoc.getObject());                                                             // 333\n                                                                                                                       // 334\n    // Update tracking of which keys we've run autovalue for                                                           // 335\n    doneKeys.push(affectedKey);                                                                                        // 336\n                                                                                                                       // 337\n    if (autoValue === void 0) {                                                                                        // 338\n      if (doUnset) {                                                                                                   // 339\n        mDoc.removeValueForPosition(this.position);                                                                    // 340\n      }                                                                                                                // 341\n      return;                                                                                                          // 342\n    }                                                                                                                  // 343\n                                                                                                                       // 344\n    // If the user's auto value is of the pseudo-modifier format, parse it                                             // 345\n    // into operator and value.                                                                                        // 346\n    var op, newValue;                                                                                                  // 347\n    if (_.isObject(autoValue)) {                                                                                       // 348\n      for (var key in autoValue) {                                                                                     // 349\n        if (autoValue.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {                                            // 350\n          op = key;                                                                                                    // 351\n          newValue = autoValue[key];                                                                                   // 352\n          break;                                                                                                       // 353\n        }                                                                                                              // 354\n      }                                                                                                                // 355\n    }                                                                                                                  // 356\n                                                                                                                       // 357\n    // Add $set for updates and upserts if necessary                                                                   // 358\n    if (!op && isModifier && this.position.slice(0, 1) !== '$') {                                                      // 359\n      op = \"$set\";                                                                                                     // 360\n      newValue = autoValue;                                                                                            // 361\n    }                                                                                                                  // 362\n                                                                                                                       // 363\n    // Update/change value                                                                                             // 364\n    if (op) {                                                                                                          // 365\n      mDoc.removeValueForPosition(this.position);                                                                      // 366\n      mDoc.setValueForPosition(op + '[' + affectedKey + ']', newValue);                                                // 367\n    } else {                                                                                                           // 368\n      mDoc.setValueForPosition(this.position, autoValue);                                                              // 369\n    }                                                                                                                  // 370\n  }                                                                                                                    // 371\n                                                                                                                       // 372\n  _.each(self._autoValues, function(func, fieldName) {                                                                 // 373\n    var positionSuffix, key, keySuffix, positions;                                                                     // 374\n                                                                                                                       // 375\n    // If we're under an array, run autovalue for all the properties of                                                // 376\n    // any objects that are present in the nearest ancestor array.                                                     // 377\n    if (fieldName.indexOf(\"$\") !== -1) {                                                                               // 378\n      var testField = fieldName.slice(0, fieldName.lastIndexOf(\"$\") + 1);                                              // 379\n      keySuffix = fieldName.slice(testField.length + 1);                                                               // 380\n      positionSuffix = MongoObject._keyToPosition(keySuffix, true);                                                    // 381\n      keySuffix = '.' + keySuffix;                                                                                     // 382\n      positions = mDoc.getPositionsForGenericKey(testField);                                                           // 383\n    } else {                                                                                                           // 384\n                                                                                                                       // 385\n      // See if anything in the object affects this key                                                                // 386\n      positions = mDoc.getPositionsForGenericKey(fieldName);                                                           // 387\n                                                                                                                       // 388\n      // Run autovalue for properties that are set in the object                                                       // 389\n      if (positions.length) {                                                                                          // 390\n        key = fieldName;                                                                                               // 391\n        keySuffix = '';                                                                                                // 392\n        positionSuffix = '';                                                                                           // 393\n      }                                                                                                                // 394\n                                                                                                                       // 395\n      // Run autovalue for properties that are NOT set in the object                                                   // 396\n      else {                                                                                                           // 397\n        key = fieldName;                                                                                               // 398\n        keySuffix = '';                                                                                                // 399\n        positionSuffix = '';                                                                                           // 400\n        if (isModifier) {                                                                                              // 401\n          positions = [\"$set[\" + fieldName + \"]\"];                                                                     // 402\n        } else {                                                                                                       // 403\n          positions = [MongoObject._keyToPosition(fieldName)];                                                         // 404\n        }                                                                                                              // 405\n      }                                                                                                                // 406\n                                                                                                                       // 407\n    }                                                                                                                  // 408\n                                                                                                                       // 409\n    _.each(positions, function(position) {                                                                             // 410\n      runAV.call({                                                                                                     // 411\n        key: (key || MongoObject._positionToKey(position)) + keySuffix,                                                // 412\n        value: mDoc.getValueForPosition(position + positionSuffix),                                                    // 413\n        operator: Utility.extractOp(position),                                                                         // 414\n        position: position + positionSuffix                                                                            // 415\n      }, func);                                                                                                        // 416\n    });                                                                                                                // 417\n  });                                                                                                                  // 418\n}                                                                                                                      // 419\n                                                                                                                       // 420\n//exported                                                                                                             // 421\nSimpleSchema = function(schemas, options) {                                                                            // 422\n  var self = this;                                                                                                     // 423\n  var firstLevelSchemaKeys = [];                                                                                       // 424\n  var fieldNameRoot;                                                                                                   // 425\n  options = options || {};                                                                                             // 426\n  schemas = schemas || {};                                                                                             // 427\n                                                                                                                       // 428\n  if (!_.isArray(schemas)) {                                                                                           // 429\n    schemas = [schemas];                                                                                               // 430\n  }                                                                                                                    // 431\n                                                                                                                       // 432\n  // adjust and store a copy of the schema definitions                                                                 // 433\n  self._schema = mergeSchemas(schemas);                                                                                // 434\n                                                                                                                       // 435\n  // store the list of defined keys for speedier checking                                                              // 436\n  self._schemaKeys = [];                                                                                               // 437\n                                                                                                                       // 438\n  // store autoValue functions by key                                                                                  // 439\n  self._autoValues = {};                                                                                               // 440\n                                                                                                                       // 441\n  // store the list of blackbox keys for passing to MongoObject constructor                                            // 442\n  self._blackboxKeys = [];                                                                                             // 443\n                                                                                                                       // 444\n  // a place to store custom validators for this instance                                                              // 445\n  self._validators = [];                                                                                               // 446\n                                                                                                                       // 447\n  // a place to store custom error messages for this schema                                                            // 448\n  self._messages = {};                                                                                                 // 449\n                                                                                                                       // 450\n  self._depsMessages = new Deps.Dependency();                                                                          // 451\n  self._depsLabels = {};                                                                                               // 452\n                                                                                                                       // 453\n  _.each(self._schema, function(definition, fieldName) {                                                               // 454\n    // Validate the field definition                                                                                   // 455\n    if (!Match.test(definition, schemaDefinition)) {                                                                   // 456\n      throw new Error('Invalid definition for ' + fieldName + ' field.');                                              // 457\n    }                                                                                                                  // 458\n                                                                                                                       // 459\n    fieldNameRoot = fieldName.split(\".\")[0];                                                                           // 460\n                                                                                                                       // 461\n    self._schemaKeys.push(fieldName);                                                                                  // 462\n                                                                                                                       // 463\n    // We support defaultValue shortcut by converting it immediately into an                                           // 464\n    // autoValue.                                                                                                      // 465\n    if ('defaultValue' in definition) {                                                                                // 466\n      if ('autoValue' in definition) {                                                                                 // 467\n        console.warn('SimpleSchema: Found both autoValue and defaultValue options for \"' + fieldName + '\". Ignoring defaultValue.');\n      } else {                                                                                                         // 469\n        if (fieldName.slice(-2) === \".$\") {                                                                            // 470\n          throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');                  // 471\n        }                                                                                                              // 472\n        self._autoValues[fieldName] = (function defineAutoValue(v) {                                                   // 473\n          return function() {                                                                                          // 474\n            if (this.operator === null && !this.isSet) {                                                               // 475\n              return v;                                                                                                // 476\n            }                                                                                                          // 477\n          };                                                                                                           // 478\n        })(definition.defaultValue);                                                                                   // 479\n      }                                                                                                                // 480\n    }                                                                                                                  // 481\n                                                                                                                       // 482\n    if ('autoValue' in definition) {                                                                                   // 483\n      if (fieldName.slice(-2) === \".$\") {                                                                              // 484\n        throw new Error('An array item field (one that ends with \".$\") cannot have autoValue.');                       // 485\n      }                                                                                                                // 486\n      self._autoValues[fieldName] = definition.autoValue;                                                              // 487\n    }                                                                                                                  // 488\n                                                                                                                       // 489\n    self._depsLabels[fieldName] = new Deps.Dependency();                                                               // 490\n                                                                                                                       // 491\n    if (definition.blackbox === true) {                                                                                // 492\n      self._blackboxKeys.push(fieldName);                                                                              // 493\n    }                                                                                                                  // 494\n                                                                                                                       // 495\n    if (!_.contains(firstLevelSchemaKeys, fieldNameRoot)) {                                                            // 496\n      firstLevelSchemaKeys.push(fieldNameRoot);                                                                        // 497\n    }                                                                                                                  // 498\n  });                                                                                                                  // 499\n                                                                                                                       // 500\n                                                                                                                       // 501\n  // Cache these lists                                                                                                 // 502\n  self._firstLevelSchemaKeys = firstLevelSchemaKeys;                                                                   // 503\n  self._objectKeys = getObjectKeys(self._schema, self._schemaKeys);                                                    // 504\n                                                                                                                       // 505\n  // We will store named validation contexts here                                                                      // 506\n  self._validationContexts = {};                                                                                       // 507\n};                                                                                                                     // 508\n                                                                                                                       // 509\n// This allows other packages or users to extend the schema                                                            // 510\n// definition options that are supported.                                                                              // 511\nSimpleSchema.extendOptions = function(options) {                                                                       // 512\n  _.extend(schemaDefinition, options);                                                                                 // 513\n};                                                                                                                     // 514\n                                                                                                                       // 515\n// this domain regex matches all domains that have at least one .                                                      // 516\n// sadly IPv4 Adresses will be caught too but technically those are valid domains                                      // 517\n// this expression is extracted from the original RFC 5322 mail expression                                             // 518\n// a modification enforces that the tld consists only of characters                                                    // 519\nvar RX_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z](?:[a-z-]*[a-z])?';                                       // 520\n// this domain regex matches everythign that could be a domain in intranet                                             // 521\n// that means \"localhost\" is a valid domain                                                                            // 522\nvar RX_NAME_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\\\.|$))+';                                                  // 523\n// strict IPv4 expression which allows 0-255 per oktett                                                                // 524\nvar RX_IPv4 = '(?:(?:[0-1]?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])(?:\\\\.|$)){4}';                                                  // 525\n// strict IPv6 expression which allows (and validates) all shortcuts                                                   // 526\nvar RX_IPv6 = '(?:(?:[\\\\dA-Fa-f]{1,4}(?::|$)){8}' // full adress                                                       // 527\n  + '|(?=(?:[^:\\\\s]|:[^:\\\\s])*::(?:[^:\\\\s]|:[^:\\\\s])*$)' // or min/max one '::'                                        // 528\n  + '[\\\\dA-Fa-f]{0,4}(?:::?(?:[\\\\dA-Fa-f]{1,4}|$)){1,6})'; // and short adress                                         // 529\n// this allows domains (also localhost etc) and ip adresses                                                            // 530\nvar RX_WEAK_DOMAIN = '(?:' + [RX_NAME_DOMAIN,RX_IPv4,RX_IPv6].join('|') + ')';                                         // 531\n                                                                                                                       // 532\nSimpleSchema.RegEx = {                                                                                                 // 533\n  // We use the RegExp suggested by W3C in http://www.w3.org/TR/html5/forms.html#valid-e-mail-address                  // 534\n  // This is probably the same logic used by most browsers when type=email, which is our goal. It is                   // 535\n  // a very permissive expression. Some apps may wish to be more strict and can write their own RegExp.                // 536\n  Email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n                                                                                                                       // 538\n  Domain: new RegExp('^' + RX_DOMAIN + '$'),                                                                           // 539\n  WeakDomain: new RegExp('^' + RX_WEAK_DOMAIN + '$'),                                                                  // 540\n                                                                                                                       // 541\n  IP: new RegExp('^(?:' + RX_IPv4 + '|' + RX_IPv6 + ')$'),                                                             // 542\n  IPv4: new RegExp('^' + RX_IPv4 + '$'),                                                                               // 543\n  IPv6: new RegExp('^' + RX_IPv6 + '$'),                                                                               // 544\n  // URL RegEx from https://gist.github.com/dperini/729294                                                             // 545\n  // http://mathiasbynens.be/demo/url-regex                                                                            // 546\n  Url: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i,\n  // unique id from the random package also used by minimongo                                                          // 548\n  // character list: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L88                 // 549\n  // string length: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L143                 // 550\n  Id: /^[23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz]{17}$/,                                               // 551\n  // allows for a 5 digit zip code followed by a whitespace or dash and then 4 more digits                             // 552\n  // matches 11111 and 11111-1111 and 11111 1111                                                                       // 553\n  ZipCode: /^\\d{5}(?:[-\\s]\\d{4})?$/,                                                                                   // 554\n  // taken from google's libphonenumber library                                                                        // 555\n  // https://github.com/googlei18n/libphonenumber/blob/master/javascript/i18n/phonenumbers/phonenumberutil.js          // 556\n  // reference the VALID_PHONE_NUMBER_PATTERN key                                                                      // 557\n  // allows for common phone number symbols including + () and -                                                       // 558\n  Phone: /^[0-9０-９٠-٩۰-۹]{2}$|^[+＋]*(?:[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～*]*[0-9０-９٠-٩۰-۹]){3,}[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～0-9０-９٠-٩۰-۹]*(?:;ext=([0-9０-９٠-٩۰-۹]{1,7})|[  \\t,]*(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|[,xｘ#＃~～]|int|anexo|ｉｎｔ)[:\\.．]?[  \\t,-]*([0-9０-９٠-٩۰-۹]{1,7})#?|[- ]+([0-9０-９٠-٩۰-۹]{1,5})#)?$/i\n};                                                                                                                     // 560\n                                                                                                                       // 561\nSimpleSchema._makeGeneric = function(name) {                                                                           // 562\n  if (typeof name !== \"string\") {                                                                                      // 563\n    return null;                                                                                                       // 564\n  }                                                                                                                    // 565\n                                                                                                                       // 566\n  return name.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');                                                                      // 567\n};                                                                                                                     // 568\n                                                                                                                       // 569\nSimpleSchema._depsGlobalMessages = new Deps.Dependency();                                                              // 570\n                                                                                                                       // 571\n// Inherit from Match.Where                                                                                            // 572\n// This allow SimpleSchema instance to be recognized as a Match.Where instance as well                                 // 573\n// as a SimpleSchema instance                                                                                          // 574\nSimpleSchema.prototype = new Match.Where();                                                                            // 575\n                                                                                                                       // 576\n// If an object is an instance of Match.Where, Meteor built-in check API will look at                                  // 577\n// the function named `condition` and will pass it the document to validate                                            // 578\nSimpleSchema.prototype.condition = function(obj) {                                                                     // 579\n  var self = this;                                                                                                     // 580\n                                                                                                                       // 581\n  //determine whether obj is a modifier                                                                                // 582\n  var isModifier, isNotModifier;                                                                                       // 583\n  _.each(obj, function(val, key) {                                                                                     // 584\n    if (key.substring(0, 1) === \"$\") {                                                                                 // 585\n      isModifier = true;                                                                                               // 586\n    } else {                                                                                                           // 587\n      isNotModifier = true;                                                                                            // 588\n    }                                                                                                                  // 589\n  });                                                                                                                  // 590\n                                                                                                                       // 591\n  if (isModifier && isNotModifier) {                                                                                   // 592\n    throw new Match.Error(\"Object cannot contain modifier operators alongside other keys\");                            // 593\n  }                                                                                                                    // 594\n                                                                                                                       // 595\n  var ctx = self.newContext();                                                                                         // 596\n  if (!ctx.validate(obj, {modifier: isModifier, filter: false, autoConvert: false})) {                                 // 597\n    var error = ctx.getErrorObject();                                                                                  // 598\n    var matchError = new Match.Error(error.message);                                                                   // 599\n    matchError.invalidKeys = error.invalidKeys;                                                                        // 600\n    if (Meteor.isServer) {                                                                                             // 601\n      matchError.sanitizedError = error.sanitizedError;                                                                // 602\n    }                                                                                                                  // 603\n    throw matchError;                                                                                                  // 604\n  }                                                                                                                    // 605\n                                                                                                                       // 606\n  return true;                                                                                                         // 607\n};                                                                                                                     // 608\n                                                                                                                       // 609\nfunction logInvalidKeysForContext(context, name) {                                                                     // 610\n  Meteor.startup(function() {                                                                                          // 611\n    Deps.autorun(function() {                                                                                          // 612\n      if (!context.isValid()) {                                                                                        // 613\n        console.log('SimpleSchema invalid keys for \"' + name + '\" context:', context.invalidKeys());                   // 614\n      }                                                                                                                // 615\n    });                                                                                                                // 616\n  });                                                                                                                  // 617\n}                                                                                                                      // 618\n                                                                                                                       // 619\nSimpleSchema.prototype.namedContext = function(name) {                                                                 // 620\n  var self = this;                                                                                                     // 621\n  if (typeof name !== \"string\") {                                                                                      // 622\n    name = \"default\";                                                                                                  // 623\n  }                                                                                                                    // 624\n  if (!self._validationContexts[name]) {                                                                               // 625\n    self._validationContexts[name] = new SimpleSchemaValidationContext(self);                                          // 626\n                                                                                                                       // 627\n    // In debug mode, log all invalid key errors to the browser console                                                // 628\n    if (SimpleSchema.debug && Meteor.isClient) {                                                                       // 629\n      Deps.nonreactive(function() {                                                                                    // 630\n        logInvalidKeysForContext(self._validationContexts[name], name);                                                // 631\n      });                                                                                                              // 632\n    }                                                                                                                  // 633\n  }                                                                                                                    // 634\n  return self._validationContexts[name];                                                                               // 635\n};                                                                                                                     // 636\n                                                                                                                       // 637\n// Global custom validators                                                                                            // 638\nSimpleSchema._validators = [];                                                                                         // 639\nSimpleSchema.addValidator = function(func) {                                                                           // 640\n  SimpleSchema._validators.push(func);                                                                                 // 641\n};                                                                                                                     // 642\n                                                                                                                       // 643\n// Instance custom validators                                                                                          // 644\nSimpleSchema.prototype.addValidator = function(func) {                                                                 // 645\n  this._validators.push(func);                                                                                         // 646\n};                                                                                                                     // 647\n                                                                                                                       // 648\n/**                                                                                                                    // 649\n * @method SimpleSchema.prototype.pick                                                                                 // 650\n * @param {[fields]} The list of fields to pick to instantiate the subschema                                           // 651\n * @returns {SimpleSchema} The subschema                                                                               // 652\n */                                                                                                                    // 653\nSimpleSchema.prototype.pick = function(/* arguments */) {                                                              // 654\n  var self = this;                                                                                                     // 655\n  var args = _.toArray(arguments);                                                                                     // 656\n  args.unshift(self._schema);                                                                                          // 657\n                                                                                                                       // 658\n  var newSchema = _.pick.apply(null, args);                                                                            // 659\n  return new SimpleSchema(newSchema);                                                                                  // 660\n};                                                                                                                     // 661\n                                                                                                                       // 662\nSimpleSchema.prototype.omit = function() {                                                                             // 663\n  var self = this;                                                                                                     // 664\n  var args = _.toArray(arguments);                                                                                     // 665\n  args.unshift(self._schema);                                                                                          // 666\n                                                                                                                       // 667\n  var newSchema = _.omit.apply(null, args);                                                                            // 668\n  return new SimpleSchema(newSchema);                                                                                  // 669\n};                                                                                                                     // 670\n                                                                                                                       // 671\n                                                                                                                       // 672\n/**                                                                                                                    // 673\n * @method SimpleSchema.prototype.clean                                                                                // 674\n * @param {Object} doc - Document or modifier to clean. Referenced object will be modified in place.                   // 675\n * @param {Object} [options]                                                                                           // 676\n * @param {Boolean} [options.filter=true] - Do filtering?                                                              // 677\n * @param {Boolean} [options.autoConvert=true] - Do automatic type converting?                                         // 678\n * @param {Boolean} [options.removeEmptyStrings=true] - Remove keys in normal object or $set where the value is an empty string?\n * @param {Boolean} [options.trimStrings=true] - Trim string values?                                                   // 680\n * @param {Boolean} [options.getAutoValues=true] - Inject automatic and default values?                                // 681\n * @param {Boolean} [options.isModifier=false] - Is doc a modifier object?                                             // 682\n * @param {Object} [options.extendAutoValueContext] - This object will be added to the `this` context of autoValue functions.\n * @returns {Object} The modified doc.                                                                                 // 684\n *                                                                                                                     // 685\n * Cleans a document or modifier object. By default, will filter, automatically                                        // 686\n * type convert where possible, and inject automatic/default values. Use the options                                   // 687\n * to skip one or more of these.                                                                                       // 688\n */                                                                                                                    // 689\nSimpleSchema.prototype.clean = function(doc, options) {                                                                // 690\n  var self = this;                                                                                                     // 691\n                                                                                                                       // 692\n  // By default, doc will be filtered and autoconverted                                                                // 693\n  options = _.extend({                                                                                                 // 694\n    filter: true,                                                                                                      // 695\n    autoConvert: true,                                                                                                 // 696\n    removeEmptyStrings: true,                                                                                          // 697\n    trimStrings: true,                                                                                                 // 698\n    getAutoValues: true,                                                                                               // 699\n    isModifier: false,                                                                                                 // 700\n    extendAutoValueContext: {}                                                                                         // 701\n  }, options || {});                                                                                                   // 702\n                                                                                                                       // 703\n  // Convert $pushAll (deprecated) to $push with $each                                                                 // 704\n  if (\"$pushAll\" in doc) {                                                                                             // 705\n    console.warn(\"SimpleSchema.clean: $pushAll is deprecated; converting to $push with $each\");                        // 706\n    doc.$push = doc.$push || {};                                                                                       // 707\n    for (var field in doc.$pushAll) {                                                                                  // 708\n      doc.$push[field] = doc.$push[field] || {};                                                                       // 709\n      doc.$push[field].$each = doc.$push[field].$each || [];                                                           // 710\n      for (var i = 0, ln = doc.$pushAll[field].length; i < ln; i++) {                                                  // 711\n        doc.$push[field].$each.push(doc.$pushAll[field][i]);                                                           // 712\n      }                                                                                                                // 713\n      delete doc.$pushAll;                                                                                             // 714\n    }                                                                                                                  // 715\n  }                                                                                                                    // 716\n                                                                                                                       // 717\n  var mDoc = new MongoObject(doc, self._blackboxKeys);                                                                 // 718\n                                                                                                                       // 719\n  // Clean loop                                                                                                        // 720\n  if (options.filter || options.autoConvert || options.removeEmptyStrings || options.trimStrings) {                    // 721\n    mDoc.forEachNode(function() {                                                                                      // 722\n      var gKey = this.genericKey, p, def, val;                                                                         // 723\n      if (gKey) {                                                                                                      // 724\n        def = self._schema[gKey];                                                                                      // 725\n        val = this.value;                                                                                              // 726\n        // Filter out props if necessary; any property is OK for $unset because we want to                             // 727\n        // allow conversions to remove props that have been removed from the schema.                                   // 728\n        if (options.filter && this.operator !== \"$unset\" && !self.allowsKey(gKey)) {                                   // 729\n          // XXX Special handling for $each; maybe this could be made nicer                                            // 730\n          if (this.position.slice(-7) === \"[$each]\") {                                                                 // 731\n            mDoc.removeValueForPosition(this.position.slice(0, -7));                                                   // 732\n          } else {                                                                                                     // 733\n            this.remove();                                                                                             // 734\n          }                                                                                                            // 735\n          if (SimpleSchema.debug) {                                                                                    // 736\n            console.info('SimpleSchema.clean: filtered out value that would have affected key \"' + gKey + '\", which is not allowed by the schema');\n          }                                                                                                            // 738\n          return; // no reason to do more                                                                              // 739\n        }                                                                                                              // 740\n        if (val !== void 0) {                                                                                          // 741\n          // Autoconvert values if requested and if possible                                                           // 742\n          var wasAutoConverted = false;                                                                                // 743\n          if (options.autoConvert && this.operator !== \"$unset\" && def) {                                              // 744\n            var newVal = typeconvert(val, def.type);                                                                   // 745\n            // trim strings                                                                                            // 746\n            if (options.trimStrings && typeof newVal === \"string\") {                                                   // 747\n              newVal = newVal.trim();                                                                                  // 748\n            }                                                                                                          // 749\n            if (newVal !== void 0 && newVal !== val) {                                                                 // 750\n              // remove empty strings                                                                                  // 751\n              if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof newVal === \"string\" && !newVal.length) {\n                // For a document, we remove any fields that are being set to an empty string                          // 753\n                newVal = void 0;                                                                                       // 754\n                // For a modifier, we $unset any fields that are being set to an empty string                          // 755\n                if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {                          // 756\n                                                                                                                       // 757\n                  p = this.position.replace(\"$set\", \"$unset\");                                                         // 758\n                  mDoc.setValueForPosition(p, \"\");                                                                     // 759\n                }                                                                                                      // 760\n              }                                                                                                        // 761\n                                                                                                                       // 762\n              // Change value; if undefined, will remove it                                                            // 763\n              SimpleSchema.debug && console.info('SimpleSchema.clean: autoconverted value ' + val + ' from ' + typeof val + ' to ' + typeof newVal + ' for ' + gKey);\n              this.updateValue(newVal);                                                                                // 765\n              wasAutoConverted = true;                                                                                 // 766\n            }                                                                                                          // 767\n          }                                                                                                            // 768\n          if (!wasAutoConverted) {                                                                                     // 769\n            // trim strings                                                                                            // 770\n            if (options.trimStrings && typeof val === \"string\" && (!def || (def && def.trim !== false))) {             // 771\n              this.updateValue(val.trim());                                                                            // 772\n            }                                                                                                          // 773\n            // remove empty strings                                                                                    // 774\n            if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof val === \"string\" && !val.length) {\n              // For a document, we remove any fields that are being set to an empty string                            // 776\n              this.remove();                                                                                           // 777\n              // For a modifier, we $unset any fields that are being set to an empty string. But only if we're not already within an entire object that is being set.\n              if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {                            // 779\n                p = this.position.replace(\"$set\", \"$unset\");                                                           // 780\n                mDoc.setValueForPosition(p, \"\");                                                                       // 781\n              }                                                                                                        // 782\n            }                                                                                                          // 783\n          }                                                                                                            // 784\n        }                                                                                                              // 785\n      }                                                                                                                // 786\n    }, {endPointsOnly: false});                                                                                        // 787\n  }                                                                                                                    // 788\n                                                                                                                       // 789\n  // Set automatic values                                                                                              // 790\n  options.getAutoValues && getAutoValues.call(self, mDoc, options.isModifier, options.extendAutoValueContext);         // 791\n                                                                                                                       // 792\n  // Ensure we don't have any operators set to an empty object                                                         // 793\n  // since MongoDB 2.6+ will throw errors.                                                                             // 794\n  if (options.isModifier) {                                                                                            // 795\n    for (var op in doc) {                                                                                              // 796\n      if (doc.hasOwnProperty(op) && _.isEmpty(doc[op])) {                                                              // 797\n        delete doc[op];                                                                                                // 798\n      }                                                                                                                // 799\n    }                                                                                                                  // 800\n  }                                                                                                                    // 801\n                                                                                                                       // 802\n  return doc;                                                                                                          // 803\n};                                                                                                                     // 804\n                                                                                                                       // 805\n// Returns the entire schema object or just the definition for one key                                                 // 806\n// in the schema.                                                                                                      // 807\nSimpleSchema.prototype.schema = function(key) {                                                                        // 808\n  var self = this;                                                                                                     // 809\n  // if not null or undefined (more specific)                                                                          // 810\n  if (key !== null && key !== void 0) {                                                                                // 811\n    return self._schema[SimpleSchema._makeGeneric(key)];                                                               // 812\n  } else {                                                                                                             // 813\n    return self._schema;                                                                                               // 814\n  }                                                                                                                    // 815\n};                                                                                                                     // 816\n                                                                                                                       // 817\n// Returns the evaluated definition for one key in the schema                                                          // 818\n// key = non-generic key                                                                                               // 819\n// [propList] = props to include in the result, for performance                                                        // 820\n// [functionContext] = used for evaluating schema options that are functions                                           // 821\nSimpleSchema.prototype.getDefinition = function(key, propList, functionContext) {                                      // 822\n  var self = this;                                                                                                     // 823\n  var defs = self.schema(key);                                                                                         // 824\n  if (!defs) {                                                                                                         // 825\n    return;                                                                                                            // 826\n  }                                                                                                                    // 827\n                                                                                                                       // 828\n  if (_.isArray(propList)) {                                                                                           // 829\n    defs = _.pick(defs, propList);                                                                                     // 830\n  } else {                                                                                                             // 831\n    defs = _.clone(defs);                                                                                              // 832\n  }                                                                                                                    // 833\n                                                                                                                       // 834\n  // For any options that support specifying a function,                                                               // 835\n  // evaluate the functions.                                                                                           // 836\n  _.each(['min', 'max', 'minCount', 'maxCount', 'allowedValues', 'optional', 'label'], function (prop) {               // 837\n    if (_.isFunction(defs[prop])) {                                                                                    // 838\n      defs[prop] = defs[prop].call(functionContext || {});                                                             // 839\n    }                                                                                                                  // 840\n  });                                                                                                                  // 841\n                                                                                                                       // 842\n  // Inflect label if not defined                                                                                      // 843\n  defs.label = defs.label || inflectedLabel(key);                                                                      // 844\n                                                                                                                       // 845\n  return defs;                                                                                                         // 846\n};                                                                                                                     // 847\n                                                                                                                       // 848\n// Check if the key is a nested dot-syntax key inside of a blackbox object                                             // 849\nSimpleSchema.prototype.keyIsInBlackBox = function(key) {                                                               // 850\n  var self = this;                                                                                                     // 851\n  var parentPath = SimpleSchema._makeGeneric(key), lastDot, def;                                                       // 852\n                                                                                                                       // 853\n  // Iterate the dot-syntax hierarchy until we find a key in our schema                                                // 854\n  do {                                                                                                                 // 855\n    lastDot = parentPath.lastIndexOf('.');                                                                             // 856\n    if (lastDot !== -1) {                                                                                              // 857\n      parentPath = parentPath.slice(0, lastDot); // Remove last path component                                         // 858\n      def = self.getDefinition(parentPath);                                                                            // 859\n    }                                                                                                                  // 860\n  } while (lastDot !== -1 && !def);                                                                                    // 861\n                                                                                                                       // 862\n  return !!(def && def.blackbox);                                                                                      // 863\n};                                                                                                                     // 864\n                                                                                                                       // 865\n// Use to dynamically change the schema labels.                                                                        // 866\nSimpleSchema.prototype.labels = function(labels) {                                                                     // 867\n  var self = this;                                                                                                     // 868\n  _.each(labels, function(label, fieldName) {                                                                          // 869\n    if (!_.isString(label) && !_.isFunction(label)) {                                                                  // 870\n      return;                                                                                                          // 871\n    }                                                                                                                  // 872\n                                                                                                                       // 873\n    if (!(fieldName in self._schema)) {                                                                                // 874\n      return;                                                                                                          // 875\n    }                                                                                                                  // 876\n                                                                                                                       // 877\n    self._schema[fieldName].label = label;                                                                             // 878\n    self._depsLabels[fieldName] && self._depsLabels[fieldName].changed();                                              // 879\n  });                                                                                                                  // 880\n};                                                                                                                     // 881\n                                                                                                                       // 882\n// should be used to safely get a label as string                                                                      // 883\nSimpleSchema.prototype.label = function(key) {                                                                         // 884\n  var self = this;                                                                                                     // 885\n                                                                                                                       // 886\n  // Get all labels                                                                                                    // 887\n  if (key === null || key === void 0) {                                                                                // 888\n    var result = {};                                                                                                   // 889\n    _.each(self.schema(), function(def, fieldName) {                                                                   // 890\n      result[fieldName] = self.label(fieldName);                                                                       // 891\n    });                                                                                                                // 892\n    return result;                                                                                                     // 893\n  }                                                                                                                    // 894\n                                                                                                                       // 895\n  // Get label for one field                                                                                           // 896\n  var def = self.getDefinition(key);                                                                                   // 897\n  if (def) {                                                                                                           // 898\n    var genericKey = SimpleSchema._makeGeneric(key);                                                                   // 899\n    self._depsLabels[genericKey] && self._depsLabels[genericKey].depend();                                             // 900\n    return def.label;                                                                                                  // 901\n  }                                                                                                                    // 902\n                                                                                                                       // 903\n  return null;                                                                                                         // 904\n};                                                                                                                     // 905\n                                                                                                                       // 906\n// Global messages                                                                                                     // 907\n                                                                                                                       // 908\nSimpleSchema._globalMessages = {                                                                                       // 909\n  required: \"[label] is required\",                                                                                     // 910\n  minString: \"[label] must be at least [min] characters\",                                                              // 911\n  maxString: \"[label] cannot exceed [max] characters\",                                                                 // 912\n  minNumber: \"[label] must be at least [min]\",                                                                         // 913\n  maxNumber: \"[label] cannot exceed [max]\",                                                                            // 914\n  minNumberExclusive: \"[label] must be greater than [min]\",                                                            // 915\n  maxNumberExclusive: \"[label] must be less than [max]\",                                                               // 916\n  minDate: \"[label] must be on or after [min]\",                                                                        // 917\n  maxDate: \"[label] cannot be after [max]\",                                                                            // 918\n  badDate: \"[label] is not a valid date\",                                                                              // 919\n  minCount: \"You must specify at least [minCount] values\",                                                             // 920\n  maxCount: \"You cannot specify more than [maxCount] values\",                                                          // 921\n  noDecimal: \"[label] must be an integer\",                                                                             // 922\n  notAllowed: \"[value] is not an allowed value\",                                                                       // 923\n  expectedString: \"[label] must be a string\",                                                                          // 924\n  expectedNumber: \"[label] must be a number\",                                                                          // 925\n  expectedBoolean: \"[label] must be a boolean\",                                                                        // 926\n  expectedArray: \"[label] must be an array\",                                                                           // 927\n  expectedObject: \"[label] must be an object\",                                                                         // 928\n  expectedConstructor: \"[label] must be a [type]\",                                                                     // 929\n  regEx: [                                                                                                             // 930\n    {msg: \"[label] failed regular expression validation\"},                                                             // 931\n    {exp: SimpleSchema.RegEx.Email, msg: \"[label] must be a valid e-mail address\"},                                    // 932\n    {exp: SimpleSchema.RegEx.WeakEmail, msg: \"[label] must be a valid e-mail address\"},                                // 933\n    {exp: SimpleSchema.RegEx.Domain, msg: \"[label] must be a valid domain\"},                                           // 934\n    {exp: SimpleSchema.RegEx.WeakDomain, msg: \"[label] must be a valid domain\"},                                       // 935\n    {exp: SimpleSchema.RegEx.IP, msg: \"[label] must be a valid IPv4 or IPv6 address\"},                                 // 936\n    {exp: SimpleSchema.RegEx.IPv4, msg: \"[label] must be a valid IPv4 address\"},                                       // 937\n    {exp: SimpleSchema.RegEx.IPv6, msg: \"[label] must be a valid IPv6 address\"},                                       // 938\n    {exp: SimpleSchema.RegEx.Url, msg: \"[label] must be a valid URL\"},                                                 // 939\n    {exp: SimpleSchema.RegEx.Id, msg: \"[label] must be a valid alphanumeric ID\"}                                       // 940\n  ],                                                                                                                   // 941\n  keyNotInSchema: \"[key] is not allowed by the schema\"                                                                 // 942\n};                                                                                                                     // 943\n                                                                                                                       // 944\nSimpleSchema.messages = function(messages) {                                                                           // 945\n  _.extend(SimpleSchema._globalMessages, messages);                                                                    // 946\n  SimpleSchema._depsGlobalMessages.changed();                                                                          // 947\n};                                                                                                                     // 948\n                                                                                                                       // 949\n// Schema-specific messages                                                                                            // 950\n                                                                                                                       // 951\nSimpleSchema.prototype.messages = function(messages) {                                                                 // 952\n  var self = this;                                                                                                     // 953\n  _.extend(self._messages, messages);                                                                                  // 954\n  self._depsMessages.changed();                                                                                        // 955\n};                                                                                                                     // 956\n                                                                                                                       // 957\n// Returns a string message for the given error type and key. Uses the                                                 // 958\n// def and value arguments to fill in placeholders in the error messages.                                              // 959\nSimpleSchema.prototype.messageForError = function(type, key, def, value) {                                             // 960\n  var self = this;                                                                                                     // 961\n                                                                                                                       // 962\n  // We proceed even if we can't get a definition because it might be a keyNotInSchema error                           // 963\n  def = def || self.getDefinition(key, ['regEx', 'label', 'minCount', 'maxCount', 'min', 'max', 'type']) || {};        // 964\n                                                                                                                       // 965\n  // Adjust for complex types, currently only regEx,                                                                   // 966\n  // where we might have regEx.1 meaning the second                                                                    // 967\n  // expression in the array.                                                                                          // 968\n  var firstTypePeriod = type.indexOf(\".\"), index = null;                                                               // 969\n  if (firstTypePeriod !== -1) {                                                                                        // 970\n    index = type.substring(firstTypePeriod + 1);                                                                       // 971\n    index = parseInt(index, 10);                                                                                       // 972\n    type = type.substring(0, firstTypePeriod);                                                                         // 973\n  }                                                                                                                    // 974\n                                                                                                                       // 975\n  // Which regExp is it?                                                                                               // 976\n  var regExpMatch;                                                                                                     // 977\n  if (type === \"regEx\") {                                                                                              // 978\n    if (index !== null && index !== void 0 && !isNaN(index)) {                                                         // 979\n      regExpMatch = def.regEx[index];                                                                                  // 980\n    } else {                                                                                                           // 981\n      regExpMatch = def.regEx;                                                                                         // 982\n    }                                                                                                                  // 983\n    if (regExpMatch) {                                                                                                 // 984\n      regExpMatch = regExpMatch.toString();                                                                            // 985\n    }                                                                                                                  // 986\n  }                                                                                                                    // 987\n                                                                                                                       // 988\n  // Prep some strings to be used when finding the correct message for this error                                      // 989\n  var typePlusKey = type + \" \" + key;                                                                                  // 990\n  var genericKey = SimpleSchema._makeGeneric(key);                                                                     // 991\n  var typePlusGenKey = type + \" \" + genericKey;                                                                        // 992\n                                                                                                                       // 993\n  // reactively update when message templates are changed                                                              // 994\n  SimpleSchema._depsGlobalMessages.depend();                                                                           // 995\n  self._depsMessages.depend();                                                                                         // 996\n                                                                                                                       // 997\n  // Prep a function that finds the correct message for regEx errors                                                   // 998\n  function findRegExError(message) {                                                                                   // 999\n    if (type !== \"regEx\" || !_.isArray(message)) {                                                                     // 1000\n      return message;                                                                                                  // 1001\n    }                                                                                                                  // 1002\n    // Parse regEx messages, which are provided in a special object array format                                       // 1003\n    // [{exp: RegExp, msg: \"Foo\"}]                                                                                     // 1004\n    // Where `exp` is optional                                                                                         // 1005\n                                                                                                                       // 1006\n    var msgObj;                                                                                                        // 1007\n    // First see if there's one where exp matches this expression                                                      // 1008\n    if (regExpMatch) {                                                                                                 // 1009\n      msgObj = _.find(message, function (o) {                                                                          // 1010\n        return o.exp && o.exp.toString() === regExpMatch;                                                              // 1011\n      });                                                                                                              // 1012\n    }                                                                                                                  // 1013\n                                                                                                                       // 1014\n    // If not, see if there's a default message defined                                                                // 1015\n    if (!msgObj) {                                                                                                     // 1016\n      msgObj = _.findWhere(message, {exp: null});                                                                      // 1017\n      if (!msgObj) {                                                                                                   // 1018\n        msgObj = _.findWhere(message, {exp: void 0});                                                                  // 1019\n      }                                                                                                                // 1020\n    }                                                                                                                  // 1021\n                                                                                                                       // 1022\n    return msgObj ? msgObj.msg : null;                                                                                 // 1023\n  }                                                                                                                    // 1024\n                                                                                                                       // 1025\n  // Try finding the correct message to use at various levels, from most                                               // 1026\n  // specific to least specific.                                                                                       // 1027\n  var message = self._messages[typePlusKey] ||                  // (1) Use schema-specific message for specific key    // 1028\n                self._messages[typePlusGenKey] ||               // (2) Use schema-specific message for generic key     // 1029\n                self._messages[type];                           // (3) Use schema-specific message for type            // 1030\n  message = findRegExError(message);                                                                                   // 1031\n                                                                                                                       // 1032\n  if (!message) {                                                                                                      // 1033\n    message = SimpleSchema._globalMessages[typePlusKey] ||      // (4) Use global message for specific key             // 1034\n              SimpleSchema._globalMessages[typePlusGenKey] ||   // (5) Use global message for generic key              // 1035\n              SimpleSchema._globalMessages[type];               // (6) Use global message for type                     // 1036\n    message = findRegExError(message);                                                                                 // 1037\n  }                                                                                                                    // 1038\n                                                                                                                       // 1039\n  if (!message) {                                                                                                      // 1040\n    return \"Unknown validation error\";                                                                                 // 1041\n  }                                                                                                                    // 1042\n                                                                                                                       // 1043\n  // Now replace all placeholders in the message with the correct values                                               // 1044\n                                                                                                                       // 1045\n  // [key]                                                                                                             // 1046\n  message = message.replace(\"[key]\", key);                                                                             // 1047\n                                                                                                                       // 1048\n  // [label]                                                                                                           // 1049\n  // The call to self.label() establishes a reactive dependency, too                                                   // 1050\n  message = message.replace(\"[label]\", self.label(key));                                                               // 1051\n                                                                                                                       // 1052\n  // [minCount]                                                                                                        // 1053\n  if (typeof def.minCount !== \"undefined\") {                                                                           // 1054\n    message = message.replace(\"[minCount]\", def.minCount);                                                             // 1055\n  }                                                                                                                    // 1056\n                                                                                                                       // 1057\n  // [maxCount]                                                                                                        // 1058\n  if (typeof def.maxCount !== \"undefined\") {                                                                           // 1059\n    message = message.replace(\"[maxCount]\", def.maxCount);                                                             // 1060\n  }                                                                                                                    // 1061\n                                                                                                                       // 1062\n  // [value]                                                                                                           // 1063\n  if (value !== void 0 && value !== null) {                                                                            // 1064\n    message = message.replace(\"[value]\", value.toString());                                                            // 1065\n  } else {                                                                                                             // 1066\n    message = message.replace(\"[value]\", 'null');                                                                      // 1067\n  }                                                                                                                    // 1068\n                                                                                                                       // 1069\n  // [min] and [max]                                                                                                   // 1070\n  var min = def.min;                                                                                                   // 1071\n  var max = def.max;                                                                                                   // 1072\n  if (def.type === Date || def.type === [Date]) {                                                                      // 1073\n    if (typeof min !== \"undefined\") {                                                                                  // 1074\n      message = message.replace(\"[min]\", Utility.dateToDateString(min));                                               // 1075\n    }                                                                                                                  // 1076\n    if (typeof max !== \"undefined\") {                                                                                  // 1077\n      message = message.replace(\"[max]\", Utility.dateToDateString(max));                                               // 1078\n    }                                                                                                                  // 1079\n  } else {                                                                                                             // 1080\n    if (typeof min !== \"undefined\") {                                                                                  // 1081\n      message = message.replace(\"[min]\", min);                                                                         // 1082\n    }                                                                                                                  // 1083\n    if (typeof max !== \"undefined\") {                                                                                  // 1084\n      message = message.replace(\"[max]\", max);                                                                         // 1085\n    }                                                                                                                  // 1086\n  }                                                                                                                    // 1087\n                                                                                                                       // 1088\n  // [type]                                                                                                            // 1089\n  if (def.type instanceof Function) {                                                                                  // 1090\n    message = message.replace(\"[type]\", def.type.name);                                                                // 1091\n  }                                                                                                                    // 1092\n                                                                                                                       // 1093\n  // Now return the message                                                                                            // 1094\n  return message;                                                                                                      // 1095\n};                                                                                                                     // 1096\n                                                                                                                       // 1097\n// Returns true if key is explicitly allowed by the schema or implied                                                  // 1098\n// by other explicitly allowed keys.                                                                                   // 1099\n// The key string should have $ in place of any numeric array positions.                                               // 1100\nSimpleSchema.prototype.allowsKey = function(key) {                                                                     // 1101\n  var self = this;                                                                                                     // 1102\n                                                                                                                       // 1103\n  // Loop through all keys in the schema                                                                               // 1104\n  return _.any(self._schemaKeys, function(schemaKey) {                                                                 // 1105\n                                                                                                                       // 1106\n    // If the schema key is the test key, it's allowed.                                                                // 1107\n    if (schemaKey === key) {                                                                                           // 1108\n      return true;                                                                                                     // 1109\n    }                                                                                                                  // 1110\n                                                                                                                       // 1111\n    // Black box handling                                                                                              // 1112\n    if (self.schema(schemaKey).blackbox === true) {                                                                    // 1113\n      var kl = schemaKey.length;                                                                                       // 1114\n      var compare1 = key.slice(0, kl + 2);                                                                             // 1115\n      var compare2 = compare1.slice(0, -1);                                                                            // 1116\n                                                                                                                       // 1117\n      // If the test key is the black box key + \".$\", then the test                                                    // 1118\n      // key is NOT allowed because black box keys are by definition                                                   // 1119\n      // only for objects, and not for arrays.                                                                         // 1120\n      if (compare1 === schemaKey + '.$') {                                                                             // 1121\n        return false;                                                                                                  // 1122\n      }                                                                                                                // 1123\n                                                                                                                       // 1124\n      // Otherwise                                                                                                     // 1125\n      if (compare2 === schemaKey + '.') {                                                                              // 1126\n        return true;                                                                                                   // 1127\n      }                                                                                                                // 1128\n    }                                                                                                                  // 1129\n                                                                                                                       // 1130\n    return false;                                                                                                      // 1131\n  });                                                                                                                  // 1132\n};                                                                                                                     // 1133\n                                                                                                                       // 1134\nSimpleSchema.prototype.newContext = function() {                                                                       // 1135\n  return new SimpleSchemaValidationContext(this);                                                                      // 1136\n};                                                                                                                     // 1137\n                                                                                                                       // 1138\n// Returns all the child keys for the object identified by the generic prefix,                                         // 1139\n// or all the top level keys if no prefix is supplied.                                                                 // 1140\nSimpleSchema.prototype.objectKeys = function(keyPrefix) {                                                              // 1141\n  var self = this;                                                                                                     // 1142\n  if (!keyPrefix) {                                                                                                    // 1143\n    return self._firstLevelSchemaKeys;                                                                                 // 1144\n  }                                                                                                                    // 1145\n  return self._objectKeys[keyPrefix + \".\"] || [];                                                                      // 1146\n};                                                                                                                     // 1147\n                                                                                                                       // 1148\nSimpleSchema.prototype.validate = function (obj, options) {                                                            // 1149\n  if (Package.check && Package['audit-argument-checks']) {                                                             // 1150\n    // Call check but ignore the error to silence audit-argument-checks                                                // 1151\n    try { check(obj); } catch (e) { /* ignore error */ }                                                               // 1152\n  }                                                                                                                    // 1153\n                                                                                                                       // 1154\n  var validationContext = this.newContext();                                                                           // 1155\n  var isValid = validationContext.validate(obj, options);                                                              // 1156\n                                                                                                                       // 1157\n  if (isValid) return;                                                                                                 // 1158\n                                                                                                                       // 1159\n  var errors = validationContext.invalidKeys().map(function (error) {                                                  // 1160\n    return {                                                                                                           // 1161\n      name: error.name,                                                                                                // 1162\n      type: error.type,                                                                                                // 1163\n      details: {                                                                                                       // 1164\n        value: error.value                                                                                             // 1165\n      }                                                                                                                // 1166\n    };                                                                                                                 // 1167\n  });                                                                                                                  // 1168\n                                                                                                                       // 1169\n  // In order for the message at the top of the stack trace to be useful,                                              // 1170\n  // we set it to the first validation error message.                                                                  // 1171\n  var message = validationContext.keyErrorMessage(errors[0].name);                                                     // 1172\n                                                                                                                       // 1173\n  throw new Package['mdg:validation-error'].ValidationError(errors, message);                                          // 1174\n};                                                                                                                     // 1175\n                                                                                                                       // 1176\nSimpleSchema.prototype.validator = function (options) {                                                                // 1177\n  var self = this;                                                                                                     // 1178\n  options = options || {};                                                                                             // 1179\n  return function (obj) {                                                                                              // 1180\n    if (options.clean === true) self.clean(obj, options);                                                              // 1181\n    self.validate(obj);                                                                                                // 1182\n  };                                                                                                                   // 1183\n};                                                                                                                     // 1184\n                                                                                                                       // 1185\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-validation.js                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility */                                                                                                   // 1\n/* global _ */                                                                                                         // 2\n/* global SimpleSchema */                                                                                              // 3\n/* global MongoObject */                                                                                               // 4\n/* global doValidation1:true */                                                                                        // 5\n                                                                                                                       // 6\nfunction doTypeChecks(def, keyValue, op) {                                                                             // 7\n  var expectedType = def.type;                                                                                         // 8\n                                                                                                                       // 9\n  // String checks                                                                                                     // 10\n  if (expectedType === String) {                                                                                       // 11\n    if (typeof keyValue !== \"string\") {                                                                                // 12\n      return \"expectedString\";                                                                                         // 13\n    } else if (def.max !== null && def.max < keyValue.length) {                                                        // 14\n      return \"maxString\";                                                                                              // 15\n    } else if (def.min !== null && def.min > keyValue.length) {                                                        // 16\n      return \"minString\";                                                                                              // 17\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {                                             // 18\n      return \"regEx\";                                                                                                  // 19\n    } else if (_.isArray(def.regEx)) {                                                                                 // 20\n      var regExError;                                                                                                  // 21\n      _.every(def.regEx, function(re, i) {                                                                             // 22\n        if (!re.test(keyValue)) {                                                                                      // 23\n          regExError = \"regEx.\" + i;                                                                                   // 24\n          return false;                                                                                                // 25\n        }                                                                                                              // 26\n        return true;                                                                                                   // 27\n      });                                                                                                              // 28\n      if (regExError) {                                                                                                // 29\n        return regExError;                                                                                             // 30\n      }                                                                                                                // 31\n    }                                                                                                                  // 32\n  }                                                                                                                    // 33\n                                                                                                                       // 34\n  // Number checks                                                                                                     // 35\n  else if (expectedType === Number) {                                                                                  // 36\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {                                                             // 37\n      return \"expectedNumber\";                                                                                         // 38\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";                                                 // 40\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";                                                 // 42\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {                                                // 43\n      return \"noDecimal\";                                                                                              // 44\n    }                                                                                                                  // 45\n  }                                                                                                                    // 46\n                                                                                                                       // 47\n  // Boolean checks                                                                                                    // 48\n  else if (expectedType === Boolean) {                                                                                 // 49\n    if (typeof keyValue !== \"boolean\") {                                                                               // 50\n      return \"expectedBoolean\";                                                                                        // 51\n    }                                                                                                                  // 52\n  }                                                                                                                    // 53\n                                                                                                                       // 54\n  // Object checks                                                                                                     // 55\n  else if (expectedType === Object) {                                                                                  // 56\n    if (!Utility.isBasicObject(keyValue)) {                                                                            // 57\n      return \"expectedObject\";                                                                                         // 58\n    }                                                                                                                  // 59\n  }                                                                                                                    // 60\n                                                                                                                       // 61\n  // Array checks                                                                                                      // 62\n  else if (expectedType === Array) {                                                                                   // 63\n    if (!_.isArray(keyValue)) {                                                                                        // 64\n      return \"expectedArray\";                                                                                          // 65\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {                                              // 66\n      return \"minCount\";                                                                                               // 67\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {                                              // 68\n      return \"maxCount\";                                                                                               // 69\n    }                                                                                                                  // 70\n  }                                                                                                                    // 71\n                                                                                                                       // 72\n  // Constructor function checks                                                                                       // 73\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {                                   // 74\n                                                                                                                       // 75\n    // Generic constructor checks                                                                                      // 76\n    if (!(keyValue instanceof expectedType)) {                                                                         // 77\n      return \"expectedConstructor\";                                                                                    // 78\n    }                                                                                                                  // 79\n                                                                                                                       // 80\n    // Date checks                                                                                                     // 81\n    else if (expectedType === Date) {                                                                                  // 82\n      if (isNaN(keyValue.getTime())) {                                                                                 // 83\n        return \"badDate\";                                                                                              // 84\n      }                                                                                                                // 85\n                                                                                                                       // 86\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {                                               // 87\n        return \"minDate\";                                                                                              // 88\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {                                        // 89\n        return \"maxDate\";                                                                                              // 90\n      }                                                                                                                // 91\n    }                                                                                                                  // 92\n  }                                                                                                                    // 93\n                                                                                                                       // 94\n}                                                                                                                      // 95\n                                                                                                                       // 96\ndoValidation1 = function doValidation1(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {          // 97\n  // First do some basic checks of the object, and throw errors if necessary                                           // 98\n  if (!_.isObject(obj)) {                                                                                              // 99\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");                            // 100\n  }                                                                                                                    // 101\n                                                                                                                       // 102\n  if (!isModifier && Utility.looksLikeModifier(obj)) {                                                                 // 103\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");  // 104\n  }                                                                                                                    // 105\n                                                                                                                       // 106\n  var invalidKeys = [];                                                                                                // 107\n  var mDoc; // for caching the MongoObject if necessary                                                                // 108\n                                                                                                                       // 109\n  // Validation function called for each affected key                                                                  // 110\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, isInArrayItemObject, isInSubObject) {\n                                                                                                                       // 112\n    // Get the schema for this key, marking invalid if there isn't one.                                                // 113\n    if (!def) {                                                                                                        // 114\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));                              // 115\n      return;                                                                                                          // 116\n    }                                                                                                                  // 117\n                                                                                                                       // 118\n    // Check for missing required values. The general logic is this:                                                   // 119\n    // * If the operator is $unset or $rename, it's invalid.                                                           // 120\n    // * If the value is null, it's invalid.                                                                           // 121\n    // * If the value is undefined and one of the following are true, it's invalid:                                    // 122\n    //     * We're validating a key of a sub-object.                                                                   // 123\n    //     * We're validating a key of an object that is an array item.                                                // 124\n    //     * We're validating a document (as opposed to a modifier).                                                   // 125\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.                         // 126\n    if (!skipRequiredCheck && !def.optional) {                                                                         // 127\n      if (                                                                                                             // 128\n        val === null ||                                                                                                // 129\n        op === \"$unset\" ||                                                                                             // 130\n        op === \"$rename\" ||                                                                                            // 131\n        (val === void 0 && (isInArrayItemObject || isInSubObject || !op || op === \"$set\"))                             // 132\n        ) {                                                                                                            // 133\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));                                 // 134\n        return;                                                                                                        // 135\n      }                                                                                                                // 136\n    }                                                                                                                  // 137\n                                                                                                                       // 138\n    // For $rename, make sure that the new name is allowed by the schema                                               // 139\n    if (op === \"$rename\" && typeof val === \"string\" && !ss.allowsKey(val)) {                                           // 140\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", val, null, null, ss));                                    // 141\n      return;                                                                                                          // 142\n    }                                                                                                                  // 143\n                                                                                                                       // 144\n    // Value checks are not necessary for null or undefined values                                                     // 145\n    // or for $unset or $rename values                                                                                 // 146\n    if (op !== \"$unset\" && op !== \"$rename\" && Utility.isNotNullOrUndefined(val)) {                                    // 147\n                                                                                                                       // 148\n      // Check that value is of the correct type                                                                       // 149\n      var typeError = doTypeChecks(def, val, op);                                                                      // 150\n      if (typeError) {                                                                                                 // 151\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));                                   // 152\n        return;                                                                                                        // 153\n      }                                                                                                                // 154\n                                                                                                                       // 155\n      // Check value against allowedValues array                                                                       // 156\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {                                                  // 157\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));                                // 158\n        return;                                                                                                        // 159\n      }                                                                                                                // 160\n                                                                                                                       // 161\n    }                                                                                                                  // 162\n                                                                                                                       // 163\n    // Perform custom validation                                                                                       // 164\n    var lastDot = affectedKey.lastIndexOf('.');                                                                        // 165\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);                                     // 166\n    var validators = def.custom ? [def.custom] : [];                                                                   // 167\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);                                   // 168\n    _.every(validators, function(validator) {                                                                          // 169\n      var errorType = validator.call(_.extend({                                                                        // 170\n        key: affectedKey,                                                                                              // 171\n        genericKey: affectedKeyGeneric,                                                                                // 172\n        definition: def,                                                                                               // 173\n        isSet: (val !== void 0),                                                                                       // 174\n        value: val,                                                                                                    // 175\n        operator: op,                                                                                                  // 176\n        field: function(fName) {                                                                                       // 177\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed                // 178\n          var keyInfo = mDoc.getInfoForKey(fName) || {};                                                               // 179\n          return {                                                                                                     // 180\n            isSet: (keyInfo.value !== void 0),                                                                         // 181\n            value: keyInfo.value,                                                                                      // 182\n            operator: keyInfo.operator                                                                                 // 183\n          };                                                                                                           // 184\n        },                                                                                                             // 185\n        siblingField: function(fName) {                                                                                // 186\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed                // 187\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};                                             // 188\n          return {                                                                                                     // 189\n            isSet: (keyInfo.value !== void 0),                                                                         // 190\n            value: keyInfo.value,                                                                                      // 191\n            operator: keyInfo.operator                                                                                 // 192\n          };                                                                                                           // 193\n        }                                                                                                              // 194\n      }, extendedCustomContext || {}));                                                                                // 195\n      if (typeof errorType === \"string\") {                                                                             // 196\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));                                   // 197\n        return false;                                                                                                  // 198\n      }                                                                                                                // 199\n      return true;                                                                                                     // 200\n    });                                                                                                                // 201\n  }                                                                                                                    // 202\n                                                                                                                       // 203\n  // The recursive function                                                                                            // 204\n  function checkObj(val, affectedKey, operator, setKeys, isInArrayItemObject, isInSubObject) {                         // 205\n    var affectedKeyGeneric, def;                                                                                       // 206\n                                                                                                                       // 207\n    if (affectedKey) {                                                                                                 // 208\n      // When we hit a blackbox key, we don't progress any further                                                     // 209\n      if (ss.keyIsInBlackBox(affectedKey)) {                                                                           // 210\n        return;                                                                                                        // 211\n      }                                                                                                                // 212\n                                                                                                                       // 213\n      // Make a generic version of the affected key, and use that                                                      // 214\n      // to get the schema for this key.                                                                               // 215\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);                                                     // 216\n      def = ss.getDefinition(affectedKey);                                                                             // 217\n                                                                                                                       // 218\n      // Perform validation for this key                                                                               // 219\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {                   // 220\n        // We can skip the required check for keys that are ancestors                                                  // 221\n        // of those in $set or $setOnInsert because they will be created                                               // 222\n        // by MongoDB while setting.                                                                                   // 223\n        var skipRequiredCheck = _.some(setKeys, function(sk) {                                                         // 224\n          return (sk.slice(0, affectedKey.length + 1) === affectedKey + \".\");                                          // 225\n        });                                                                                                            // 226\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, skipRequiredCheck, isInArrayItemObject, isInSubObject);\n      }                                                                                                                // 228\n    }                                                                                                                  // 229\n                                                                                                                       // 230\n    // Temporarily convert missing objects to empty objects                                                            // 231\n    // so that the looping code will be called and required                                                            // 232\n    // descendent keys can be validated.                                                                               // 233\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {                        // 234\n      val = {};                                                                                                        // 235\n    }                                                                                                                  // 236\n                                                                                                                       // 237\n    // Loop through arrays                                                                                             // 238\n    if (_.isArray(val)) {                                                                                              // 239\n      _.each(val, function(v, i) {                                                                                     // 240\n        checkObj(v, affectedKey + '.' + i, operator, setKeys);                                                         // 241\n      });                                                                                                              // 242\n    }                                                                                                                  // 243\n                                                                                                                       // 244\n    // Loop through object keys                                                                                        // 245\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {                                                  // 246\n                                                                                                                       // 247\n      // Get list of present keys                                                                                      // 248\n      var presentKeys = _.keys(val);                                                                                   // 249\n                                                                                                                       // 250\n      // Check all present keys plus all keys defined by the schema.                                                   // 251\n      // This allows us to detect extra keys not allowed by the schema plus                                            // 252\n      // any missing required keys, and to run any custom functions for other keys.                                    // 253\n      var keysToCheck = _.union(presentKeys, ss.objectKeys(affectedKeyGeneric));                                       // 254\n                                                                                                                       // 255\n      // If this object is within an array, make sure we check for                                                     // 256\n      // required as if it's not a modifier                                                                            // 257\n      isInArrayItemObject = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");                             // 258\n                                                                                                                       // 259\n      // Check all keys in the merged list                                                                             // 260\n      _.each(keysToCheck, function(key) {                                                                              // 261\n        checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), operator, setKeys, isInArrayItemObject, true);\n      });                                                                                                              // 263\n    }                                                                                                                  // 264\n                                                                                                                       // 265\n  }                                                                                                                    // 266\n                                                                                                                       // 267\n  function checkModifier(mod) {                                                                                        // 268\n    // Check for empty modifier                                                                                        // 269\n    if (_.isEmpty(mod)) {                                                                                              // 270\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");          // 271\n    }                                                                                                                  // 272\n                                                                                                                       // 273\n    // Get a list of all keys in $set and $setOnInsert combined, for use later                                         // 274\n    var setKeys = _.keys(mod.$set || {}).concat(_.keys(mod.$setOnInsert || {}));                                       // 275\n                                                                                                                       // 276\n    // If this is an upsert, add all the $setOnInsert keys to $set;                                                    // 277\n    // since we don't know whether it will be an insert or update, we'll                                               // 278\n    // validate upserts as if they will be an insert.                                                                  // 279\n    if (\"$setOnInsert\" in mod) {                                                                                       // 280\n      if (isUpsert) {                                                                                                  // 281\n        mod.$set = mod.$set || {};                                                                                     // 282\n        mod.$set = _.extend(mod.$set, mod.$setOnInsert);                                                               // 283\n      }                                                                                                                // 284\n      delete mod.$setOnInsert;                                                                                         // 285\n    }                                                                                                                  // 286\n                                                                                                                       // 287\n    // Loop through operators                                                                                          // 288\n    _.each(mod, function (opObj, op) {                                                                                 // 289\n      // If non-operators are mixed in, throw error                                                                    // 290\n      if (op.slice(0, 1) !== \"$\") {                                                                                    // 291\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators. Did you forget `$set`?\");\n      }                                                                                                                // 293\n      if (Utility.shouldCheck(op)) {                                                                                   // 294\n        // For an upsert, missing props would not be set if an insert is performed,                                    // 295\n        // so we add null keys to the modifier to force any \"required\" checks to fail                                  // 296\n        if (isUpsert && op === \"$set\") {                                                                               // 297\n          var presentKeys = _.keys(opObj);                                                                             // 298\n          _.each(ss.objectKeys(), function (schemaKey) {                                                               // 299\n            if (!_.contains(presentKeys, schemaKey)) {                                                                 // 300\n              checkObj(void 0, schemaKey, op, setKeys);                                                                // 301\n            }                                                                                                          // 302\n          });                                                                                                          // 303\n        }                                                                                                              // 304\n        _.each(opObj, function (v, k) {                                                                                // 305\n          if (op === \"$push\" || op === \"$addToSet\") {                                                                  // 306\n            if (Utility.isBasicObject(v) && \"$each\" in v) {                                                            // 307\n              v = v.$each;                                                                                             // 308\n            } else {                                                                                                   // 309\n              k = k + \".0\";                                                                                            // 310\n            }                                                                                                          // 311\n          }                                                                                                            // 312\n          checkObj(v, k, op, setKeys);                                                                                 // 313\n        });                                                                                                            // 314\n      }                                                                                                                // 315\n    });                                                                                                                // 316\n  }                                                                                                                    // 317\n                                                                                                                       // 318\n  // Kick off the validation                                                                                           // 319\n  if (isModifier) {                                                                                                    // 320\n    checkModifier(obj);                                                                                                // 321\n  } else {                                                                                                             // 322\n    checkObj(obj);                                                                                                     // 323\n  }                                                                                                                    // 324\n                                                                                                                       // 325\n  // Make sure there is only one error per fieldName                                                                   // 326\n  var addedFieldNames = [];                                                                                            // 327\n  invalidKeys = _.filter(invalidKeys, function(errObj) {                                                               // 328\n    if (!_.contains(addedFieldNames, errObj.name)) {                                                                   // 329\n      addedFieldNames.push(errObj.name);                                                                               // 330\n      return true;                                                                                                     // 331\n    }                                                                                                                  // 332\n    return false;                                                                                                      // 333\n  });                                                                                                                  // 334\n                                                                                                                       // 335\n  return invalidKeys;                                                                                                  // 336\n};                                                                                                                     // 337\n                                                                                                                       // 338\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-validation-new.js                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility */                                                                                                   // 1\n/* global _ */                                                                                                         // 2\n/* global SimpleSchema */                                                                                              // 3\n/* global MongoObject */                                                                                               // 4\n/* global Meteor */                                                                                                    // 5\n/* global Random */                                                                                                    // 6\n/* global doValidation2:true */                                                                                        // 7\n                                                                                                                       // 8\nfunction doTypeChecks(def, keyValue, op) {                                                                             // 9\n  var expectedType = def.type;                                                                                         // 10\n                                                                                                                       // 11\n  // String checks                                                                                                     // 12\n  if (expectedType === String) {                                                                                       // 13\n    if (typeof keyValue !== \"string\") {                                                                                // 14\n      return \"expectedString\";                                                                                         // 15\n    } else if (def.max !== null && def.max < keyValue.length) {                                                        // 16\n      return \"maxString\";                                                                                              // 17\n    } else if (def.min !== null && def.min > keyValue.length) {                                                        // 18\n      return \"minString\";                                                                                              // 19\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {                                             // 20\n      return \"regEx\";                                                                                                  // 21\n    } else if (_.isArray(def.regEx)) {                                                                                 // 22\n      var regExError;                                                                                                  // 23\n      _.every(def.regEx, function(re, i) {                                                                             // 24\n        if (!re.test(keyValue)) {                                                                                      // 25\n          regExError = \"regEx.\" + i;                                                                                   // 26\n          return false;                                                                                                // 27\n        }                                                                                                              // 28\n        return true;                                                                                                   // 29\n      });                                                                                                              // 30\n      if (regExError) {                                                                                                // 31\n        return regExError;                                                                                             // 32\n      }                                                                                                                // 33\n    }                                                                                                                  // 34\n  }                                                                                                                    // 35\n                                                                                                                       // 36\n  // Number checks                                                                                                     // 37\n  else if (expectedType === Number) {                                                                                  // 38\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {                                                             // 39\n      return \"expectedNumber\";                                                                                         // 40\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";                                                 // 42\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";                                                 // 44\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {                                                // 45\n      return \"noDecimal\";                                                                                              // 46\n    }                                                                                                                  // 47\n  }                                                                                                                    // 48\n                                                                                                                       // 49\n  // Boolean checks                                                                                                    // 50\n  else if (expectedType === Boolean) {                                                                                 // 51\n    if (typeof keyValue !== \"boolean\") {                                                                               // 52\n      return \"expectedBoolean\";                                                                                        // 53\n    }                                                                                                                  // 54\n  }                                                                                                                    // 55\n                                                                                                                       // 56\n  // Object checks                                                                                                     // 57\n  else if (expectedType === Object) {                                                                                  // 58\n    if (!Utility.isBasicObject(keyValue)) {                                                                            // 59\n      return \"expectedObject\";                                                                                         // 60\n    }                                                                                                                  // 61\n  }                                                                                                                    // 62\n                                                                                                                       // 63\n  // Array checks                                                                                                      // 64\n  else if (expectedType === Array) {                                                                                   // 65\n    if (!_.isArray(keyValue)) {                                                                                        // 66\n      return \"expectedArray\";                                                                                          // 67\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {                                              // 68\n      return \"minCount\";                                                                                               // 69\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {                                              // 70\n      return \"maxCount\";                                                                                               // 71\n    }                                                                                                                  // 72\n  }                                                                                                                    // 73\n                                                                                                                       // 74\n  // Constructor function checks                                                                                       // 75\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {                                   // 76\n                                                                                                                       // 77\n    // Generic constructor checks                                                                                      // 78\n    if (!(keyValue instanceof expectedType)) {                                                                         // 79\n      return \"expectedConstructor\";                                                                                    // 80\n    }                                                                                                                  // 81\n                                                                                                                       // 82\n    // Date checks                                                                                                     // 83\n    else if (expectedType === Date) {                                                                                  // 84\n      if (isNaN(keyValue.getTime())) {                                                                                 // 85\n        return \"badDate\";                                                                                              // 86\n      }                                                                                                                // 87\n                                                                                                                       // 88\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {                                               // 89\n        return \"minDate\";                                                                                              // 90\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {                                        // 91\n        return \"maxDate\";                                                                                              // 92\n      }                                                                                                                // 93\n    }                                                                                                                  // 94\n  }                                                                                                                    // 95\n                                                                                                                       // 96\n}                                                                                                                      // 97\n                                                                                                                       // 98\ndoValidation2 = function doValidation2(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {          // 99\n                                                                                                                       // 100\n  // First do some basic checks of the object, and throw errors if necessary                                           // 101\n  if (!_.isObject(obj)) {                                                                                              // 102\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");                            // 103\n  }                                                                                                                    // 104\n                                                                                                                       // 105\n  if (isModifier) {                                                                                                    // 106\n    if (_.isEmpty(obj)) {                                                                                              // 107\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");          // 108\n    } else {                                                                                                           // 109\n      var allKeysAreOperators = _.every(obj, function(v, k) {                                                          // 110\n        return (k.substring(0, 1) === \"$\");                                                                            // 111\n      });                                                                                                              // 112\n      if (!allKeysAreOperators) {                                                                                      // 113\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators\");             // 114\n      }                                                                                                                // 115\n                                                                                                                       // 116\n      // We use a LocalCollection to figure out what the resulting doc                                                 // 117\n      // would be in a worst case scenario. Then we validate that doc                                                  // 118\n      // so that we don't have to validate the modifier object directly.                                               // 119\n      obj = convertModifierToDoc(obj, ss.schema(), isUpsert);                                                          // 120\n    }                                                                                                                  // 121\n  } else if (Utility.looksLikeModifier(obj)) {                                                                         // 122\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");  // 123\n  }                                                                                                                    // 124\n                                                                                                                       // 125\n  var invalidKeys = [];                                                                                                // 126\n  var mDoc; // for caching the MongoObject if necessary                                                                // 127\n                                                                                                                       // 128\n  // Validation function called for each affected key                                                                  // 129\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, strictRequiredCheck) {           // 130\n                                                                                                                       // 131\n    // Get the schema for this key, marking invalid if there isn't one.                                                // 132\n    if (!def) {                                                                                                        // 133\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));                              // 134\n      return;                                                                                                          // 135\n    }                                                                                                                  // 136\n                                                                                                                       // 137\n    // Check for missing required values. The general logic is this:                                                   // 138\n    // * If the operator is $unset or $rename, it's invalid.                                                           // 139\n    // * If the value is null, it's invalid.                                                                           // 140\n    // * If the value is undefined and one of the following are true, it's invalid:                                    // 141\n    //     * We're validating a key of a sub-object.                                                                   // 142\n    //     * We're validating a key of an object that is an array item.                                                // 143\n    //     * We're validating a document (as opposed to a modifier).                                                   // 144\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.                         // 145\n    if (!skipRequiredCheck && !def.optional) {                                                                         // 146\n      if (val === null || val === void 0) {                                                                            // 147\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));                                 // 148\n        return;                                                                                                        // 149\n      }                                                                                                                // 150\n    }                                                                                                                  // 151\n                                                                                                                       // 152\n    // Value checks are not necessary for null or undefined values                                                     // 153\n    if (Utility.isNotNullOrUndefined(val)) {                                                                           // 154\n                                                                                                                       // 155\n      // Check that value is of the correct type                                                                       // 156\n      var typeError = doTypeChecks(def, val, op);                                                                      // 157\n      if (typeError) {                                                                                                 // 158\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));                                   // 159\n        return;                                                                                                        // 160\n      }                                                                                                                // 161\n                                                                                                                       // 162\n      // Check value against allowedValues array                                                                       // 163\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {                                                  // 164\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));                                // 165\n        return;                                                                                                        // 166\n      }                                                                                                                // 167\n                                                                                                                       // 168\n    }                                                                                                                  // 169\n                                                                                                                       // 170\n    // Perform custom validation                                                                                       // 171\n    var lastDot = affectedKey.lastIndexOf('.');                                                                        // 172\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);                                     // 173\n    var validators = def.custom ? [def.custom] : [];                                                                   // 174\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);                                   // 175\n    _.every(validators, function(validator) {                                                                          // 176\n      var errorType = validator.call(_.extend({                                                                        // 177\n        key: affectedKey,                                                                                              // 178\n        genericKey: affectedKeyGeneric,                                                                                // 179\n        definition: def,                                                                                               // 180\n        isSet: (val !== void 0),                                                                                       // 181\n        value: val,                                                                                                    // 182\n        operator: op,                                                                                                  // 183\n        field: function(fName) {                                                                                       // 184\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed                // 185\n          var keyInfo = mDoc.getInfoForKey(fName) || {};                                                               // 186\n          return {                                                                                                     // 187\n            isSet: (keyInfo.value !== void 0),                                                                         // 188\n            value: keyInfo.value,                                                                                      // 189\n            operator: keyInfo.operator                                                                                 // 190\n          };                                                                                                           // 191\n        },                                                                                                             // 192\n        siblingField: function(fName) {                                                                                // 193\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed                // 194\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};                                             // 195\n          return {                                                                                                     // 196\n            isSet: (keyInfo.value !== void 0),                                                                         // 197\n            value: keyInfo.value,                                                                                      // 198\n            operator: keyInfo.operator                                                                                 // 199\n          };                                                                                                           // 200\n        }                                                                                                              // 201\n      }, extendedCustomContext || {}));                                                                                // 202\n      if (typeof errorType === \"string\") {                                                                             // 203\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));                                   // 204\n        return false;                                                                                                  // 205\n      }                                                                                                                // 206\n      return true;                                                                                                     // 207\n    });                                                                                                                // 208\n  }                                                                                                                    // 209\n                                                                                                                       // 210\n  // The recursive function                                                                                            // 211\n  function checkObj(val, affectedKey, skipRequiredCheck, strictRequiredCheck) {                                        // 212\n    var affectedKeyGeneric, def;                                                                                       // 213\n                                                                                                                       // 214\n    if (affectedKey) {                                                                                                 // 215\n                                                                                                                       // 216\n      // When we hit a blackbox key, we don't progress any further                                                     // 217\n      if (ss.keyIsInBlackBox(affectedKey)) {                                                                           // 218\n        return;                                                                                                        // 219\n      }                                                                                                                // 220\n                                                                                                                       // 221\n      // Make a generic version of the affected key, and use that                                                      // 222\n      // to get the schema for this key.                                                                               // 223\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);                                                     // 224\n      def = ss.getDefinition(affectedKey);                                                                             // 225\n                                                                                                                       // 226\n      // Perform validation for this key                                                                               // 227\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {                   // 228\n        validate(val, affectedKey, affectedKeyGeneric, def, null, skipRequiredCheck, strictRequiredCheck);             // 229\n      }                                                                                                                // 230\n    }                                                                                                                  // 231\n                                                                                                                       // 232\n    // Temporarily convert missing objects to empty objects                                                            // 233\n    // so that the looping code will be called and required                                                            // 234\n    // descendent keys can be validated.                                                                               // 235\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {                        // 236\n      val = {};                                                                                                        // 237\n    }                                                                                                                  // 238\n                                                                                                                       // 239\n    // Loop through arrays                                                                                             // 240\n    if (_.isArray(val)) {                                                                                              // 241\n      _.each(val, function(v, i) {                                                                                     // 242\n        checkObj(v, affectedKey + '.' + i);                                                                            // 243\n      });                                                                                                              // 244\n    }                                                                                                                  // 245\n                                                                                                                       // 246\n    // Loop through object keys                                                                                        // 247\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {                                                  // 248\n                                                                                                                       // 249\n      // Get list of present keys                                                                                      // 250\n      var presentKeys = _.keys(val);                                                                                   // 251\n                                                                                                                       // 252\n      // Check all present keys plus all keys defined by the schema.                                                   // 253\n      // This allows us to detect extra keys not allowed by the schema plus                                            // 254\n      // any missing required keys, and to run any custom functions for other keys.                                    // 255\n      var keysToCheck = _.union(presentKeys, ss._schemaKeys);                                                          // 256\n                                                                                                                       // 257\n      // If this object is within an array, make sure we check for                                                     // 258\n      // required as if it's not a modifier                                                                            // 259\n      strictRequiredCheck = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");                             // 260\n                                                                                                                       // 261\n      // Check all keys in the merged list                                                                             // 262\n      _.each(keysToCheck, function(key) {                                                                              // 263\n        if (Utility.shouldCheck(key)) {                                                                                // 264\n          checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), skipRequiredCheck, strictRequiredCheck);     // 265\n        }                                                                                                              // 266\n      });                                                                                                              // 267\n    }                                                                                                                  // 268\n                                                                                                                       // 269\n  }                                                                                                                    // 270\n                                                                                                                       // 271\n  // Kick off the validation                                                                                           // 272\n  checkObj(obj);                                                                                                       // 273\n                                                                                                                       // 274\n  // Make sure there is only one error per fieldName                                                                   // 275\n  var addedFieldNames = [];                                                                                            // 276\n  invalidKeys = _.filter(invalidKeys, function(errObj) {                                                               // 277\n    if (!_.contains(addedFieldNames, errObj.name)) {                                                                   // 278\n      addedFieldNames.push(errObj.name);                                                                               // 279\n      return true;                                                                                                     // 280\n    }                                                                                                                  // 281\n    return false;                                                                                                      // 282\n  });                                                                                                                  // 283\n                                                                                                                       // 284\n  return invalidKeys;                                                                                                  // 285\n};                                                                                                                     // 286\n                                                                                                                       // 287\nfunction convertModifierToDoc(mod, schema, isUpsert) {                                                                 // 288\n  // Create unmanaged LocalCollection as scratchpad                                                                    // 289\n  var t = new Meteor.Collection(null);                                                                                 // 290\n                                                                                                                       // 291\n  // LocalCollections are in memory, and it seems                                                                      // 292\n  // that it's fine to use them synchronously on                                                                       // 293\n  // either client or server                                                                                           // 294\n  var id;                                                                                                              // 295\n  if (isUpsert) {                                                                                                      // 296\n    // We assume upserts will be inserts (conservative                                                                 // 297\n    // validation of requiredness)                                                                                     // 298\n    id = Random.id();                                                                                                  // 299\n    t.upsert({_id: id}, mod);                                                                                          // 300\n  } else {                                                                                                             // 301\n    var mDoc = new MongoObject(mod);                                                                                   // 302\n    // Create a ficticious existing document                                                                           // 303\n    var fakeDoc = new MongoObject({});                                                                                 // 304\n    _.each(schema, function (def, fieldName) {                                                                         // 305\n      var setVal;                                                                                                      // 306\n      // Prefill doc with empty arrays to avoid the                                                                    // 307\n      // mongodb issue where it does not understand                                                                    // 308\n      // that numeric pieces should create arrays.                                                                     // 309\n      if (def.type === Array && mDoc.affectsGenericKey(fieldName)) {                                                   // 310\n        setVal = [];                                                                                                   // 311\n      }                                                                                                                // 312\n      // Set dummy values for required fields because                                                                  // 313\n      // we assume any existing data would be valid.                                                                   // 314\n      else if (!def.optional) {                                                                                        // 315\n        // TODO correct value type based on schema type                                                                // 316\n        if (def.type === Boolean) {                                                                                    // 317\n          setVal = true;                                                                                               // 318\n        } else if (def.type === Number) {                                                                              // 319\n          setVal = def.min || 0;                                                                                       // 320\n        } else if (def.type === Date) {                                                                                // 321\n          setVal = def.min || new Date();                                                                              // 322\n        } else if (def.type === Array) {                                                                               // 323\n          setVal = [];                                                                                                 // 324\n        } else if (def.type === Object) {                                                                              // 325\n          setVal = {};                                                                                                 // 326\n        } else {                                                                                                       // 327\n          setVal = \"0\";                                                                                                // 328\n        }                                                                                                              // 329\n      }                                                                                                                // 330\n                                                                                                                       // 331\n      if (setVal !== void 0) {                                                                                         // 332\n        var key = fieldName.replace(/\\.\\$/g, \".0\");                                                                    // 333\n        var pos = MongoObject._keyToPosition(key, false);                                                              // 334\n        fakeDoc.setValueForPosition(pos, setVal);                                                                      // 335\n      }                                                                                                                // 336\n    });                                                                                                                // 337\n    fakeDoc = fakeDoc.getObject();                                                                                     // 338\n    // Insert fake doc into local scratch collection                                                                   // 339\n    id = t.insert(fakeDoc);                                                                                            // 340\n    // Now update it with the modifier                                                                                 // 341\n    t.update(id, mod);                                                                                                 // 342\n  }                                                                                                                    // 343\n                                                                                                                       // 344\n  var doc = t.findOne(id);                                                                                             // 345\n  // We're done with it                                                                                                // 346\n  t.remove(id);                                                                                                        // 347\n  // Currently we don't validate _id unless it is                                                                      // 348\n  // explicitly added to the schema                                                                                    // 349\n  if (!schema._id) {                                                                                                   // 350\n    delete doc._id;                                                                                                    // 351\n  }                                                                                                                    // 352\n  return doc;                                                                                                          // 353\n}                                                                                                                      // 354\n                                                                                                                       // 355\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-context.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global SimpleSchema */                                                                                              // 1\n/* global SimpleSchemaValidationContext:true */                                                                        // 2\n/* global doValidation1 */                                                                                             // 3\n/* global doValidation2 */                                                                                             // 4\n                                                                                                                       // 5\nfunction doValidation(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {                           // 6\n  var useOld = true; //for now this can be manually changed to try the experimental method, which doesn't yet work properly\n  var func = useOld ? doValidation1 : doValidation2;                                                                   // 8\n  return func(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext);                                    // 9\n}                                                                                                                      // 10\n                                                                                                                       // 11\n/*                                                                                                                     // 12\n * PUBLIC API                                                                                                          // 13\n */                                                                                                                    // 14\n                                                                                                                       // 15\nSimpleSchemaValidationContext = function SimpleSchemaValidationContext(ss) {                                           // 16\n  var self = this;                                                                                                     // 17\n  self._simpleSchema = ss;                                                                                             // 18\n  self._schema = ss.schema();                                                                                          // 19\n  self._schemaKeys = _.keys(self._schema);                                                                             // 20\n  self._invalidKeys = [];                                                                                              // 21\n  //set up validation dependencies                                                                                     // 22\n  self._deps = {};                                                                                                     // 23\n  self._depsAny = new Deps.Dependency();                                                                               // 24\n  _.each(self._schemaKeys, function(name) {                                                                            // 25\n    self._deps[name] = new Deps.Dependency();                                                                          // 26\n  });                                                                                                                  // 27\n};                                                                                                                     // 28\n                                                                                                                       // 29\n//validates the object against the simple schema and sets a reactive array of error objects                            // 30\nSimpleSchemaValidationContext.prototype.validate = function simpleSchemaValidationContextValidate(doc, options) {      // 31\n  var self = this;                                                                                                     // 32\n  options = _.extend({                                                                                                 // 33\n    modifier: false,                                                                                                   // 34\n    upsert: false,                                                                                                     // 35\n    extendedCustomContext: {}                                                                                          // 36\n  }, options || {});                                                                                                   // 37\n                                                                                                                       // 38\n  //on the client we can add the userId if not already in the custom context                                           // 39\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {                                            // 40\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;                                 // 41\n  }                                                                                                                    // 42\n                                                                                                                       // 43\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, null, self._simpleSchema, options.extendedCustomContext);\n                                                                                                                       // 45\n  //now update self._invalidKeys and dependencies                                                                      // 46\n                                                                                                                       // 47\n  //note any currently invalid keys so that we can mark them as changed                                                // 48\n  //due to new validation (they may be valid now, or invalid in a different way)                                       // 49\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");                                                                // 50\n                                                                                                                       // 51\n  //update                                                                                                             // 52\n  self._invalidKeys = invalidKeys;                                                                                     // 53\n                                                                                                                       // 54\n  //add newly invalid keys to changedKeys                                                                              // 55\n  var addedKeys = _.pluck(self._invalidKeys, \"name\");                                                                  // 56\n                                                                                                                       // 57\n  //mark all changed keys as changed                                                                                   // 58\n  var changedKeys = _.union(addedKeys, removedKeys);                                                                   // 59\n  self._markKeysChanged(changedKeys);                                                                                  // 60\n                                                                                                                       // 61\n  // Return true if it was valid; otherwise, return false                                                              // 62\n  return self._invalidKeys.length === 0;                                                                               // 63\n};                                                                                                                     // 64\n                                                                                                                       // 65\n//validates doc against self._schema for one key and sets a reactive array of error objects                            // 66\nSimpleSchemaValidationContext.prototype.validateOne = function simpleSchemaValidationContextValidateOne(doc, keyName, options) {\n  var self = this, i, ln, k;                                                                                           // 68\n  options = _.extend({                                                                                                 // 69\n    modifier: false,                                                                                                   // 70\n    upsert: false,                                                                                                     // 71\n    extendedCustomContext: {}                                                                                          // 72\n  }, options || {});                                                                                                   // 73\n                                                                                                                       // 74\n  //on the client we can add the userId if not already in the custom context                                           // 75\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {                                            // 76\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;                                 // 77\n  }                                                                                                                    // 78\n                                                                                                                       // 79\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, keyName, self._simpleSchema, options.extendedCustomContext);\n                                                                                                                       // 81\n  //now update self._invalidKeys and dependencies                                                                      // 82\n                                                                                                                       // 83\n  //remove objects from self._invalidKeys where name = keyName                                                         // 84\n  var newInvalidKeys = [];                                                                                             // 85\n  for (i = 0, ln = self._invalidKeys.length; i < ln; i++) {                                                            // 86\n    k = self._invalidKeys[i];                                                                                          // 87\n    if (k.name !== keyName) {                                                                                          // 88\n      newInvalidKeys.push(k);                                                                                          // 89\n    }                                                                                                                  // 90\n  }                                                                                                                    // 91\n  self._invalidKeys = newInvalidKeys;                                                                                  // 92\n                                                                                                                       // 93\n  //merge invalidKeys into self._invalidKeys                                                                           // 94\n  for (i = 0, ln = invalidKeys.length; i < ln; i++) {                                                                  // 95\n    k = invalidKeys[i];                                                                                                // 96\n    self._invalidKeys.push(k);                                                                                         // 97\n  }                                                                                                                    // 98\n                                                                                                                       // 99\n  //mark key as changed due to new validation (they may be valid now, or invalid in a different way)                   // 100\n  self._markKeysChanged([keyName]);                                                                                    // 101\n                                                                                                                       // 102\n  // Return true if it was valid; otherwise, return false                                                              // 103\n  return !self._keyIsInvalid(keyName);                                                                                 // 104\n};                                                                                                                     // 105\n                                                                                                                       // 106\n//reset the invalidKeys array                                                                                          // 107\nSimpleSchemaValidationContext.prototype.resetValidation = function simpleSchemaValidationContextResetValidation() {    // 108\n  var self = this;                                                                                                     // 109\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");                                                                // 110\n  self._invalidKeys = [];                                                                                              // 111\n  self._markKeysChanged(removedKeys);                                                                                  // 112\n};                                                                                                                     // 113\n                                                                                                                       // 114\nSimpleSchemaValidationContext.prototype.isValid = function simpleSchemaValidationContextIsValid() {                    // 115\n  var self = this;                                                                                                     // 116\n  self._depsAny.depend();                                                                                              // 117\n  return !self._invalidKeys.length;                                                                                    // 118\n};                                                                                                                     // 119\n                                                                                                                       // 120\nSimpleSchemaValidationContext.prototype.invalidKeys = function simpleSchemaValidationContextInvalidKeys() {            // 121\n  var self = this;                                                                                                     // 122\n  self._depsAny.depend();                                                                                              // 123\n  return self._invalidKeys;                                                                                            // 124\n};                                                                                                                     // 125\n                                                                                                                       // 126\nSimpleSchemaValidationContext.prototype.addInvalidKeys = function simpleSchemaValidationContextAddInvalidKeys(errors) {\n  var self = this;                                                                                                     // 128\n                                                                                                                       // 129\n  if (!errors || !errors.length) {                                                                                     // 130\n    return;                                                                                                            // 131\n  }                                                                                                                    // 132\n                                                                                                                       // 133\n  var changedKeys = [];                                                                                                // 134\n  _.each(errors, function (errorObject) {                                                                              // 135\n    changedKeys.push(errorObject.name);                                                                                // 136\n    self._invalidKeys.push(errorObject);                                                                               // 137\n  });                                                                                                                  // 138\n                                                                                                                       // 139\n  self._markKeysChanged(changedKeys);                                                                                  // 140\n};                                                                                                                     // 141\n                                                                                                                       // 142\nSimpleSchemaValidationContext.prototype._markKeysChanged = function simpleSchemaValidationContextMarkKeysChanged(keys) {\n  var self = this;                                                                                                     // 144\n                                                                                                                       // 145\n  if (!keys || !keys.length) {                                                                                         // 146\n    return;                                                                                                            // 147\n  }                                                                                                                    // 148\n                                                                                                                       // 149\n  _.each(keys, function(name) {                                                                                        // 150\n    var genericName = SimpleSchema._makeGeneric(name);                                                                 // 151\n    if (genericName in self._deps) {                                                                                   // 152\n      self._deps[genericName].changed();                                                                               // 153\n    }                                                                                                                  // 154\n  });                                                                                                                  // 155\n  self._depsAny.changed();                                                                                             // 156\n};                                                                                                                     // 157\n                                                                                                                       // 158\nSimpleSchemaValidationContext.prototype._getInvalidKeyObject = function simpleSchemaValidationContextGetInvalidKeyObject(name, genericName) {\n  var self = this;                                                                                                     // 160\n  genericName = genericName || SimpleSchema._makeGeneric(name);                                                        // 161\n                                                                                                                       // 162\n  var errorObj = _.findWhere(self._invalidKeys, {name: name});                                                         // 163\n  if (!errorObj) {                                                                                                     // 164\n    errorObj = _.findWhere(self._invalidKeys, {name: genericName});                                                    // 165\n  }                                                                                                                    // 166\n  return errorObj;                                                                                                     // 167\n};                                                                                                                     // 168\n                                                                                                                       // 169\nSimpleSchemaValidationContext.prototype._keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name, genericName) {\n  return !!this._getInvalidKeyObject(name, genericName);                                                               // 171\n};                                                                                                                     // 172\n                                                                                                                       // 173\n// Like the internal one, but with deps                                                                                // 174\nSimpleSchemaValidationContext.prototype.keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name) {      // 175\n  var self = this, genericName = SimpleSchema._makeGeneric(name);                                                      // 176\n  self._deps[genericName] && self._deps[genericName].depend();                                                         // 177\n                                                                                                                       // 178\n  return self._keyIsInvalid(name, genericName);                                                                        // 179\n};                                                                                                                     // 180\n                                                                                                                       // 181\nSimpleSchemaValidationContext.prototype.keyErrorMessage = function simpleSchemaValidationContextKeyErrorMessage(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);                                                      // 183\n  self._deps[genericName] && self._deps[genericName].depend();                                                         // 184\n                                                                                                                       // 185\n  var errorObj = self._getInvalidKeyObject(name, genericName);                                                         // 186\n  if (!errorObj) {                                                                                                     // 187\n    return \"\";                                                                                                         // 188\n  }                                                                                                                    // 189\n                                                                                                                       // 190\n  return self._simpleSchema.messageForError(errorObj.type, errorObj.name, null, errorObj.value);                       // 191\n};                                                                                                                     // 192\n                                                                                                                       // 193\nSimpleSchemaValidationContext.prototype.getErrorObject = function simpleSchemaValidationContextGetErrorObject() {      // 194\n  var self = this, message, invalidKeys = this._invalidKeys;                                                           // 195\n  if (invalidKeys.length) {                                                                                            // 196\n    message = self.keyErrorMessage(invalidKeys[0].name);                                                               // 197\n    // We add `message` prop to the invalidKeys.                                                                       // 198\n    invalidKeys = _.map(invalidKeys, function (o) {                                                                    // 199\n      return _.extend({message: self.keyErrorMessage(o.name)}, o);                                                     // 200\n    });                                                                                                                // 201\n  } else {                                                                                                             // 202\n    message = \"Failed validation\";                                                                                     // 203\n  }                                                                                                                    // 204\n  var error = new Error(message);                                                                                      // 205\n  error.invalidKeys = invalidKeys;                                                                                     // 206\n  // If on the server, we add a sanitized error, too, in case we're                                                    // 207\n  // called from a method.                                                                                             // 208\n  if (Meteor.isServer) {                                                                                               // 209\n    error.sanitizedError = new Meteor.Error(400, message);                                                             // 210\n  }                                                                                                                    // 211\n  return error;                                                                                                        // 212\n};                                                                                                                     // 213\n                                                                                                                       // 214\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['aldeed:simple-schema'] = {}, {\n  SimpleSchema: SimpleSchema,\n  MongoObject: MongoObject,\n  humanize: humanize\n});\n\n})();\n","servePath":"/packages/aldeed_simple-schema.js","sourceMap":{"version":3,"sources":["/packages/aldeed_simple-schema/string-polyfills.js","/packages/aldeed_simple-schema/string-humanize.js","/packages/aldeed_simple-schema/mongo-object.js","/packages/aldeed_simple-schema/simple-schema-utility.js","/packages/aldeed_simple-schema/simple-schema.js","/packages/aldeed_simple-schema/simple-schema-validation.js","/packages/aldeed_simple-schema/simple-schema-validation-new.js","/packages/aldeed_simple-schema/simple-schema-context.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACnvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H;;;;;;;;;;;;;;;;;;AChqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/aldeed_simple-schema.js","sourcesContent":["if (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n","/*\n  Code source:\n    https://github.com/jxson/string-humanize\n    https://github.com/jxson/string-capitalize\n */\n\nfunction capitalize(string){\n  string = string || '';\n  string = string.trim();\n\n  if (string[0]) {\n    string = string[0].toUpperCase() + string.substr(1).toLowerCase();\n  }\n\n  return string;\n}\n\nhumanize = function humanize(string){\n  string = string || '';\n  string = string.toString(); // might be a number\n  string = string.trim();\n  string = string.replace(extname(string), '');\n  string = underscore(string);\n  string = string.replace(/[\\W_]+/g, ' ');\n\n  return capitalize(string);\n}\n\n\nfunction underscore(string){\n  string = string || '';\n  string = string.toString(); // might be a number\n  string = string.trim();\n  string = string.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2');\n  string = string.replace(/[-\\s]+/g, '_').toLowerCase();\n\n  return string;\n}\n\nfunction extname(string){\n  var index = string.lastIndexOf('.');\n  var ext = string.substring(index, string.length);\n\n  return (index === -1) ? '' : ext;\n}\n","/* global MongoObject:true */\n\n\nvar isObject = function(obj) {\n  return obj === Object(obj);\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n/* Takes a specific string that uses mongo-style dot notation\n * and returns a generic string equivalent. Replaces all numeric\n * \"pieces\" with a dollar sign ($).\n *\n * @param {type} name\n * @returns {unresolved}\n */\nvar makeGeneric = function makeGeneric(name) {\n  if (typeof name !== \"string\") {\n    return null;\n  }\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+$/g, '.$');\n};\n\nvar appendAffectedKey = function appendAffectedKey(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};\n\n// Extracts operator piece, if present, from position string\nvar extractOp = function extractOp(position) {\n  var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n  return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n};\n\n/*\n * @constructor\n * @param {Object} objOrModifier\n * @param {string[]} blackBoxKeys - A list of the names of keys that shouldn't be traversed\n * @returns {undefined}\n *\n * Creates a new MongoObject instance. The object passed as the first argument\n * will be modified in place by calls to instance methods. Also, immediately\n * upon creation of the instance, the object will have any `undefined` keys\n * removed recursively.\n */\nMongoObject = function(objOrModifier, blackBoxKeys) {\n  var self = this;\n  self._obj = objOrModifier;\n  self._affectedKeys = {};\n  self._genericAffectedKeys = {};\n  self._parentPositions = [];\n  self._positionsInsideArrays = [];\n  self._objectPositions = [];\n\n  function parseObj(val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\n\n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    var affectedKeyIsBlackBox = false;\n    var affectedKeyGeneric;\n    var stop = false;\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet and $pull and $pop\n      if (!adjusted) {\n        if (operator === \"$push\" || operator === \"$addToSet\" || operator === \"$pop\") {\n          // Adjust for $each\n          // We can simply jump forward and pretend like the $each array\n          // is the array for the field. This has the added benefit of\n          // skipping past any $slice, which we also don't care about.\n          if (isBasicObject(val) && \"$each\" in val) {\n            val = val.$each;\n            currentPosition = currentPosition + \"[$each]\";\n          } else {\n            affectedKey = affectedKey + \".0\";\n          }\n          adjusted = true;\n        } else if (operator === \"$pull\") {\n          affectedKey = affectedKey + \".0\";\n          if (isBasicObject(val)) {\n            stop = true;\n          }\n          adjusted = true;\n        }\n      }\n\n      // Make generic key\n      affectedKeyGeneric = makeGeneric(affectedKey);\n\n      // Determine whether affected key should be treated as a black box\n      affectedKeyIsBlackBox = _.contains(blackBoxKeys, affectedKeyGeneric);\n\n      // Mark that this position affects this generic and non-generic key\n      if (currentPosition) {\n        self._affectedKeys[currentPosition] = affectedKey;\n        self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\n\n        // If we're within an array, mark this position so we can omit it from flat docs\n        isWithinArray && self._positionsInsideArrays.push(currentPosition);\n      }\n    }\n\n    if (stop) {\n      return;\n    }\n\n    // Loop through arrays\n    if (_.isArray(val) && !_.isEmpty(val)) {\n      if (currentPosition) {\n        // Mark positions with arrays that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n      }\n\n      // Loop\n      _.each(val, function(v, i) {\n        parseObj(v, (currentPosition ? currentPosition + \"[\" + i + \"]\" : i), affectedKey + '.' + i, operator, adjusted, true);\n      });\n    }\n\n    // Loop through object keys, only for basic objects,\n    // but always for the passed-in object, even if it\n    // is a custom object.\n    else if ((isBasicObject(val) && !affectedKeyIsBlackBox) || !currentPosition) {\n      if (currentPosition && !_.isEmpty(val)) {\n        // Mark positions with objects that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n        // Mark positions with objects that should be left out of flat docs.\n        self._objectPositions.push(currentPosition);\n      }\n      // Loop\n      _.each(val, function(v, k) {\n        if (v === void 0) {\n          delete val[k];\n        } else if (k !== \"$slice\") {\n          parseObj(v, (currentPosition ? currentPosition + \"[\" + k + \"]\" : k), appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\n        }\n      });\n    }\n\n  }\n  parseObj(self._obj);\n\n  function reParseObj() {\n    self._affectedKeys = {};\n    self._genericAffectedKeys = {};\n    self._parentPositions = [];\n    self._positionsInsideArrays = [];\n    self._objectPositions = [];\n    parseObj(self._obj);\n  }\n\n  /**\n   * @method MongoObject.forEachNode\n   * @param {Function} func\n   * @param {Object} [options]\n   * @param {Boolean} [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n   * @returns {undefined}\n   *\n   * Runs a function for each endpoint node in the object tree, including all items in every array.\n   * The function arguments are\n   * (1) the value at this node\n   * (2) a string representing the node position\n   * (3) the representation of what would be changed in mongo, using mongo dot notation\n   * (4) the generic equivalent of argument 3, with \"$\" instead of numeric pieces\n   */\n  self.forEachNode = function(func, options) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"filter requires a loop function\");\n    }\n\n    options = _.extend({\n      endPointsOnly: true\n    }, options);\n\n    var updatedValues = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (options.endPointsOnly && _.contains(self._parentPositions, position)) {\n        return; //only endpoints\n      }\n      func.call({\n        value: self.getValueForPosition(position),\n        operator: extractOp(position),\n        position: position,\n        key: affectedKey,\n        genericKey: self._genericAffectedKeys[position],\n        updateValue: function(newVal) {\n          updatedValues[position] = newVal;\n        },\n        remove: function() {\n          updatedValues[position] = void 0;\n        }\n      });\n    });\n\n    // Actually update/remove values as instructed\n    _.each(updatedValues, function(newVal, position) {\n      self.setValueForPosition(position, newVal);\n    });\n\n  };\n\n  self.getValueForPosition = function(position) {\n    var subkey, subkeys = position.split(\"[\"), current = self._obj;\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      current = current[subkey];\n      if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n        return;\n      }\n    }\n    return current;\n  };\n\n  /**\n   * @method MongoObject.prototype.setValueForPosition\n   * @param {String} position\n   * @param {Any} value\n   * @returns {undefined}\n   */\n  self.setValueForPosition = function(position, value) {\n    var nextPiece, subkey, subkeys = position.split(\"[\"), current = self._obj;\n\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      // If we've reached the key in the object tree that needs setting or\n      // deleting, do it.\n      if (i === ln - 1) {\n        current[subkey] = value;\n        //if value is undefined, delete the property\n        if (value === void 0) {\n          delete current[subkey];\n        }\n      }\n      // Otherwise attempt to keep moving deeper into the object.\n      else {\n        // If we're setting (as opposed to deleting) a key and we hit a place\n        // in the ancestor chain where the keys are not yet created, create them.\n        if (current[subkey] === void 0 && value !== void 0) {\n          //see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          current[subkey] = isNaN(nextPiece) ? {} : [];\n        }\n\n        // Move deeper into the object\n        current = current[subkey];\n\n        // If we can go no further, then quit\n        if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n          return;\n        }\n      }\n    }\n\n    reParseObj();\n  };\n\n  /**\n   * @method MongoObject.prototype.removeValueForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.removeValueForPosition = function(position) {\n    self.setValueForPosition(position, void 0);\n  };\n\n  /**\n   * @method MongoObject.prototype.getKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getKeyForPosition = function(position) {\n    return self._affectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.prototype.getGenericKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getGenericKeyForPosition = function(position) {\n    return self._genericAffectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.getInfoForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Object}\n   *\n   * Returns the value and operator of the requested non-generic key.\n   * Example: {value: 1, operator: \"$pull\"}\n   */\n  self.getInfoForKey = function(key) {\n    // Get the info\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return {\n        value: self.getValueForPosition(position),\n        operator: extractOp(position)\n      };\n    }\n\n    // If we haven't returned yet, check to see if there is an array value\n    // corresponding to this key\n    // We find the first item within the array, strip the last piece off the\n    // position string, and then return whatever is at that new position in\n    // the original object.\n    var positions = self.getPositionsForGenericKey(key + \".$\"), p, v;\n    for (var i = 0, ln = positions.length; i < ln; i++) {\n      p = positions[i];\n      v = self.getValueForPosition(p) || self.getValueForPosition(p.slice(0, p.lastIndexOf(\"[\")));\n      if (v) {\n        return {\n          value: v,\n          operator: extractOp(p)\n        };\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getPositionForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|String} Position string\n   *\n   * Returns the position string for the place in the object that\n   * affects the requested non-generic key.\n   * Example: 'foo[bar][0]'\n   */\n  self.getPositionForKey = function(key) {\n    // Get the info\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same non-generic key, we'll assume that's not the case.\n          return position;\n        }\n      }\n    }\n\n    // If we haven't returned yet, we need to check for affected keys\n  };\n\n  /**\n   * @method MongoObject.getPositionsForGenericKey\n   * @param {String} key - Generic key\n   * @returns {String[]} Array of position strings\n   *\n   * Returns an array of position strings for the places in the object that\n   * affect the requested generic key.\n   * Example: ['foo[bar][0]']\n   */\n  self.getPositionsForGenericKey = function(key) {\n    // Get the info\n    var list = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          list.push(position);\n        }\n      }\n    }\n\n    return list;\n  };\n\n  /**\n   * @deprecated Use getInfoForKey\n   * @method MongoObject.getValueForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Any}\n   *\n   * Returns the value of the requested non-generic key\n   */\n  self.getValueForKey = function(key) {\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return self.getValueForPosition(position);\n    }\n  };\n\n  /**\n   * @method MongoObject.prototype.addKey\n   * @param {String} key - Key to set\n   * @param {Any} val - Value to give this key\n   * @param {String} op - Operator under which to set it, or `null` for a non-modifier object\n   * @returns {undefined}\n   *\n   * Adds `key` with value `val` under operator `op` to the source object.\n   */\n  self.addKey = function(key, val, op) {\n    var position = op ? op + \"[\" + key + \"]\" : MongoObject._keyToPosition(key);\n    self.setValueForPosition(position, val);\n  };\n\n  /**\n   * @method MongoObject.prototype.removeGenericKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the generic keys in the list\n   */\n  self.removeGenericKeys = function(keys) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (_.contains(keys, self._genericAffectedKeys[position])) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeGenericKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested generic key\n   */\n  self.removeGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested non-generic key\n   */\n  self.removeKey = function(key) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // remove for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the non-generic keys in the list\n   */\n  self.removeKeys = function(keys) {\n    for (var i = 0, ln = keys.length; i < ln; i++) {\n      self.removeKey(keys[i]);\n    }\n  };\n\n  /**\n   * @method MongoObject.filterGenericKeys\n   * @param {Function} test - Test function\n   * @returns {undefined}\n   *\n   * Passes all affected keys to a test function, which\n   * should return false to remove whatever is affecting that key\n   */\n  self.filterGenericKeys = function(test) {\n    var gk, checkedKeys = [], keysToRemove = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        gk = self._genericAffectedKeys[position];\n        if (!_.contains(checkedKeys, gk)) {\n          checkedKeys.push(gk);\n          if (gk && !test(gk)) {\n            keysToRemove.push(gk);\n          }\n        }\n      }\n    }\n\n    _.each(keysToRemove, function(key) {\n      self.removeGenericKey(key);\n    });\n  };\n\n  /**\n   * @method MongoObject.setValueForKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested non-generic key\n   */\n  self.setValueForKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.setValueForGenericKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested generic key\n   */\n  self.setValueForGenericKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getObject\n   * @returns {Object}\n   *\n   * Get the source object, potentially modified by other method calls on this\n   * MongoObject instance.\n   */\n  self.getObject = function() {\n    return self._obj;\n  };\n\n  /**\n   * @method MongoObject.getFlatObject\n   * @returns {Object}\n   *\n   * Gets a flat object based on the MongoObject instance.\n   * In a flat object, the key is the name of the non-generic affectedKey,\n   * with mongo dot notation if necessary, and the value is the value for\n   * that key.\n   *\n   * With `keepArrays: true`, we don't flatten within arrays. Currently\n   * MongoDB does not see a key such as `a.0.b` and automatically assume\n   * an array. Instead it would create an object with key \"0\" if there\n   * wasn't already an array saved as the value of `a`, which is rarely\n   * if ever what we actually want. To avoid this confusion, we\n   * set entire arrays.\n   */\n  self.getFlatObject = function(options) {\n    options = options || {};\n    var newObj = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (typeof affectedKey === \"string\" &&\n        (options.keepArrays === true && !_.contains(self._positionsInsideArrays, position) && !_.contains(self._objectPositions, position)) ||\n        (!options.keepArrays && !_.contains(self._parentPositions, position))\n        ) {\n        newObj[affectedKey] = self.getValueForPosition(position);\n      }\n    });\n    return newObj;\n  };\n\n  /**\n   * @method MongoObject.affectsKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the non-generic key is affected by this object\n   */\n  self.affectsKey = function(key) {\n    return !!self.getPositionForKey(key);\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the generic key is affected by this object\n   */\n  self.affectsGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKeyImplicit\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Like affectsGenericKey, but will return true if a child key is affected\n   */\n  self.affectsGenericKeyImplicit = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        var affectedKey = self._genericAffectedKeys[position];\n\n        // If the affected key is the test key\n        if (affectedKey === key) {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key followed by a period\n        if (affectedKey.substring(0, key.length + 1) === key + \".\") {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key and the test key ends with \".$\"\n        var lastTwo = key.slice(-2);\n        if (lastTwo === \".$\" && key.slice(0, -2) === affectedKey) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n */\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n *\n * @param {any} val\n * @param {String} key\n * @param {Object} obj\n * @returns {undefined}\n */\nMongoObject.expandKey = function(val, key, obj) {\n  var nextPiece, subkey, subkeys = key.split(\"[\"), current = obj;\n  for (var i = 0, ln = subkeys.length; i < ln; i++) {\n    subkey = subkeys[i];\n    if (subkey.slice(-1) === \"]\") {\n      subkey = subkey.slice(0, -1);\n    }\n    if (i === ln - 1) {\n      //last iteration; time to set the value; always overwrite\n      current[subkey] = val;\n      //if val is undefined, delete the property\n      if (val === void 0) {\n        delete current[subkey];\n      }\n    } else {\n      //see if the next piece is a number\n      nextPiece = subkeys[i + 1];\n      nextPiece = parseInt(nextPiece, 10);\n      if (!current[subkey]) {\n        current[subkey] = isNaN(nextPiece) ? {} : [];\n      }\n    }\n    current = current[subkey];\n  }\n};\n\nMongoObject._keyToPosition = function keyToPosition(key, wrapAll) {\n  var position = '';\n  _.each(key.split(\".\"), function (piece, i) {\n    if (i === 0 && !wrapAll) {\n      position += piece;\n    } else {\n      position += \"[\" + piece + \"]\";\n    }\n  });\n  return position;\n};\n\n/**\n * @method MongoObject._positionToKey\n * @param {String} position\n * @returns {String} The key that this position in an object would affect.\n *\n * This is different from MongoObject.prototype.getKeyForPosition in that\n * this method does not depend on the requested position actually being\n * present in any particular MongoObject.\n */\nMongoObject._positionToKey = function positionToKey(position) {\n  //XXX Probably a better way to do this, but this is\n  //foolproof for now.\n  var mDoc = new MongoObject({});\n  mDoc.setValueForPosition(position, 1); //value doesn't matter\n  var key = mDoc.getKeyForPosition(position);\n  mDoc = null;\n  return key;\n};\n\n","/* global Utility:true */\n\nUtility = {\n  appendAffectedKey: function appendAffectedKey(affectedKey, key) {\n    if (key === \"$each\") {\n      return affectedKey;\n    } else {\n      return (affectedKey ? affectedKey + \".\" + key : key);\n    }\n  },\n  shouldCheck: function shouldCheck(key) {\n    if (key === \"$pushAll\") {\n      throw new Error(\"$pushAll is not supported; use $push + $each\");\n    }\n    return !_.contains([\"$pull\", \"$pullAll\", \"$pop\", \"$slice\"], key);\n  },\n  errorObject: function errorObject(errorType, keyName, keyValue) {\n    return {name: keyName, type: errorType, value: keyValue};\n  },\n  // Tests whether it's an Object as opposed to something that inherits from Object\n  isBasicObject: function isBasicObject(obj) {\n    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n  },\n  // The latest Safari returns false for Uint8Array, etc. instanceof Function\n  // unlike other browsers.\n  safariBugFix: function safariBugFix(type) {\n    return (typeof Uint8Array !== \"undefined\" && type === Uint8Array) ||\n      (typeof Uint16Array !== \"undefined\" && type === Uint16Array) ||\n      (typeof Uint32Array !== \"undefined\" && type === Uint32Array) ||\n      (typeof Uint8ClampedArray !== \"undefined\" && type === Uint8ClampedArray);\n  },\n  isNotNullOrUndefined: function isNotNullOrUndefined(val) {\n    return val !== void 0 && val !== null;\n  },\n  // Extracts operator piece, if present, from position string\n  extractOp: function extractOp(position) {\n    var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n    return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n  },\n  deleteIfPresent: function deleteIfPresent(obj, key) {\n    if (key in obj) {\n      delete obj[key];\n    }\n  },\n  looksLikeModifier: function looksLikeModifier(obj) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n        return true;\n      }\n    }\n    return false;\n  },\n  dateToDateString: function dateToDateString(date) {\n    var m = (date.getUTCMonth() + 1);\n    if (m < 10) {\n      m = \"0\" + m;\n    }\n    var d = date.getUTCDate();\n    if (d < 10) {\n      d = \"0\" + d;\n    }\n    return date.getUTCFullYear() + '-' + m + '-' + d;\n  }\n};\n","/* global SimpleSchema:true */\n/* global SimpleSchemaValidationContext */\n/* global MongoObject */\n/* global Utility */\n\nvar schemaDefinition = {\n  type: Match.Any,\n  label: Match.Optional(Match.OneOf(String, Function)),\n  optional: Match.Optional(Match.OneOf(Boolean, Function)),\n  min: Match.Optional(Match.OneOf(Number, Date, Function)),\n  max: Match.Optional(Match.OneOf(Number, Date, Function)),\n  minCount: Match.Optional(Match.OneOf(Number, Function)),\n  maxCount: Match.Optional(Match.OneOf(Number, Function)),\n  allowedValues: Match.Optional(Match.OneOf([Match.Any], Function)),\n  decimal: Match.Optional(Boolean),\n  exclusiveMax: Match.Optional(Boolean),\n  exclusiveMin: Match.Optional(Boolean),\n  regEx: Match.Optional(Match.OneOf(RegExp, [RegExp])),\n  custom: Match.Optional(Function),\n  blackbox: Match.Optional(Boolean),\n  autoValue: Match.Optional(Function),\n  defaultValue: Match.Optional(Match.Any),\n  trim: Match.Optional(Boolean)\n};\n\n/*\n * PRIVATE FUNCTIONS\n */\n\n//called by clean()\nvar typeconvert = function(value, type) {\n  var parsedDate;\n\n  if (_.isArray(value) || (_.isObject(value) && !(value instanceof Date))) {\n    return value; //can't and shouldn't convert arrays or objects\n  }\n  if (type === String) {\n    if (typeof value !== \"undefined\" && value !== null && typeof value !== \"string\") {\n      return value.toString();\n    }\n    return value;\n  }\n  if (type === Number) {\n    if (typeof value === \"string\" && !_.isEmpty(value)) {\n      //try to convert numeric strings to numbers\n      var numberVal = Number(value);\n      if (!isNaN(numberVal)) {\n        return numberVal;\n      } else {\n        return value; //leave string; will fail validation\n      }\n    }\n    return value;\n  }\n  //\n  // If target type is a Date we can safely convert from either a\n  // number (Integer value representing the number of milliseconds\n  // since 1 January 1970 00:00:00 UTC) or a string that can be parsed\n  // by Date.\n  //\n  if (type === Date) {\n    if (typeof value === \"string\") {\n      parsedDate = Date.parse(value);\n      if (isNaN(parsedDate) === false) {\n        return new Date(parsedDate);\n      }\n    }\n    if (typeof value === \"number\") {\n      return new Date(value);\n    }\n  }\n  return value;\n};\n\nvar expandSchema = function(schema) {\n  // Flatten schema by inserting nested definitions\n  _.each(schema, function(val, key) {\n    var dot, type;\n    if (!val) {\n      return;\n    }\n    if (Match.test(val.type, SimpleSchema)) {\n      dot = '.';\n      type = val.type;\n      val.type = Object;\n    } else if (Match.test(val.type, [SimpleSchema])) {\n      dot = '.$.';\n      type = val.type[0];\n      val.type = [Object];\n    } else {\n      return;\n    }\n    //add child schema definitions to parent schema\n    _.each(type._schema, function(subVal, subKey) {\n      var newKey = key + dot + subKey;\n      if (!(newKey in schema)) {\n        schema[newKey] = subVal;\n      }\n    });\n  });\n  return schema;\n};\n\nvar adjustArrayFields = function(schema) {\n  _.each(schema, function(def, existingKey) {\n    if (_.isArray(def.type) || def.type === Array) {\n      // Copy some options to array-item definition\n      var itemKey = existingKey + \".$\";\n      if (!(itemKey in schema)) {\n        schema[itemKey] = {};\n      }\n      if (_.isArray(def.type)) {\n        schema[itemKey].type = def.type[0];\n      }\n      if (def.label) {\n        schema[itemKey].label = def.label;\n      }\n      schema[itemKey].optional = true;\n      if (typeof def.min !== \"undefined\") {\n        schema[itemKey].min = def.min;\n      }\n      if (typeof def.max !== \"undefined\") {\n        schema[itemKey].max = def.max;\n      }\n      if (typeof def.allowedValues !== \"undefined\") {\n        schema[itemKey].allowedValues = def.allowedValues;\n      }\n      if (typeof def.decimal !== \"undefined\") {\n        schema[itemKey].decimal = def.decimal;\n      }\n      if (typeof def.exclusiveMax !== \"undefined\") {\n        schema[itemKey].exclusiveMax = def.exclusiveMax;\n      }\n      if (typeof def.exclusiveMin !== \"undefined\") {\n        schema[itemKey].exclusiveMin = def.exclusiveMin;\n      }\n      if (typeof def.regEx !== \"undefined\") {\n        schema[itemKey].regEx = def.regEx;\n      }\n      if (typeof def.blackbox !== \"undefined\") {\n        schema[itemKey].blackbox = def.blackbox;\n      }\n      // Remove copied options and adjust type\n      def.type = Array;\n      _.each(['min', 'max', 'allowedValues', 'decimal', 'exclusiveMax', 'exclusiveMin', 'regEx', 'blackbox'], function(k) {\n        Utility.deleteIfPresent(def, k);\n      });\n    }\n  });\n};\n\n/**\n * Adds implied keys.\n * * If schema contains a key like \"foo.$.bar\" but not \"foo\", adds \"foo\".\n * * If schema contains a key like \"foo\" with an array type, adds \"foo.$\".\n * @param {Object} schema\n * @returns {Object} modified schema\n */\nvar addImplicitKeys = function(schema) {\n  var arrayKeysToAdd = [], objectKeysToAdd = [], newKey, key, i, ln;\n\n  // Pass 1 (objects)\n  _.each(schema, function(def, existingKey) {\n    var pos = existingKey.indexOf(\".\");\n    while (pos !== -1) {\n      newKey = existingKey.substring(0, pos);\n\n      // It's an array item; nothing to add\n      if (newKey.substring(newKey.length - 2) === \".$\") {\n        pos = -1;\n      }\n      // It's an array of objects; add it with type [Object] if not already in the schema\n      else if (existingKey.substring(pos, pos + 3) === \".$.\") {\n        arrayKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 3); // skip over next dot, find the one after\n      }\n      // It's an object; add it with type Object if not already in the schema\n      else {\n        objectKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 1); // find next dot\n      }\n    }\n  });\n\n  for (i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {\n    key = arrayKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: [Object], optional: true};\n    }\n  }\n\n  for (i = 0, ln = objectKeysToAdd.length; i < ln; i++) {\n    key = objectKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: Object, optional: true};\n    }\n  }\n\n  // Pass 2 (arrays)\n  adjustArrayFields(schema);\n\n  return schema;\n};\n\nvar mergeSchemas = function(schemas) {\n\n  // Merge all provided schema definitions.\n  // This is effectively a shallow clone of each object, too,\n  // which is what we want since we are going to manipulate it.\n  var mergedSchema = {};\n  _.each(schemas, function(schema) {\n\n    // Create a temporary SS instance so that the internal object\n    // we use for merging/extending will be fully expanded\n    if (Match.test(schema, SimpleSchema)) {\n      schema = schema._schema;\n    } else {\n      schema = addImplicitKeys(expandSchema(schema));\n    }\n\n    // Loop through and extend each individual field\n    // definition. That way you can extend and overwrite\n    // base field definitions.\n    _.each(schema, function(def, field) {\n      mergedSchema[field] = mergedSchema[field] || {};\n      _.extend(mergedSchema[field], def);\n    });\n\n  });\n\n  // If we merged some schemas, do this again to make sure\n  // extended definitions are pushed into array item field\n  // definitions properly.\n  schemas.length && adjustArrayFields(mergedSchema);\n\n  return mergedSchema;\n};\n\n// Returns an object relating the keys in the list\n// to their parent object.\nvar getObjectKeys = function(schema, schemaKeyList) {\n  var keyPrefix, remainingText, rKeys = {}, loopArray;\n  _.each(schema, function(definition, fieldName) {\n    if (definition.type === Object) {\n      //object\n      keyPrefix = fieldName + \".\";\n    } else {\n      return;\n    }\n\n    loopArray = [];\n    _.each(schemaKeyList, function(fieldName2) {\n      if (fieldName2.startsWith(keyPrefix)) {\n        remainingText = fieldName2.substring(keyPrefix.length);\n        if (remainingText.indexOf(\".\") === -1) {\n          loopArray.push(remainingText);\n        }\n      }\n    });\n    rKeys[keyPrefix] = loopArray;\n  });\n  return rKeys;\n};\n\n// returns an inflected version of fieldName to use as the label\nvar inflectedLabel = function(fieldName) {\n  var label = fieldName, lastPeriod = label.lastIndexOf(\".\");\n  if (lastPeriod !== -1) {\n    label = label.substring(lastPeriod + 1);\n    if (label === \"$\") {\n      var pcs = fieldName.split(\".\");\n      label = pcs[pcs.length - 2];\n    }\n  }\n  if (label === \"_id\") {\n    return \"ID\";\n  }\n  return humanize(label);\n};\n\n/**\n * @method getAutoValues\n * @private\n * @param {MongoObject} mDoc\n * @param {Boolean} [isModifier=false] - Is it a modifier doc?\n * @param {Object} [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\n * @returns {undefined}\n *\n * Updates doc with automatic values from autoValue functions or default\n * values from defaultValue. Modifies the referenced object in place.\n */\nfunction getAutoValues(mDoc, isModifier, extendedAutoValueContext) {\n  var self = this;\n  var doneKeys = [];\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && extendedAutoValueContext.userId === void 0) {\n    extendedAutoValueContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  function runAV(func) {\n    var affectedKey = this.key;\n    // If already called for this key, skip it\n    if (_.contains(doneKeys, affectedKey)) {\n      return;\n    }\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var doUnset = false;\n    var autoValue = func.call(_.extend({\n      isSet: (this.value !== void 0),\n      unset: function() {\n        doUnset = true;\n      },\n      value: this.value,\n      operator: this.operator,\n      field: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      },\n      siblingField: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      }\n    }, extendedAutoValueContext || {}), mDoc.getObject());\n\n    // Update tracking of which keys we've run autovalue for\n    doneKeys.push(affectedKey);\n\n    if (autoValue === void 0) {\n      if (doUnset) {\n        mDoc.removeValueForPosition(this.position);\n      }\n      return;\n    }\n\n    // If the user's auto value is of the pseudo-modifier format, parse it\n    // into operator and value.\n    var op, newValue;\n    if (_.isObject(autoValue)) {\n      for (var key in autoValue) {\n        if (autoValue.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n          op = key;\n          newValue = autoValue[key];\n          break;\n        }\n      }\n    }\n\n    // Add $set for updates and upserts if necessary\n    if (!op && isModifier && this.position.slice(0, 1) !== '$') {\n      op = \"$set\";\n      newValue = autoValue;\n    }\n\n    // Update/change value\n    if (op) {\n      mDoc.removeValueForPosition(this.position);\n      mDoc.setValueForPosition(op + '[' + affectedKey + ']', newValue);\n    } else {\n      mDoc.setValueForPosition(this.position, autoValue);\n    }\n  }\n\n  _.each(self._autoValues, function(func, fieldName) {\n    var positionSuffix, key, keySuffix, positions;\n\n    // If we're under an array, run autovalue for all the properties of\n    // any objects that are present in the nearest ancestor array.\n    if (fieldName.indexOf(\"$\") !== -1) {\n      var testField = fieldName.slice(0, fieldName.lastIndexOf(\"$\") + 1);\n      keySuffix = fieldName.slice(testField.length + 1);\n      positionSuffix = MongoObject._keyToPosition(keySuffix, true);\n      keySuffix = '.' + keySuffix;\n      positions = mDoc.getPositionsForGenericKey(testField);\n    } else {\n\n      // See if anything in the object affects this key\n      positions = mDoc.getPositionsForGenericKey(fieldName);\n\n      // Run autovalue for properties that are set in the object\n      if (positions.length) {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n      }\n\n      // Run autovalue for properties that are NOT set in the object\n      else {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n        if (isModifier) {\n          positions = [\"$set[\" + fieldName + \"]\"];\n        } else {\n          positions = [MongoObject._keyToPosition(fieldName)];\n        }\n      }\n\n    }\n\n    _.each(positions, function(position) {\n      runAV.call({\n        key: (key || MongoObject._positionToKey(position)) + keySuffix,\n        value: mDoc.getValueForPosition(position + positionSuffix),\n        operator: Utility.extractOp(position),\n        position: position + positionSuffix\n      }, func);\n    });\n  });\n}\n\n//exported\nSimpleSchema = function(schemas, options) {\n  var self = this;\n  var firstLevelSchemaKeys = [];\n  var fieldNameRoot;\n  options = options || {};\n  schemas = schemas || {};\n\n  if (!_.isArray(schemas)) {\n    schemas = [schemas];\n  }\n\n  // adjust and store a copy of the schema definitions\n  self._schema = mergeSchemas(schemas);\n\n  // store the list of defined keys for speedier checking\n  self._schemaKeys = [];\n\n  // store autoValue functions by key\n  self._autoValues = {};\n\n  // store the list of blackbox keys for passing to MongoObject constructor\n  self._blackboxKeys = [];\n\n  // a place to store custom validators for this instance\n  self._validators = [];\n\n  // a place to store custom error messages for this schema\n  self._messages = {};\n\n  self._depsMessages = new Deps.Dependency();\n  self._depsLabels = {};\n\n  _.each(self._schema, function(definition, fieldName) {\n    // Validate the field definition\n    if (!Match.test(definition, schemaDefinition)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field.');\n    }\n\n    fieldNameRoot = fieldName.split(\".\")[0];\n\n    self._schemaKeys.push(fieldName);\n\n    // We support defaultValue shortcut by converting it immediately into an\n    // autoValue.\n    if ('defaultValue' in definition) {\n      if ('autoValue' in definition) {\n        console.warn('SimpleSchema: Found both autoValue and defaultValue options for \"' + fieldName + '\". Ignoring defaultValue.');\n      } else {\n        if (fieldName.slice(-2) === \".$\") {\n          throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n        }\n        self._autoValues[fieldName] = (function defineAutoValue(v) {\n          return function() {\n            if (this.operator === null && !this.isSet) {\n              return v;\n            }\n          };\n        })(definition.defaultValue);\n      }\n    }\n\n    if ('autoValue' in definition) {\n      if (fieldName.slice(-2) === \".$\") {\n        throw new Error('An array item field (one that ends with \".$\") cannot have autoValue.');\n      }\n      self._autoValues[fieldName] = definition.autoValue;\n    }\n\n    self._depsLabels[fieldName] = new Deps.Dependency();\n\n    if (definition.blackbox === true) {\n      self._blackboxKeys.push(fieldName);\n    }\n\n    if (!_.contains(firstLevelSchemaKeys, fieldNameRoot)) {\n      firstLevelSchemaKeys.push(fieldNameRoot);\n    }\n  });\n\n\n  // Cache these lists\n  self._firstLevelSchemaKeys = firstLevelSchemaKeys;\n  self._objectKeys = getObjectKeys(self._schema, self._schemaKeys);\n\n  // We will store named validation contexts here\n  self._validationContexts = {};\n};\n\n// This allows other packages or users to extend the schema\n// definition options that are supported.\nSimpleSchema.extendOptions = function(options) {\n  _.extend(schemaDefinition, options);\n};\n\n// this domain regex matches all domains that have at least one .\n// sadly IPv4 Adresses will be caught too but technically those are valid domains\n// this expression is extracted from the original RFC 5322 mail expression\n// a modification enforces that the tld consists only of characters\nvar RX_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z](?:[a-z-]*[a-z])?';\n// this domain regex matches everythign that could be a domain in intranet\n// that means \"localhost\" is a valid domain\nvar RX_NAME_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\\\.|$))+';\n// strict IPv4 expression which allows 0-255 per oktett\nvar RX_IPv4 = '(?:(?:[0-1]?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])(?:\\\\.|$)){4}';\n// strict IPv6 expression which allows (and validates) all shortcuts\nvar RX_IPv6 = '(?:(?:[\\\\dA-Fa-f]{1,4}(?::|$)){8}' // full adress\n  + '|(?=(?:[^:\\\\s]|:[^:\\\\s])*::(?:[^:\\\\s]|:[^:\\\\s])*$)' // or min/max one '::'\n  + '[\\\\dA-Fa-f]{0,4}(?:::?(?:[\\\\dA-Fa-f]{1,4}|$)){1,6})'; // and short adress\n// this allows domains (also localhost etc) and ip adresses\nvar RX_WEAK_DOMAIN = '(?:' + [RX_NAME_DOMAIN,RX_IPv4,RX_IPv6].join('|') + ')';\n\nSimpleSchema.RegEx = {\n  // We use the RegExp suggested by W3C in http://www.w3.org/TR/html5/forms.html#valid-e-mail-address\n  // This is probably the same logic used by most browsers when type=email, which is our goal. It is\n  // a very permissive expression. Some apps may wish to be more strict and can write their own RegExp.\n  Email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n\n  Domain: new RegExp('^' + RX_DOMAIN + '$'),\n  WeakDomain: new RegExp('^' + RX_WEAK_DOMAIN + '$'),\n\n  IP: new RegExp('^(?:' + RX_IPv4 + '|' + RX_IPv6 + ')$'),\n  IPv4: new RegExp('^' + RX_IPv4 + '$'),\n  IPv6: new RegExp('^' + RX_IPv6 + '$'),\n  // URL RegEx from https://gist.github.com/dperini/729294\n  // http://mathiasbynens.be/demo/url-regex\n  Url: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i,\n  // unique id from the random package also used by minimongo\n  // character list: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L88\n  // string length: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L143\n  Id: /^[23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz]{17}$/,\n  // allows for a 5 digit zip code followed by a whitespace or dash and then 4 more digits\n  // matches 11111 and 11111-1111 and 11111 1111\n  ZipCode: /^\\d{5}(?:[-\\s]\\d{4})?$/,\n  // taken from google's libphonenumber library\n  // https://github.com/googlei18n/libphonenumber/blob/master/javascript/i18n/phonenumbers/phonenumberutil.js\n  // reference the VALID_PHONE_NUMBER_PATTERN key\n  // allows for common phone number symbols including + () and -\n  Phone: /^[0-9０-９٠-٩۰-۹]{2}$|^[+＋]*(?:[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～*]*[0-9０-９٠-٩۰-۹]){3,}[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～0-9０-９٠-٩۰-۹]*(?:;ext=([0-9０-９٠-٩۰-۹]{1,7})|[  \\t,]*(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|[,xｘ#＃~～]|int|anexo|ｉｎｔ)[:\\.．]?[  \\t,-]*([0-9０-９٠-٩۰-۹]{1,7})#?|[- ]+([0-9０-９٠-٩۰-۹]{1,5})#)?$/i\n};\n\nSimpleSchema._makeGeneric = function(name) {\n  if (typeof name !== \"string\") {\n    return null;\n  }\n\n  return name.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n};\n\nSimpleSchema._depsGlobalMessages = new Deps.Dependency();\n\n// Inherit from Match.Where\n// This allow SimpleSchema instance to be recognized as a Match.Where instance as well\n// as a SimpleSchema instance\nSimpleSchema.prototype = new Match.Where();\n\n// If an object is an instance of Match.Where, Meteor built-in check API will look at\n// the function named `condition` and will pass it the document to validate\nSimpleSchema.prototype.condition = function(obj) {\n  var self = this;\n\n  //determine whether obj is a modifier\n  var isModifier, isNotModifier;\n  _.each(obj, function(val, key) {\n    if (key.substring(0, 1) === \"$\") {\n      isModifier = true;\n    } else {\n      isNotModifier = true;\n    }\n  });\n\n  if (isModifier && isNotModifier) {\n    throw new Match.Error(\"Object cannot contain modifier operators alongside other keys\");\n  }\n\n  var ctx = self.newContext();\n  if (!ctx.validate(obj, {modifier: isModifier, filter: false, autoConvert: false})) {\n    var error = ctx.getErrorObject();\n    var matchError = new Match.Error(error.message);\n    matchError.invalidKeys = error.invalidKeys;\n    if (Meteor.isServer) {\n      matchError.sanitizedError = error.sanitizedError;\n    }\n    throw matchError;\n  }\n\n  return true;\n};\n\nfunction logInvalidKeysForContext(context, name) {\n  Meteor.startup(function() {\n    Deps.autorun(function() {\n      if (!context.isValid()) {\n        console.log('SimpleSchema invalid keys for \"' + name + '\" context:', context.invalidKeys());\n      }\n    });\n  });\n}\n\nSimpleSchema.prototype.namedContext = function(name) {\n  var self = this;\n  if (typeof name !== \"string\") {\n    name = \"default\";\n  }\n  if (!self._validationContexts[name]) {\n    self._validationContexts[name] = new SimpleSchemaValidationContext(self);\n\n    // In debug mode, log all invalid key errors to the browser console\n    if (SimpleSchema.debug && Meteor.isClient) {\n      Deps.nonreactive(function() {\n        logInvalidKeysForContext(self._validationContexts[name], name);\n      });\n    }\n  }\n  return self._validationContexts[name];\n};\n\n// Global custom validators\nSimpleSchema._validators = [];\nSimpleSchema.addValidator = function(func) {\n  SimpleSchema._validators.push(func);\n};\n\n// Instance custom validators\nSimpleSchema.prototype.addValidator = function(func) {\n  this._validators.push(func);\n};\n\n/**\n * @method SimpleSchema.prototype.pick\n * @param {[fields]} The list of fields to pick to instantiate the subschema\n * @returns {SimpleSchema} The subschema\n */\nSimpleSchema.prototype.pick = function(/* arguments */) {\n  var self = this;\n  var args = _.toArray(arguments);\n  args.unshift(self._schema);\n\n  var newSchema = _.pick.apply(null, args);\n  return new SimpleSchema(newSchema);\n};\n\nSimpleSchema.prototype.omit = function() {\n  var self = this;\n  var args = _.toArray(arguments);\n  args.unshift(self._schema);\n\n  var newSchema = _.omit.apply(null, args);\n  return new SimpleSchema(newSchema);\n};\n\n\n/**\n * @method SimpleSchema.prototype.clean\n * @param {Object} doc - Document or modifier to clean. Referenced object will be modified in place.\n * @param {Object} [options]\n * @param {Boolean} [options.filter=true] - Do filtering?\n * @param {Boolean} [options.autoConvert=true] - Do automatic type converting?\n * @param {Boolean} [options.removeEmptyStrings=true] - Remove keys in normal object or $set where the value is an empty string?\n * @param {Boolean} [options.trimStrings=true] - Trim string values?\n * @param {Boolean} [options.getAutoValues=true] - Inject automatic and default values?\n * @param {Boolean} [options.isModifier=false] - Is doc a modifier object?\n * @param {Object} [options.extendAutoValueContext] - This object will be added to the `this` context of autoValue functions.\n * @returns {Object} The modified doc.\n *\n * Cleans a document or modifier object. By default, will filter, automatically\n * type convert where possible, and inject automatic/default values. Use the options\n * to skip one or more of these.\n */\nSimpleSchema.prototype.clean = function(doc, options) {\n  var self = this;\n\n  // By default, doc will be filtered and autoconverted\n  options = _.extend({\n    filter: true,\n    autoConvert: true,\n    removeEmptyStrings: true,\n    trimStrings: true,\n    getAutoValues: true,\n    isModifier: false,\n    extendAutoValueContext: {}\n  }, options || {});\n\n  // Convert $pushAll (deprecated) to $push with $each\n  if (\"$pushAll\" in doc) {\n    console.warn(\"SimpleSchema.clean: $pushAll is deprecated; converting to $push with $each\");\n    doc.$push = doc.$push || {};\n    for (var field in doc.$pushAll) {\n      doc.$push[field] = doc.$push[field] || {};\n      doc.$push[field].$each = doc.$push[field].$each || [];\n      for (var i = 0, ln = doc.$pushAll[field].length; i < ln; i++) {\n        doc.$push[field].$each.push(doc.$pushAll[field][i]);\n      }\n      delete doc.$pushAll;\n    }\n  }\n\n  var mDoc = new MongoObject(doc, self._blackboxKeys);\n\n  // Clean loop\n  if (options.filter || options.autoConvert || options.removeEmptyStrings || options.trimStrings) {\n    mDoc.forEachNode(function() {\n      var gKey = this.genericKey, p, def, val;\n      if (gKey) {\n        def = self._schema[gKey];\n        val = this.value;\n        // Filter out props if necessary; any property is OK for $unset because we want to\n        // allow conversions to remove props that have been removed from the schema.\n        if (options.filter && this.operator !== \"$unset\" && !self.allowsKey(gKey)) {\n          // XXX Special handling for $each; maybe this could be made nicer\n          if (this.position.slice(-7) === \"[$each]\") {\n            mDoc.removeValueForPosition(this.position.slice(0, -7));\n          } else {\n            this.remove();\n          }\n          if (SimpleSchema.debug) {\n            console.info('SimpleSchema.clean: filtered out value that would have affected key \"' + gKey + '\", which is not allowed by the schema');\n          }\n          return; // no reason to do more\n        }\n        if (val !== void 0) {\n          // Autoconvert values if requested and if possible\n          var wasAutoConverted = false;\n          if (options.autoConvert && this.operator !== \"$unset\" && def) {\n            var newVal = typeconvert(val, def.type);\n            // trim strings\n            if (options.trimStrings && typeof newVal === \"string\") {\n              newVal = newVal.trim();\n            }\n            if (newVal !== void 0 && newVal !== val) {\n              // remove empty strings\n              if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof newVal === \"string\" && !newVal.length) {\n                // For a document, we remove any fields that are being set to an empty string\n                newVal = void 0;\n                // For a modifier, we $unset any fields that are being set to an empty string\n                if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {\n\n                  p = this.position.replace(\"$set\", \"$unset\");\n                  mDoc.setValueForPosition(p, \"\");\n                }\n              }\n\n              // Change value; if undefined, will remove it\n              SimpleSchema.debug && console.info('SimpleSchema.clean: autoconverted value ' + val + ' from ' + typeof val + ' to ' + typeof newVal + ' for ' + gKey);\n              this.updateValue(newVal);\n              wasAutoConverted = true;\n            }\n          }\n          if (!wasAutoConverted) {\n            // trim strings\n            if (options.trimStrings && typeof val === \"string\" && (!def || (def && def.trim !== false))) {\n              this.updateValue(val.trim());\n            }\n            // remove empty strings\n            if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof val === \"string\" && !val.length) {\n              // For a document, we remove any fields that are being set to an empty string\n              this.remove();\n              // For a modifier, we $unset any fields that are being set to an empty string. But only if we're not already within an entire object that is being set.\n              if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {\n                p = this.position.replace(\"$set\", \"$unset\");\n                mDoc.setValueForPosition(p, \"\");\n              }\n            }\n          }\n        }\n      }\n    }, {endPointsOnly: false});\n  }\n\n  // Set automatic values\n  options.getAutoValues && getAutoValues.call(self, mDoc, options.isModifier, options.extendAutoValueContext);\n\n  // Ensure we don't have any operators set to an empty object\n  // since MongoDB 2.6+ will throw errors.\n  if (options.isModifier) {\n    for (var op in doc) {\n      if (doc.hasOwnProperty(op) && _.isEmpty(doc[op])) {\n        delete doc[op];\n      }\n    }\n  }\n\n  return doc;\n};\n\n// Returns the entire schema object or just the definition for one key\n// in the schema.\nSimpleSchema.prototype.schema = function(key) {\n  var self = this;\n  // if not null or undefined (more specific)\n  if (key !== null && key !== void 0) {\n    return self._schema[SimpleSchema._makeGeneric(key)];\n  } else {\n    return self._schema;\n  }\n};\n\n// Returns the evaluated definition for one key in the schema\n// key = non-generic key\n// [propList] = props to include in the result, for performance\n// [functionContext] = used for evaluating schema options that are functions\nSimpleSchema.prototype.getDefinition = function(key, propList, functionContext) {\n  var self = this;\n  var defs = self.schema(key);\n  if (!defs) {\n    return;\n  }\n\n  if (_.isArray(propList)) {\n    defs = _.pick(defs, propList);\n  } else {\n    defs = _.clone(defs);\n  }\n\n  // For any options that support specifying a function,\n  // evaluate the functions.\n  _.each(['min', 'max', 'minCount', 'maxCount', 'allowedValues', 'optional', 'label'], function (prop) {\n    if (_.isFunction(defs[prop])) {\n      defs[prop] = defs[prop].call(functionContext || {});\n    }\n  });\n\n  // Inflect label if not defined\n  defs.label = defs.label || inflectedLabel(key);\n\n  return defs;\n};\n\n// Check if the key is a nested dot-syntax key inside of a blackbox object\nSimpleSchema.prototype.keyIsInBlackBox = function(key) {\n  var self = this;\n  var parentPath = SimpleSchema._makeGeneric(key), lastDot, def;\n\n  // Iterate the dot-syntax hierarchy until we find a key in our schema\n  do {\n    lastDot = parentPath.lastIndexOf('.');\n    if (lastDot !== -1) {\n      parentPath = parentPath.slice(0, lastDot); // Remove last path component\n      def = self.getDefinition(parentPath);\n    }\n  } while (lastDot !== -1 && !def);\n\n  return !!(def && def.blackbox);\n};\n\n// Use to dynamically change the schema labels.\nSimpleSchema.prototype.labels = function(labels) {\n  var self = this;\n  _.each(labels, function(label, fieldName) {\n    if (!_.isString(label) && !_.isFunction(label)) {\n      return;\n    }\n\n    if (!(fieldName in self._schema)) {\n      return;\n    }\n\n    self._schema[fieldName].label = label;\n    self._depsLabels[fieldName] && self._depsLabels[fieldName].changed();\n  });\n};\n\n// should be used to safely get a label as string\nSimpleSchema.prototype.label = function(key) {\n  var self = this;\n\n  // Get all labels\n  if (key === null || key === void 0) {\n    var result = {};\n    _.each(self.schema(), function(def, fieldName) {\n      result[fieldName] = self.label(fieldName);\n    });\n    return result;\n  }\n\n  // Get label for one field\n  var def = self.getDefinition(key);\n  if (def) {\n    var genericKey = SimpleSchema._makeGeneric(key);\n    self._depsLabels[genericKey] && self._depsLabels[genericKey].depend();\n    return def.label;\n  }\n\n  return null;\n};\n\n// Global messages\n\nSimpleSchema._globalMessages = {\n  required: \"[label] is required\",\n  minString: \"[label] must be at least [min] characters\",\n  maxString: \"[label] cannot exceed [max] characters\",\n  minNumber: \"[label] must be at least [min]\",\n  maxNumber: \"[label] cannot exceed [max]\",\n  minNumberExclusive: \"[label] must be greater than [min]\",\n  maxNumberExclusive: \"[label] must be less than [max]\",\n  minDate: \"[label] must be on or after [min]\",\n  maxDate: \"[label] cannot be after [max]\",\n  badDate: \"[label] is not a valid date\",\n  minCount: \"You must specify at least [minCount] values\",\n  maxCount: \"You cannot specify more than [maxCount] values\",\n  noDecimal: \"[label] must be an integer\",\n  notAllowed: \"[value] is not an allowed value\",\n  expectedString: \"[label] must be a string\",\n  expectedNumber: \"[label] must be a number\",\n  expectedBoolean: \"[label] must be a boolean\",\n  expectedArray: \"[label] must be an array\",\n  expectedObject: \"[label] must be an object\",\n  expectedConstructor: \"[label] must be a [type]\",\n  regEx: [\n    {msg: \"[label] failed regular expression validation\"},\n    {exp: SimpleSchema.RegEx.Email, msg: \"[label] must be a valid e-mail address\"},\n    {exp: SimpleSchema.RegEx.WeakEmail, msg: \"[label] must be a valid e-mail address\"},\n    {exp: SimpleSchema.RegEx.Domain, msg: \"[label] must be a valid domain\"},\n    {exp: SimpleSchema.RegEx.WeakDomain, msg: \"[label] must be a valid domain\"},\n    {exp: SimpleSchema.RegEx.IP, msg: \"[label] must be a valid IPv4 or IPv6 address\"},\n    {exp: SimpleSchema.RegEx.IPv4, msg: \"[label] must be a valid IPv4 address\"},\n    {exp: SimpleSchema.RegEx.IPv6, msg: \"[label] must be a valid IPv6 address\"},\n    {exp: SimpleSchema.RegEx.Url, msg: \"[label] must be a valid URL\"},\n    {exp: SimpleSchema.RegEx.Id, msg: \"[label] must be a valid alphanumeric ID\"}\n  ],\n  keyNotInSchema: \"[key] is not allowed by the schema\"\n};\n\nSimpleSchema.messages = function(messages) {\n  _.extend(SimpleSchema._globalMessages, messages);\n  SimpleSchema._depsGlobalMessages.changed();\n};\n\n// Schema-specific messages\n\nSimpleSchema.prototype.messages = function(messages) {\n  var self = this;\n  _.extend(self._messages, messages);\n  self._depsMessages.changed();\n};\n\n// Returns a string message for the given error type and key. Uses the\n// def and value arguments to fill in placeholders in the error messages.\nSimpleSchema.prototype.messageForError = function(type, key, def, value) {\n  var self = this;\n\n  // We proceed even if we can't get a definition because it might be a keyNotInSchema error\n  def = def || self.getDefinition(key, ['regEx', 'label', 'minCount', 'maxCount', 'min', 'max', 'type']) || {};\n\n  // Adjust for complex types, currently only regEx,\n  // where we might have regEx.1 meaning the second\n  // expression in the array.\n  var firstTypePeriod = type.indexOf(\".\"), index = null;\n  if (firstTypePeriod !== -1) {\n    index = type.substring(firstTypePeriod + 1);\n    index = parseInt(index, 10);\n    type = type.substring(0, firstTypePeriod);\n  }\n\n  // Which regExp is it?\n  var regExpMatch;\n  if (type === \"regEx\") {\n    if (index !== null && index !== void 0 && !isNaN(index)) {\n      regExpMatch = def.regEx[index];\n    } else {\n      regExpMatch = def.regEx;\n    }\n    if (regExpMatch) {\n      regExpMatch = regExpMatch.toString();\n    }\n  }\n\n  // Prep some strings to be used when finding the correct message for this error\n  var typePlusKey = type + \" \" + key;\n  var genericKey = SimpleSchema._makeGeneric(key);\n  var typePlusGenKey = type + \" \" + genericKey;\n\n  // reactively update when message templates are changed\n  SimpleSchema._depsGlobalMessages.depend();\n  self._depsMessages.depend();\n\n  // Prep a function that finds the correct message for regEx errors\n  function findRegExError(message) {\n    if (type !== \"regEx\" || !_.isArray(message)) {\n      return message;\n    }\n    // Parse regEx messages, which are provided in a special object array format\n    // [{exp: RegExp, msg: \"Foo\"}]\n    // Where `exp` is optional\n\n    var msgObj;\n    // First see if there's one where exp matches this expression\n    if (regExpMatch) {\n      msgObj = _.find(message, function (o) {\n        return o.exp && o.exp.toString() === regExpMatch;\n      });\n    }\n\n    // If not, see if there's a default message defined\n    if (!msgObj) {\n      msgObj = _.findWhere(message, {exp: null});\n      if (!msgObj) {\n        msgObj = _.findWhere(message, {exp: void 0});\n      }\n    }\n\n    return msgObj ? msgObj.msg : null;\n  }\n\n  // Try finding the correct message to use at various levels, from most\n  // specific to least specific.\n  var message = self._messages[typePlusKey] ||                  // (1) Use schema-specific message for specific key\n                self._messages[typePlusGenKey] ||               // (2) Use schema-specific message for generic key\n                self._messages[type];                           // (3) Use schema-specific message for type\n  message = findRegExError(message);\n\n  if (!message) {\n    message = SimpleSchema._globalMessages[typePlusKey] ||      // (4) Use global message for specific key\n              SimpleSchema._globalMessages[typePlusGenKey] ||   // (5) Use global message for generic key\n              SimpleSchema._globalMessages[type];               // (6) Use global message for type\n    message = findRegExError(message);\n  }\n\n  if (!message) {\n    return \"Unknown validation error\";\n  }\n\n  // Now replace all placeholders in the message with the correct values\n\n  // [key]\n  message = message.replace(\"[key]\", key);\n\n  // [label]\n  // The call to self.label() establishes a reactive dependency, too\n  message = message.replace(\"[label]\", self.label(key));\n\n  // [minCount]\n  if (typeof def.minCount !== \"undefined\") {\n    message = message.replace(\"[minCount]\", def.minCount);\n  }\n\n  // [maxCount]\n  if (typeof def.maxCount !== \"undefined\") {\n    message = message.replace(\"[maxCount]\", def.maxCount);\n  }\n\n  // [value]\n  if (value !== void 0 && value !== null) {\n    message = message.replace(\"[value]\", value.toString());\n  } else {\n    message = message.replace(\"[value]\", 'null');\n  }\n\n  // [min] and [max]\n  var min = def.min;\n  var max = def.max;\n  if (def.type === Date || def.type === [Date]) {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", Utility.dateToDateString(min));\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", Utility.dateToDateString(max));\n    }\n  } else {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", min);\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", max);\n    }\n  }\n\n  // [type]\n  if (def.type instanceof Function) {\n    message = message.replace(\"[type]\", def.type.name);\n  }\n\n  // Now return the message\n  return message;\n};\n\n// Returns true if key is explicitly allowed by the schema or implied\n// by other explicitly allowed keys.\n// The key string should have $ in place of any numeric array positions.\nSimpleSchema.prototype.allowsKey = function(key) {\n  var self = this;\n\n  // Loop through all keys in the schema\n  return _.any(self._schemaKeys, function(schemaKey) {\n\n    // If the schema key is the test key, it's allowed.\n    if (schemaKey === key) {\n      return true;\n    }\n\n    // Black box handling\n    if (self.schema(schemaKey).blackbox === true) {\n      var kl = schemaKey.length;\n      var compare1 = key.slice(0, kl + 2);\n      var compare2 = compare1.slice(0, -1);\n\n      // If the test key is the black box key + \".$\", then the test\n      // key is NOT allowed because black box keys are by definition\n      // only for objects, and not for arrays.\n      if (compare1 === schemaKey + '.$') {\n        return false;\n      }\n\n      // Otherwise\n      if (compare2 === schemaKey + '.') {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\nSimpleSchema.prototype.newContext = function() {\n  return new SimpleSchemaValidationContext(this);\n};\n\n// Returns all the child keys for the object identified by the generic prefix,\n// or all the top level keys if no prefix is supplied.\nSimpleSchema.prototype.objectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelSchemaKeys;\n  }\n  return self._objectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.validate = function (obj, options) {\n  if (Package.check && Package['audit-argument-checks']) {\n    // Call check but ignore the error to silence audit-argument-checks\n    try { check(obj); } catch (e) { /* ignore error */ }\n  }\n\n  var validationContext = this.newContext();\n  var isValid = validationContext.validate(obj, options);\n\n  if (isValid) return;\n\n  var errors = validationContext.invalidKeys().map(function (error) {\n    return {\n      name: error.name,\n      type: error.type,\n      details: {\n        value: error.value\n      }\n    };\n  });\n\n  // In order for the message at the top of the stack trace to be useful,\n  // we set it to the first validation error message.\n  var message = validationContext.keyErrorMessage(errors[0].name);\n\n  throw new Package['mdg:validation-error'].ValidationError(errors, message);\n};\n\nSimpleSchema.prototype.validator = function (options) {\n  var self = this;\n  options = options || {};\n  return function (obj) {\n    if (options.clean === true) self.clean(obj, options);\n    self.validate(obj);\n  };\n};\n","/* global Utility */\n/* global _ */\n/* global SimpleSchema */\n/* global MongoObject */\n/* global doValidation1:true */\n\nfunction doTypeChecks(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (def.max !== null && def.max < keyValue.length) {\n      return \"maxString\";\n    } else if (def.min !== null && def.min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError) {\n        return regExError;\n      }\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!Utility.isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (isNaN(keyValue.getTime())) {\n        return \"badDate\";\n      }\n\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n}\n\ndoValidation1 = function doValidation1(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n\n  if (!isModifier && Utility.looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  var invalidKeys = [];\n  var mDoc; // for caching the MongoObject if necessary\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, isInArrayItemObject, isInSubObject) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If the operator is $unset or $rename, it's invalid.\n    // * If the value is null, it's invalid.\n    // * If the value is undefined and one of the following are true, it's invalid:\n    //     * We're validating a key of a sub-object.\n    //     * We're validating a key of an object that is an array item.\n    //     * We're validating a document (as opposed to a modifier).\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.\n    if (!skipRequiredCheck && !def.optional) {\n      if (\n        val === null ||\n        op === \"$unset\" ||\n        op === \"$rename\" ||\n        (val === void 0 && (isInArrayItemObject || isInSubObject || !op || op === \"$set\"))\n        ) {\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // For $rename, make sure that the new name is allowed by the schema\n    if (op === \"$rename\" && typeof val === \"string\" && !ss.allowsKey(val)) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", val, null, null, ss));\n      return;\n    }\n\n    // Value checks are not necessary for null or undefined values\n    // or for $unset or $rename values\n    if (op !== \"$unset\" && op !== \"$rename\" && Utility.isNotNullOrUndefined(val)) {\n\n      // Check that value is of the correct type\n      var typeError = doTypeChecks(def, val, op);\n      if (typeError) {\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));\n        return;\n      }\n\n      // Check value against allowedValues array\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // Perform custom validation\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var validators = def.custom ? [def.custom] : [];\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);\n    _.every(validators, function(validator) {\n      var errorType = validator.call(_.extend({\n        key: affectedKey,\n        genericKey: affectedKeyGeneric,\n        definition: def,\n        isSet: (val !== void 0),\n        value: val,\n        operator: op,\n        field: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        },\n        siblingField: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        }\n      }, extendedCustomContext || {}));\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, operator, setKeys, isInArrayItemObject, isInSubObject) {\n    var affectedKeyGeneric, def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (ss.keyIsInBlackBox(affectedKey)) {\n        return;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);\n      def = ss.getDefinition(affectedKey);\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        // We can skip the required check for keys that are ancestors\n        // of those in $set or $setOnInsert because they will be created\n        // by MongoDB while setting.\n        var skipRequiredCheck = _.some(setKeys, function(sk) {\n          return (sk.slice(0, affectedKey.length + 1) === affectedKey + \".\");\n        });\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, skipRequiredCheck, isInArrayItemObject, isInSubObject);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i, operator, setKeys);\n      });\n    }\n\n    // Loop through object keys\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {\n\n      // Get list of present keys\n      var presentKeys = _.keys(val);\n\n      // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n      var keysToCheck = _.union(presentKeys, ss.objectKeys(affectedKeyGeneric));\n\n      // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n      isInArrayItemObject = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");\n\n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), operator, setKeys, isInArrayItemObject, true);\n      });\n    }\n\n  }\n\n  function checkModifier(mod) {\n    // Check for empty modifier\n    if (_.isEmpty(mod)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    }\n\n    // Get a list of all keys in $set and $setOnInsert combined, for use later\n    var setKeys = _.keys(mod.$set || {}).concat(_.keys(mod.$setOnInsert || {}));\n\n    // If this is an upsert, add all the $setOnInsert keys to $set;\n    // since we don't know whether it will be an insert or update, we'll\n    // validate upserts as if they will be an insert.\n    if (\"$setOnInsert\" in mod) {\n      if (isUpsert) {\n        mod.$set = mod.$set || {};\n        mod.$set = _.extend(mod.$set, mod.$setOnInsert);\n      }\n      delete mod.$setOnInsert;\n    }\n\n    // Loop through operators\n    _.each(mod, function (opObj, op) {\n      // If non-operators are mixed in, throw error\n      if (op.slice(0, 1) !== \"$\") {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators. Did you forget `$set`?\");\n      }\n      if (Utility.shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we add null keys to the modifier to force any \"required\" checks to fail\n        if (isUpsert && op === \"$set\") {\n          var presentKeys = _.keys(opObj);\n          _.each(ss.objectKeys(), function (schemaKey) {\n            if (!_.contains(presentKeys, schemaKey)) {\n              checkObj(void 0, schemaKey, op, setKeys);\n            }\n          });\n        }\n        _.each(opObj, function (v, k) {\n          if (op === \"$push\" || op === \"$addToSet\") {\n            if (Utility.isBasicObject(v) && \"$each\" in v) {\n              v = v.$each;\n            } else {\n              k = k + \".0\";\n            }\n          }\n          checkObj(v, k, op, setKeys);\n        });\n      }\n    });\n  }\n\n  // Kick off the validation\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj(obj);\n  }\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n","/* global Utility */\n/* global _ */\n/* global SimpleSchema */\n/* global MongoObject */\n/* global Meteor */\n/* global Random */\n/* global doValidation2:true */\n\nfunction doTypeChecks(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (def.max !== null && def.max < keyValue.length) {\n      return \"maxString\";\n    } else if (def.min !== null && def.min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError) {\n        return regExError;\n      }\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!Utility.isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (isNaN(keyValue.getTime())) {\n        return \"badDate\";\n      }\n\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n}\n\ndoValidation2 = function doValidation2(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n\n  if (isModifier) {\n    if (_.isEmpty(obj)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    } else {\n      var allKeysAreOperators = _.every(obj, function(v, k) {\n        return (k.substring(0, 1) === \"$\");\n      });\n      if (!allKeysAreOperators) {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators\");\n      }\n\n      // We use a LocalCollection to figure out what the resulting doc\n      // would be in a worst case scenario. Then we validate that doc\n      // so that we don't have to validate the modifier object directly.\n      obj = convertModifierToDoc(obj, ss.schema(), isUpsert);\n    }\n  } else if (Utility.looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  var invalidKeys = [];\n  var mDoc; // for caching the MongoObject if necessary\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, strictRequiredCheck) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If the operator is $unset or $rename, it's invalid.\n    // * If the value is null, it's invalid.\n    // * If the value is undefined and one of the following are true, it's invalid:\n    //     * We're validating a key of a sub-object.\n    //     * We're validating a key of an object that is an array item.\n    //     * We're validating a document (as opposed to a modifier).\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.\n    if (!skipRequiredCheck && !def.optional) {\n      if (val === null || val === void 0) {\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // Value checks are not necessary for null or undefined values\n    if (Utility.isNotNullOrUndefined(val)) {\n\n      // Check that value is of the correct type\n      var typeError = doTypeChecks(def, val, op);\n      if (typeError) {\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));\n        return;\n      }\n\n      // Check value against allowedValues array\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // Perform custom validation\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var validators = def.custom ? [def.custom] : [];\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);\n    _.every(validators, function(validator) {\n      var errorType = validator.call(_.extend({\n        key: affectedKey,\n        genericKey: affectedKeyGeneric,\n        definition: def,\n        isSet: (val !== void 0),\n        value: val,\n        operator: op,\n        field: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        },\n        siblingField: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        }\n      }, extendedCustomContext || {}));\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, skipRequiredCheck, strictRequiredCheck) {\n    var affectedKeyGeneric, def;\n\n    if (affectedKey) {\n\n      // When we hit a blackbox key, we don't progress any further\n      if (ss.keyIsInBlackBox(affectedKey)) {\n        return;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);\n      def = ss.getDefinition(affectedKey);\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        validate(val, affectedKey, affectedKeyGeneric, def, null, skipRequiredCheck, strictRequiredCheck);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i);\n      });\n    }\n\n    // Loop through object keys\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {\n\n      // Get list of present keys\n      var presentKeys = _.keys(val);\n\n      // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n      var keysToCheck = _.union(presentKeys, ss._schemaKeys);\n\n      // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n      strictRequiredCheck = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");\n\n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        if (Utility.shouldCheck(key)) {\n          checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), skipRequiredCheck, strictRequiredCheck);\n        }\n      });\n    }\n\n  }\n\n  // Kick off the validation\n  checkObj(obj);\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n\nfunction convertModifierToDoc(mod, schema, isUpsert) {\n  // Create unmanaged LocalCollection as scratchpad\n  var t = new Meteor.Collection(null);\n\n  // LocalCollections are in memory, and it seems\n  // that it's fine to use them synchronously on \n  // either client or server\n  var id;\n  if (isUpsert) {\n    // We assume upserts will be inserts (conservative\n    // validation of requiredness)\n    id = Random.id();\n    t.upsert({_id: id}, mod);\n  } else {\n    var mDoc = new MongoObject(mod);\n    // Create a ficticious existing document\n    var fakeDoc = new MongoObject({});\n    _.each(schema, function (def, fieldName) {\n      var setVal;\n      // Prefill doc with empty arrays to avoid the\n      // mongodb issue where it does not understand\n      // that numeric pieces should create arrays.\n      if (def.type === Array && mDoc.affectsGenericKey(fieldName)) {\n        setVal = [];\n      }\n      // Set dummy values for required fields because\n      // we assume any existing data would be valid.\n      else if (!def.optional) {\n        // TODO correct value type based on schema type\n        if (def.type === Boolean) {\n          setVal = true;\n        } else if (def.type === Number) {\n          setVal = def.min || 0;\n        } else if (def.type === Date) {\n          setVal = def.min || new Date();\n        } else if (def.type === Array) {\n          setVal = [];\n        } else if (def.type === Object) {\n          setVal = {};\n        } else {\n          setVal = \"0\";\n        }\n      }\n\n      if (setVal !== void 0) {\n        var key = fieldName.replace(/\\.\\$/g, \".0\");\n        var pos = MongoObject._keyToPosition(key, false);\n        fakeDoc.setValueForPosition(pos, setVal);\n      }\n    });\n    fakeDoc = fakeDoc.getObject();\n    // Insert fake doc into local scratch collection\n    id = t.insert(fakeDoc);\n    // Now update it with the modifier\n    t.update(id, mod);\n  }\n  \n  var doc = t.findOne(id);\n  // We're done with it\n  t.remove(id);\n  // Currently we don't validate _id unless it is\n  // explicitly added to the schema\n  if (!schema._id) {\n    delete doc._id;\n  }\n  return doc;\n}\n","/* global SimpleSchema */\n/* global SimpleSchemaValidationContext:true */\n/* global doValidation1 */\n/* global doValidation2 */\n\nfunction doValidation(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n  var useOld = true; //for now this can be manually changed to try the experimental method, which doesn't yet work properly\n  var func = useOld ? doValidation1 : doValidation2;\n  return func(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext);\n}\n\n/*\n * PUBLIC API\n */\n\nSimpleSchemaValidationContext = function SimpleSchemaValidationContext(ss) {\n  var self = this;\n  self._simpleSchema = ss;\n  self._schema = ss.schema();\n  self._schemaKeys = _.keys(self._schema);\n  self._invalidKeys = [];\n  //set up validation dependencies\n  self._deps = {};\n  self._depsAny = new Deps.Dependency();\n  _.each(self._schemaKeys, function(name) {\n    self._deps[name] = new Deps.Dependency();\n  });\n};\n\n//validates the object against the simple schema and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validate = function simpleSchemaValidationContextValidate(doc, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, null, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //note any currently invalid keys so that we can mark them as changed\n  //due to new validation (they may be valid now, or invalid in a different way)\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //update\n  self._invalidKeys = invalidKeys;\n\n  //add newly invalid keys to changedKeys\n  var addedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //mark all changed keys as changed\n  var changedKeys = _.union(addedKeys, removedKeys);\n  self._markKeysChanged(changedKeys);\n\n  // Return true if it was valid; otherwise, return false\n  return self._invalidKeys.length === 0;\n};\n\n//validates doc against self._schema for one key and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validateOne = function simpleSchemaValidationContextValidateOne(doc, keyName, options) {\n  var self = this, i, ln, k;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, keyName, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //remove objects from self._invalidKeys where name = keyName\n  var newInvalidKeys = [];\n  for (i = 0, ln = self._invalidKeys.length; i < ln; i++) {\n    k = self._invalidKeys[i];\n    if (k.name !== keyName) {\n      newInvalidKeys.push(k);\n    }\n  }\n  self._invalidKeys = newInvalidKeys;\n\n  //merge invalidKeys into self._invalidKeys\n  for (i = 0, ln = invalidKeys.length; i < ln; i++) {\n    k = invalidKeys[i];\n    self._invalidKeys.push(k);\n  }\n\n  //mark key as changed due to new validation (they may be valid now, or invalid in a different way)\n  self._markKeysChanged([keyName]);\n\n  // Return true if it was valid; otherwise, return false\n  return !self._keyIsInvalid(keyName);\n};\n\n//reset the invalidKeys array\nSimpleSchemaValidationContext.prototype.resetValidation = function simpleSchemaValidationContextResetValidation() {\n  var self = this;\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n  self._invalidKeys = [];\n  self._markKeysChanged(removedKeys);\n};\n\nSimpleSchemaValidationContext.prototype.isValid = function simpleSchemaValidationContextIsValid() {\n  var self = this;\n  self._depsAny.depend();\n  return !self._invalidKeys.length;\n};\n\nSimpleSchemaValidationContext.prototype.invalidKeys = function simpleSchemaValidationContextInvalidKeys() {\n  var self = this;\n  self._depsAny.depend();\n  return self._invalidKeys;\n};\n\nSimpleSchemaValidationContext.prototype.addInvalidKeys = function simpleSchemaValidationContextAddInvalidKeys(errors) {\n  var self = this;\n\n  if (!errors || !errors.length) {\n    return;\n  }\n\n  var changedKeys = [];\n  _.each(errors, function (errorObject) {\n    changedKeys.push(errorObject.name);\n    self._invalidKeys.push(errorObject);\n  });\n\n  self._markKeysChanged(changedKeys);\n};\n\nSimpleSchemaValidationContext.prototype._markKeysChanged = function simpleSchemaValidationContextMarkKeysChanged(keys) {\n  var self = this;\n\n  if (!keys || !keys.length) {\n    return;\n  }\n\n  _.each(keys, function(name) {\n    var genericName = SimpleSchema._makeGeneric(name);\n    if (genericName in self._deps) {\n      self._deps[genericName].changed();\n    }\n  });\n  self._depsAny.changed();\n};\n\nSimpleSchemaValidationContext.prototype._getInvalidKeyObject = function simpleSchemaValidationContextGetInvalidKeyObject(name, genericName) {\n  var self = this;\n  genericName = genericName || SimpleSchema._makeGeneric(name);\n\n  var errorObj = _.findWhere(self._invalidKeys, {name: name});\n  if (!errorObj) {\n    errorObj = _.findWhere(self._invalidKeys, {name: genericName});\n  }\n  return errorObj;\n};\n\nSimpleSchemaValidationContext.prototype._keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name, genericName) {\n  return !!this._getInvalidKeyObject(name, genericName);\n};\n\n// Like the internal one, but with deps\nSimpleSchemaValidationContext.prototype.keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  self._deps[genericName] && self._deps[genericName].depend();\n\n  return self._keyIsInvalid(name, genericName);\n};\n\nSimpleSchemaValidationContext.prototype.keyErrorMessage = function simpleSchemaValidationContextKeyErrorMessage(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  self._deps[genericName] && self._deps[genericName].depend();\n  \n  var errorObj = self._getInvalidKeyObject(name, genericName);\n  if (!errorObj) {\n    return \"\";\n  }\n  \n  return self._simpleSchema.messageForError(errorObj.type, errorObj.name, null, errorObj.value);\n};\n\nSimpleSchemaValidationContext.prototype.getErrorObject = function simpleSchemaValidationContextGetErrorObject() {\n  var self = this, message, invalidKeys = this._invalidKeys;\n  if (invalidKeys.length) {\n    message = self.keyErrorMessage(invalidKeys[0].name);\n    // We add `message` prop to the invalidKeys.\n    invalidKeys = _.map(invalidKeys, function (o) {\n      return _.extend({message: self.keyErrorMessage(o.name)}, o);\n    });\n  } else {\n    message = \"Failed validation\";\n  }\n  var error = new Error(message);\n  error.invalidKeys = invalidKeys;\n  // If on the server, we add a sanitized error, too, in case we're\n  // called from a method.\n  if (Meteor.isServer) {\n    error.sanitizedError = new Meteor.Error(400, message);\n  }\n  return error;\n};\n"]}}]