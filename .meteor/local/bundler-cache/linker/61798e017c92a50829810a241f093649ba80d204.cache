[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\nvar EJSON = Package.ejson.EJSON;\nvar Spacebars = Package.spacebars.Spacebars;\nvar BaseComponent = Package['peerlibrary:base-component'].BaseComponent;\nvar BaseComponentDebug = Package['peerlibrary:base-component'].BaseComponentDebug;\nvar assert = Package['peerlibrary:assert'].assert;\nvar ReactiveField = Package['peerlibrary:reactive-field'].ReactiveField;\nvar ComputedField = Package['peerlibrary:computed-field'].ComputedField;\nvar DataLookup = Package['peerlibrary:data-lookup'].DataLookup;\nvar HTML = Package.htmljs.HTML;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar __coffeescriptShare, Template, AttributeHandler, ElementAttributesUpdater, BlazeComponent, BlazeComponentDebug;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/template.coffee.js                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\n                                                                                                                       // 1\n                                                                                                                       //\nTemplate = Blaze.Template;                                                                                             // 1\n                                                                                                                       //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/templating.js                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of templating.js file wrapped into a condition.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__checkName) {\n  // Packages and apps add templates on to this object.\n\n  /**\n   * @summary The class for defining templates\n   * @class\n   * @instanceName Template.myTemplate\n   */\n  Template = Blaze.Template;\n\n  var RESERVED_TEMPLATE_NAMES = \"__proto__ name\".split(\" \");\n\n  // Check for duplicate template names and illegal names that won't work.\n  Template.__checkName = function (name) {\n    // Some names can't be used for Templates. These include:\n    //  - Properties Blaze sets on the Template object.\n    //  - Properties that some browsers don't let the code to set.\n    //    These are specified in RESERVED_TEMPLATE_NAMES.\n    if (name in Template || _.contains(RESERVED_TEMPLATE_NAMES, name)) {\n      if ((Template[name] instanceof Template) && name !== \"body\")\n        throw new Error(\"There are multiple templates named '\" + name + \"'. Each template needs a unique name.\");\n      throw new Error(\"This template name is reserved: \" + name);\n    }\n  };\n\n  // XXX COMPAT WITH 0.8.3\n  Template.__define__ = function (name, renderFunc) {\n    Template.__checkName(name);\n    Template[name] = new Template(\"Template.\" + name, renderFunc);\n    // Exempt packages built pre-0.9.0 from warnings about using old\n    // helper syntax, because we can.  It's not very useful to get a\n    // warning about someone else's code (like a package on Atmosphere),\n    // and this should at least put a bit of a dent in number of warnings\n    // that come from packages that haven't been updated lately.\n    Template[name]._NOWARN_OLDSTYLE_HELPERS = true;\n  };\n\n  // Define a template `Template.body` that renders its\n  // `contentRenderFuncs`.  `<body>` tags (of which there may be\n  // multiple) will have their contents added to it.\n\n  /**\n   * @summary The [template object](#templates_api) representing your `<body>`\n   * tag.\n   * @locus Client\n   */\n  Template.body = new Template('body', function () {\n    var view = this;\n    return _.map(Template.body.contentRenderFuncs, function (func) {\n      return func.apply(view);\n    });\n  });\n  Template.body.contentRenderFuncs = []; // array of Blaze.Views\n  Template.body.view = null;\n\n  Template.body.addContent = function (renderFunc) {\n    Template.body.contentRenderFuncs.push(renderFunc);\n  };\n\n  // This function does not use `this` and so it may be called\n  // as `Meteor.startup(Template.body.renderIntoDocument)`.\n  Template.body.renderToDocument = function () {\n    // Only do it once.\n    if (Template.body.view)\n      return;\n\n    var view = Blaze.render(Template.body, document.body);\n    Template.body.view = view;\n  };\n\n  // XXX COMPAT WITH 0.9.0\n  UI.body = Template.body;\n\n  // XXX COMPAT WITH 0.9.0\n  // (<body> tags in packages built with 0.9.0)\n  Template.__body__ = Template.body;\n  Template.__body__.__contentParts = Template.body.contentViews;\n  Template.__body__.__instantiate = Template.body.renderToDocument;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/template.dynamic.js                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\nTemplate.__checkName(\"__dynamicBackport\");\nTemplate[\"__dynamicBackport\"] = new Template(\"Template.__dynamicBackport\", (function() {\n  var view = this;\n  return [ Blaze.View(\"lookup:checkContext\", function() {\n    return Spacebars.mustache(view.lookup(\"checkContext\"));\n  }), \"\\n  \", Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"dataContextPresent\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n      return Blaze._InOuterTemplateScope(view, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(view.templateContentBlock);\n        });\n      });\n    }), \"\\n  \" ];\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return {\n        template: Spacebars.call(view.lookup(\"template\")),\n        data: Spacebars.call(view.lookup(\"..\"))\n      };\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  }) ];\n}));\n\nTemplate.__checkName(\"__dynamicWithDataContextBackport\");\nTemplate[\"__dynamicWithDataContextBackport\"] = new Template(\"Template.__dynamicWithDataContextBackport\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"chooseTemplate\"), view.lookup(\"template\"));\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"data\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"..\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  });\n}));\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/dynamic.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of dynamic.js file wrapped into a condition with renaming of backported templates.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__dynamicWithDataContext) {\n  Blaze.Template.__dynamicWithDataContext = Blaze.Template.__dynamicWithDataContextBackport;\n  Blaze.Template.__dynamicWithDataContext.viewName = 'Template.__dynamicWithDataContext';\n  Blaze.Template.__dynamic = Blaze.Template.__dynamicBackport;\n  Blaze.Template.__dynamic.viewName = 'Template.__dynamic';\n\n  var Template = Blaze.Template;\n\n  /**\n   * @isTemplate true\n   * @memberOf Template\n   * @function dynamic\n   * @summary Choose a template to include dynamically, by name.\n   * @locus Templates\n   * @param {String} template The name of the template to include.\n   * @param {Object} [data] Optional. The data context in which to include the\n   * template.\n   */\n\n  Template.__dynamicWithDataContext.helpers({\n    chooseTemplate: function (name) {\n      return Blaze._getTemplate(name, function () {\n        return Template.instance();\n      });\n    }\n  });\n\n  Template.__dynamic.helpers({\n    dataContextPresent: function () {\n      return _.has(this, \"data\");\n    },\n    checkContext: function () {\n      if (!_.has(this, \"template\")) {\n        throw new Error(\"Must specify name in the 'template' argument \" +\n          \"to {{> Template.dynamic}}.\");\n      }\n\n      _.each(this, function (v, k) {\n        if (k !== \"template\" && k !== \"data\") {\n          throw new Error(\"Invalid argument to {{> Template.dynamic}}: \" +\n            k);\n        }\n      });\n    }\n  });\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/lookup.js                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* This file backports Blaze lookup.js from Meteor 1.2 so that required Blaze features to support Blaze\n   Components are available also in older Meteor versions.\n   It is a copy of lookup.js file from Meteor 1.2 with lexical scope lookup commented out.\n\n   TODO: Remove this file eventually.\n */\n\n// Check if we are not running Meteor 1.2+.\nif (! Blaze._getTemplate) {\n  // If `x` is a function, binds the value of `this` for that function\n  // to the current data context.\n  var bindDataContext = function (x) {\n    if (typeof x === 'function') {\n      return function () {\n        var data = Blaze.getData();\n        if (data == null)\n          data = {};\n        return x.apply(data, arguments);\n      };\n    }\n    return x;\n  };\n\n  Blaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n    // XXX COMPAT WITH 0.9.3\n    var isKnownOldStyleHelper = false;\n\n    if (template.__helpers.has(name)) {\n      var helper = template.__helpers.get(name);\n      if (helper === Blaze._OLDSTYLE_HELPER) {\n        isKnownOldStyleHelper = true;\n      } else if (helper != null) {\n        return wrapHelper(bindDataContext(helper), tmplInstanceFunc);\n      } else {\n        return null;\n      }\n    }\n\n    // old-style helper\n    if (name in template) {\n      // Only warn once per helper\n      if (!isKnownOldStyleHelper) {\n        template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n        if (!template._NOWARN_OLDSTYLE_HELPERS) {\n          Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n            name + ' = ...` is deprecated.  Use `' + template.viewName +\n            '.helpers(...)` instead.');\n        }\n      }\n      if (template[name] != null) {\n        return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n      }\n    }\n\n    return null;\n  };\n\n  var wrapHelper = function (f, templateFunc) {\n    // XXX COMPAT WITH METEOR 1.0.3.2\n    if (!Blaze.Template._withTemplateInstanceFunc) {\n      return Blaze._wrapCatchingExceptions(f, 'template helper');\n    }\n\n    if (typeof f !== \"function\") {\n      return f;\n    }\n\n    return function () {\n      var self = this;\n      var args = arguments;\n\n      return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n        return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n      });\n    };\n  };\n\n  // templateInstance argument is provided to be available for possible\n  // alternative implementations of this function by 3rd party packages.\n  Blaze._getTemplate = function (name, templateInstance) {\n    if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {\n      return Blaze.Template[name];\n    }\n    return null;\n  };\n\n  Blaze._getGlobalHelper = function (name, templateInstance) {\n    if (Blaze._globalHelpers[name] != null) {\n      return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance);\n    }\n    return null;\n  };\n\n  Blaze.View.prototype.lookup = function (name, _options) {\n    var template = this.template;\n    var lookupTemplate = _options && _options.template;\n    var helper;\n    var binding;\n    var boundTmplInstance;\n    var foundTemplate;\n\n    if (this.templateInstance) {\n      boundTmplInstance = _.bind(this.templateInstance, this);\n    }\n\n    // 0. looking up the parent data context with the special \"../\" syntax\n    if (/^\\./.test(name)) {\n      // starts with a dot. must be a series of dots which maps to an\n      // ancestor of the appropriate height.\n      if (!/^(\\.)+$/.test(name))\n        throw new Error(\"id starting with dot must be a series of dots\");\n\n      return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n    }\n\n    // 1. look up a helper on the current template\n    if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {\n      return helper;\n    }\n\n    // 2. look up a binding by traversing the lexical view hierarchy inside the\n    // current template\n    /*if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n      return binding;\n    }*/\n\n    // 3. look up a template by name\n    if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {\n      return foundTemplate;\n    }\n\n    // 4. look up a global helper\n    if ((helper = Blaze._getGlobalHelper(name, boundTmplInstance)) != null) {\n      return helper;\n    }\n\n    // 5. look up in a data context\n    return function () {\n      var isCalledAsFunction = (arguments.length > 0);\n      var data = Blaze.getData();\n      var x = data && data[name];\n      if (!x) {\n        if (lookupTemplate) {\n          throw new Error(\"No such template: \" + name);\n        } else if (isCalledAsFunction) {\n          throw new Error(\"No such function: \" + name);\n        } /*else if (name.charAt(0) === '@' && ((x === null) ||\n          (x === undefined))) {\n          // Throw an error if the user tries to use a `@directive`\n          // that doesn't exist.  We don't implement all directives\n          // from Handlebars, so there's a potential for confusion\n          // if we fail silently.  On the other hand, we want to\n          // throw late in case some app or package wants to provide\n          // a missing directive.\n          throw new Error(\"Unsupported directive: \" + name);\n        }*/\n      }\n      if (!data) {\n        return null;\n      }\n      if (typeof x !== 'function') {\n        if (isCalledAsFunction) {\n          throw new Error(\"Can't call non-function: \" + x);\n        }\n        return x;\n      }\n      return x.apply(data, arguments);\n    };\n  };\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/attrs.js                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of attrs.js file with the changes from the above pull request merged in.\n\n   TODO: Remove this file eventually.\n */\n\nvar jsUrlsAllowed = false;\nBlaze._allowJavascriptUrls = function () {\n  jsUrlsAllowed = true;\n};\nBlaze._javascriptUrlsAllowed = function () {\n  return jsUrlsAllowed;\n};\n\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\nBlaze._AttributeHandler = AttributeHandler;\n\nAttributeHandler.prototype.update = function (element, oldValue, value) {\n  if (value === null) {\n    if (oldValue !== null)\n      element.removeAttribute(this.name);\n  } else {\n    element.setAttribute(this.name, value);\n  }\n};\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"\n//\n// Each subclass must implement a parseValue method which takes a string\n// as an input and returns a dict of attributes. The keys of the dict\n// are unique identifiers (ie. css properties in the case of styles), and the\n// values are the entire attribute which will be injected into the element.\n//\n// Extended below to support classes, SVG elements and styles.\n\nBlaze._DiffingAttributeHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");\n\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};\n    var newAttrsMap = value ? this.parseValue(value) : {};\n\n    // the current attributes on the element, which we will mutate.\n\n    var attrString = this.getCurrentValue(element);\n    var attrsMap = attrString ? this.parseValue(attrString) : {};\n\n    _.each(_.keys(oldAttrsMap), function (t) {\n      if (! (t in newAttrsMap))\n        delete attrsMap[t];\n    });\n\n    _.each(_.keys(newAttrsMap), function (t) {\n      attrsMap[t] = newAttrsMap[t];\n    });\n\n    this.setValue(element, _.values(attrsMap).join(' '));\n  }\n});\n\nvar ClassHandler = Blaze._DiffingAttributeHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  },\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    _.each(attrString.split(' '), function(token) {\n      if (token)\n        tokens[token] = token;\n    });\n    return tokens;\n  }\n});\n\nvar SVGClassHandler = ClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar StyleHandler = Blaze._DiffingAttributeHandler.extend({\n  getCurrentValue: function (element) {\n    return element.getAttribute('style');\n  },\n  setValue: function (element, style) {\n    if (style === '') {\n      element.removeAttribute('style');\n    } else {\n      element.setAttribute('style', style);\n    }\n  },\n\n  // Parse a string to produce a map from property to attribute string.\n  //\n  // Example:\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    // Regex for parsing a css attribute declaration, taken from css-parse:\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\n    var match = regex.exec(attrString);\n    while (match) {\n      // match[0] = entire matching string\n      // match[1] = css property\n      // Prefix the token to prevent conflicts with existing properties.\n\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to\n      // remove strong dep on jquery.\n      tokens[' ' + match[1]] = match[0].trim ?\n        match[0].trim() : $.trim(match[0]);\n\n      match = regex.exec(attrString);\n    }\n\n    return tokens;\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar DOMPropertyHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value !== element[name])\n      element[name] = value;\n  }\n});\n\n// attributes of the type 'xlink:something' should be set using\n// the correct namespace in order to work\nvar XlinkHandler = AttributeHandler.extend({\n  update: function(element, oldValue, value) {\n    var NS = 'http://www.w3.org/1999/xlink';\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttributeNS(NS, this.name);\n    } else {\n      element.setAttributeNS(NS, this.name, this.value);\n    }\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\nvar isUrlAttribute = function (tagName, attrName) {\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\n  // and\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\n  var urlAttrs = {\n    FORM: ['action'],\n    BODY: ['background'],\n    BLOCKQUOTE: ['cite'],\n    Q: ['cite'],\n    DEL: ['cite'],\n    INS: ['cite'],\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\n    APPLET: ['codebase'],\n    A: ['href'],\n    AREA: ['href'],\n    LINK: ['href'],\n    BASE: ['href'],\n    IMG: ['longdesc', 'src', 'usemap'],\n    FRAME: ['longdesc', 'src'],\n    IFRAME: ['longdesc', 'src'],\n    HEAD: ['profile'],\n    SCRIPT: ['src'],\n    INPUT: ['src', 'usemap', 'formaction'],\n    BUTTON: ['formaction'],\n    BASE: ['href'],\n    MENUITEM: ['icon'],\n    HTML: ['manifest'],\n    VIDEO: ['poster']\n  };\n\n  if (attrName === 'itemid') {\n    return true;\n  }\n\n  var urlAttrNames = urlAttrs[tagName] || [];\n  return _.contains(urlAttrNames, attrName);\n};\n\n// To get the protocol for a URL, we let the browser normalize it for\n// us, by setting it as the href for an anchor tag and then reading out\n// the 'protocol' property.\nif (Meteor.isClient) {\n  var anchorForNormalization = document.createElement('A');\n}\n\nvar getUrlProtocol = function (url) {\n  if (Meteor.isClient) {\n    anchorForNormalization.href = url;\n    return (anchorForNormalization.protocol || \"\").toLowerCase();\n  } else {\n    throw new Error('getUrlProtocol not implemented on the server');\n  }\n};\n\n// UrlHandler is an attribute handler for all HTML attributes that take\n// URL values. It disallows javascript: URLs, unless\n// Blaze._allowJavascriptUrls() has been called. To detect javascript:\n// urls, we set the attribute on a dummy anchor element and then read\n// out the 'protocol' property of the attribute.\nvar origUpdate = AttributeHandler.prototype.update;\nvar UrlHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var self = this;\n    var args = arguments;\n\n    if (Blaze._javascriptUrlsAllowed()) {\n      origUpdate.apply(self, args);\n    } else {\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");\n      if (isJavascriptProtocol) {\n        Blaze._warn(\"URLs that use the 'javascript:' protocol are not \" +\n                    \"allowed in URL attribute values. \" +\n                    \"Call Blaze._allowJavascriptUrls() \" +\n                    \"to enable them.\");\n        origUpdate.apply(self, [element, oldValue, null]);\n      } else {\n        origUpdate.apply(self, args);\n      }\n    }\n  }\n});\n\n// XXX make it possible for users to register attribute handlers!\nBlaze._makeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'style') {\n    return new StyleHandler(name, value);\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\n             (elem.tagName === 'INPUT' && name === 'checked')) {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new DOMPropertyHandler(name, value);\n  } else if (name.substring(0,6) === 'xlink:') {\n    return new XlinkHandler(name.substring(6), value);\n  } else if (isUrlAttribute(elem.tagName, name)) {\n    return new UrlHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n\n\nElementAttributesUpdater = function (elem) {\n  this.elem = elem;\n  this.handlers = {};\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, whose\n// values are strings.\nElementAttributesUpdater.prototype.update = function(newAttrs) {\n  var elem = this.elem;\n  var handlers = this.handlers;\n\n  for (var k in handlers) {\n    if (! _.has(newAttrs, k)) {\n      // remove attributes (and handlers) for attribute names\n      // that don't exist as keys of `newAttrs` and so won't\n      // be visited when traversing it.  (Attributes that\n      // exist in the `newAttrs` object but are `null`\n      // are handled later.)\n      var handler = handlers[k];\n      var oldValue = handler.value;\n      handler.value = null;\n      handler.update(elem, oldValue, null);\n      delete handlers[k];\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if (! _.has(handlers, k)) {\n      if (value !== null) {\n        // make new handler\n        handler = Blaze._makeAttributeHandler(elem, k, value);\n        handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/compatibility/materializer.js                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of the materializer.js file and is needed because it references symbols from attrs.js.\n\n   TODO: Remove this file eventually.\n */\n\n// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,\n                                  _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = (_existingWorkStack || []);\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n\n  if (! _existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n\n  return intoArray;\n};\n\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n\n  switch (typeof htmljs) {\n  case 'string': case 'boolean': case 'number':\n    intoArray.push(document.createTextNode(String(htmljs)));\n    return;\n  case 'object':\n    if (htmljs.htmljsType) {\n      switch (htmljs.htmljsType) {\n      case HTML.Tag.htmljsType:\n        intoArray.push(materializeTag(htmljs, parentView, workStack));\n        return;\n      case HTML.CharRef.htmljsType:\n        intoArray.push(document.createTextNode(htmljs.str));\n        return;\n      case HTML.Comment.htmljsType:\n        intoArray.push(document.createComment(htmljs.sanitizedValue));\n        return;\n      case HTML.Raw.htmljsType:\n        // Get an array of DOM nodes by using the browser's HTML parser\n        // (like innerHTML).\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n        for (var i = 0; i < nodes.length; i++)\n          intoArray.push(nodes[i]);\n        return;\n      }\n    } else if (HTML.isArray(htmljs)) {\n      for (var i = htmljs.length-1; i >= 0; i--) {\n        workStack.push(_.bind(Blaze._materializeDOM, null,\n                              htmljs[i], intoArray, parentView, workStack));\n      }\n      return;\n    } else {\n      if (htmljs instanceof Blaze.Template) {\n        htmljs = htmljs.constructView();\n        // fall through to Blaze.View case below\n      }\n      if (htmljs instanceof Blaze.View) {\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n        return;\n      }\n    }\n  }\n\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\n\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\n      && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length &&\n      ! (rawAttrs && ('value' in rawAttrs))) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' ||\n        HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\n                      \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = _.extend({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],\n                                              parentView,\n                                              HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation =\n        parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange)\n          x.attach(elem);\n        else\n          elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(_.bind(Blaze._materializeDOM, null,\n                          children, childNodesAndRanges, parentView,\n                          workStack));\n  }\n\n  return elem;\n};\n\n\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return (node.tagName === \"a\" &&\n          node.attrs &&\n          node.attrs[\"xlink:href\"] !== undefined);\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/lib.coffee.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar                                                                                                                    //\n    ComponentsNamespaceReference,                                                                                      //\n    HTMLJSExpander,                                                                                                    //\n    REQUIRE_RENDERED_INSTANCE,                                                                                         //\n    SUPPORTS_REACTIVE_INSTANCE,                                                                                        //\n    addEvents,                                                                                                         //\n    argumentsConstructor,                                                                                              //\n    bindComponent,                                                                                                     //\n    bindDataContext,                                                                                                   //\n    callTemplateBaseHooks,                                                                                             //\n    contentAsFunc,                                                                                                     //\n    contentAsView,                                                                                                     //\n    currentViewIfRendering,                                                                                            //\n    expand,                                                                                                            //\n    expandView,                                                                                                        //\n    getTemplateBase,                                                                                                   //\n    getTemplateInstance,                                                                                               //\n    getTemplateInstanceFunction,                                                                                       //\n    method,                                                                                                            //\n    methodName,                                                                                                        //\n    originalDot,                                                                                                       //\n    originalFlattenAttributes,                                                                                         //\n    originalGetTemplate,                                                                                               //\n    originalInclude,                                                                                                   //\n    originalVisitTag,                                                                                                  //\n    ref,                                                                                                               //\n    registerFirstCreatedHook,                                                                                          //\n    registerHooks,                                                                                                     //\n    templateInstanceToComponent,                                                                                       //\n    withTemplateInstanceFunc,                                                                                          //\n    wrapHelper,                                                                                                        //\n    wrapViewAndTemplate,                                                                                               //\n    slice = [].slice,                                                                                                  //\n    extend = function extend(child, parent) {                                                                          //\n  for (var key in meteorBabelHelpers.sanitizeForInObject(parent)) {                                                    //\n    if (hasProp.call(parent, key)) child[key] = parent[key];                                                           //\n  }function ctor() {                                                                                                   //\n    this.constructor = child;                                                                                          //\n  }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;     //\n},                                                                                                                     //\n    hasProp = {}.hasOwnProperty,                                                                                       //\n    indexOf = [].indexOf || function (item) {                                                                          //\n  for (var i = 0, l = this.length; i < l; i++) {                                                                       //\n    if (i in this && this[i] === item) return i;                                                                       //\n  }return -1;                                                                                                          //\n};                                                                                                                     //\n                                                                                                                       //\ngetTemplateInstance = function getTemplateInstance(view, skipBlockHelpers) {                                           //\n  while (view && !view._templateInstance) {                                                                            //\n    if (skipBlockHelpers) {                                                                                            //\n      view = view.parentView;                                                                                          //\n    } else {                                                                                                           //\n      view = view.originalParentView || view.parentView;                                                               //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  return view != null ? view._templateInstance : void 0;                                                               //\n};                                                                                                                     //\n                                                                                                                       //\ntemplateInstanceToComponent = function templateInstanceToComponent(templateInstanceFunc, skipBlockHelpers) {           //\n  var templateInstance;                                                                                                //\n  templateInstance = typeof templateInstanceFunc === \"function\" ? templateInstanceFunc() : void 0;                     //\n  templateInstance = getTemplateInstance(templateInstance != null ? templateInstance.view : void 0, skipBlockHelpers);\n  while (templateInstance) {                                                                                           //\n    if ('component' in templateInstance) {                                                                             //\n      return templateInstance.component;                                                                               //\n    }                                                                                                                  //\n    if (skipBlockHelpers) {                                                                                            //\n      templateInstance = getTemplateInstance(templateInstance.view.parentView, skipBlockHelpers);                      //\n    } else {                                                                                                           //\n      templateInstance = getTemplateInstance(templateInstance.view.originalParentView || templateInstance.view.parentView, skipBlockHelpers);\n    }                                                                                                                  //\n  }                                                                                                                    //\n  return null;                                                                                                         //\n};                                                                                                                     //\n                                                                                                                       //\ngetTemplateInstanceFunction = function getTemplateInstanceFunction(view, skipBlockHelpers) {                           //\n  var templateInstance;                                                                                                //\n  templateInstance = getTemplateInstance(view, skipBlockHelpers);                                                      //\n  return function () {                                                                                                 //\n    return templateInstance;                                                                                           //\n  };                                                                                                                   //\n};                                                                                                                     //\n                                                                                                                       //\nComponentsNamespaceReference = function () {                                                                           //\n  function ComponentsNamespaceReference(namespace, templateInstance1) {                                                //\n    this.namespace = namespace;                                                                                        //\n    this.templateInstance = templateInstance1;                                                                         //\n  }                                                                                                                    //\n                                                                                                                       //\n  return ComponentsNamespaceReference;                                                                                 //\n}();                                                                                                                   //\n                                                                                                                       //\noriginalDot = Spacebars.dot;                                                                                           //\n                                                                                                                       //\nSpacebars.dot = function () {                                                                                          //\n  var args, value;                                                                                                     //\n  value = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];                                  //\n  if (value instanceof ComponentsNamespaceReference) {                                                                 //\n    return Blaze._getTemplate(value.namespace + \".\" + args.join('.'), value.templateInstance);                         //\n  }                                                                                                                    //\n  return originalDot.apply(null, [value].concat(slice.call(args)));                                                    //\n};                                                                                                                     //\n                                                                                                                       //\noriginalInclude = Spacebars.include;                                                                                   //\n                                                                                                                       //\nSpacebars.include = function () {                                                                                      //\n  var args, templateOrFunction;                                                                                        //\n  templateOrFunction = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];                     //\n  if (templateOrFunction instanceof ComponentsNamespaceReference) {                                                    //\n    templateOrFunction = Blaze._getTemplate(templateOrFunction.namespace, templateOrFunction.templateInstance);        //\n  }                                                                                                                    //\n  return originalInclude.apply(null, [templateOrFunction].concat(slice.call(args)));                                   //\n};                                                                                                                     //\n                                                                                                                       //\nBlaze._getTemplateHelper = function (template, name, templateInstance) {                                               //\n  var component, helper, isKnownOldStyleHelper, mixinOrComponent, ref, ref1, ref2;                                     //\n  isKnownOldStyleHelper = false;                                                                                       //\n  if (template.__helpers.has(name)) {                                                                                  //\n    helper = template.__helpers.get(name);                                                                             //\n    if (helper === Blaze._OLDSTYLE_HELPER) {                                                                           //\n      isKnownOldStyleHelper = true;                                                                                    //\n    } else if (helper != null) {                                                                                       //\n      return wrapHelper(bindDataContext(helper), templateInstance);                                                    //\n    } else {                                                                                                           //\n      return null;                                                                                                     //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  if (name in template) {                                                                                              //\n    if (!isKnownOldStyleHelper) {                                                                                      //\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);                                                            //\n      if (!template._NOWARN_OLDSTYLE_HELPERS) {                                                                        //\n        Blaze._warn(\"Assigning helper with `\" + template.viewName + \".\" + name + \" = ...` is deprecated.  Use `\" + template.viewName + \".helpers(...)` instead.\");\n      }                                                                                                                //\n    }                                                                                                                  //\n    if (template[name] != null) {                                                                                      //\n      return wrapHelper(bindDataContext(template[name]), templateInstance);                                            //\n    } else {                                                                                                           //\n      return null;                                                                                                     //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  if (!templateInstance) {                                                                                             //\n    return null;                                                                                                       //\n  }                                                                                                                    //\n  if ((ref = template.viewName) === 'Template.__dynamicWithDataContext' || ref === 'Template.__dynamic') {             //\n    return null;                                                                                                       //\n  }                                                                                                                    //\n  component = Tracker.nonreactive(function () {                                                                        //\n    return templateInstanceToComponent(templateInstance, true);                                                        //\n  });                                                                                                                  //\n  if (component) {                                                                                                     //\n    if (mixinOrComponent = component.getFirstWith(null, name)) {                                                       //\n      return wrapHelper(bindComponent(mixinOrComponent, mixinOrComponent[name]), templateInstance);                    //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  if (name && name in BlazeComponent.components) {                                                                     //\n    return new ComponentsNamespaceReference(name, templateInstance);                                                   //\n  }                                                                                                                    //\n  if (component) {                                                                                                     //\n    if ((helper = (ref1 = component._componentInternals) != null ? (ref2 = ref1.templateBase) != null ? ref2.__helpers.get(name) : void 0 : void 0) != null) {\n      return wrapHelper(bindDataContext(helper), templateInstance);                                                    //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  return null;                                                                                                         //\n};                                                                                                                     //\n                                                                                                                       //\nshare.inExpandAttributes = false;                                                                                      //\n                                                                                                                       //\nbindComponent = function bindComponent(component, helper) {                                                            //\n  if (_.isFunction(helper)) {                                                                                          //\n    return function () {                                                                                               //\n      var args, name, result, value;                                                                                   //\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                    //\n      result = helper.apply(component, args);                                                                          //\n      if (share.inExpandAttributes && _.isObject(result)) {                                                            //\n        for (name in meteorBabelHelpers.sanitizeForInObject(result)) {                                                 //\n          value = result[name];                                                                                        //\n          if (share.EVENT_HANDLER_REGEX.test(name)) {                                                                  //\n            if (_.isFunction(value)) {                                                                                 //\n              result[name] = _.bind(value, component);                                                                 //\n            } else if (_.isArray(value)) {                                                                             //\n              result[name] = _.map(value, function (fun) {                                                             //\n                if (_.isFunction(fun)) {                                                                               //\n                  return _.bind(fun, component);                                                                       //\n                } else {                                                                                               //\n                  return fun;                                                                                          //\n                }                                                                                                      //\n              });                                                                                                      //\n            }                                                                                                          //\n          }                                                                                                            //\n        }                                                                                                              //\n      }                                                                                                                //\n      return result;                                                                                                   //\n    };                                                                                                                 //\n  } else {                                                                                                             //\n    return helper;                                                                                                     //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nbindDataContext = function bindDataContext(helper) {                                                                   //\n  if (_.isFunction(helper)) {                                                                                          //\n    return function () {                                                                                               //\n      var data;                                                                                                        //\n      data = Blaze.getData();                                                                                          //\n      if (data == null) {                                                                                              //\n        data = {};                                                                                                     //\n      }                                                                                                                //\n      return helper.apply(data, arguments);                                                                            //\n    };                                                                                                                 //\n  } else {                                                                                                             //\n    return helper;                                                                                                     //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nwrapHelper = function wrapHelper(f, templateFunc) {                                                                    //\n  if (!Blaze.Template._withTemplateInstanceFunc) {                                                                     //\n    return Blaze._wrapCatchingExceptions(f, 'template helper');                                                        //\n  }                                                                                                                    //\n  if (!_.isFunction(f)) {                                                                                              //\n    return f;                                                                                                          //\n  }                                                                                                                    //\n  return function () {                                                                                                 //\n    var args, self;                                                                                                    //\n    self = this;                                                                                                       //\n    args = arguments;                                                                                                  //\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {                                        //\n      return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);                                    //\n    });                                                                                                                //\n  };                                                                                                                   //\n};                                                                                                                     //\n                                                                                                                       //\nif (Blaze.Template._withTemplateInstanceFunc) {                                                                        //\n  withTemplateInstanceFunc = Blaze.Template._withTemplateInstanceFunc;                                                 //\n} else {                                                                                                               //\n  withTemplateInstanceFunc = function withTemplateInstanceFunc(templateInstance, f) {                                  //\n    return f();                                                                                                        //\n  };                                                                                                                   //\n}                                                                                                                      //\n                                                                                                                       //\ngetTemplateBase = function getTemplateBase(component) {                                                                //\n  return Tracker.nonreactive(function () {                                                                             //\n    var componentTemplate, templateBase;                                                                               //\n    componentTemplate = component.template();                                                                          //\n    if (_.isString(componentTemplate)) {                                                                               //\n      templateBase = Template[componentTemplate];                                                                      //\n      if (!templateBase) {                                                                                             //\n        throw new Error(\"Template '\" + componentTemplate + \"' cannot be found.\");                                      //\n      }                                                                                                                //\n    } else if (componentTemplate) {                                                                                    //\n      templateBase = componentTemplate;                                                                                //\n    } else {                                                                                                           //\n      throw new Error(\"Template for the component '\" + (component.componentName() || 'unnamed') + \"' not provided.\");  //\n    }                                                                                                                  //\n    return templateBase;                                                                                               //\n  });                                                                                                                  //\n};                                                                                                                     //\n                                                                                                                       //\ncallTemplateBaseHooks = function callTemplateBaseHooks(component, hookName) {                                          //\n  var callbacks, templateInstance;                                                                                     //\n  if (component._componentInternals == null) {                                                                         //\n    component._componentInternals = {};                                                                                //\n  }                                                                                                                    //\n  if (!component._componentInternals.templateInstance) {                                                               //\n    return;                                                                                                            //\n  }                                                                                                                    //\n  templateInstance = Tracker.nonreactive(function () {                                                                 //\n    return component._componentInternals.templateInstance();                                                           //\n  });                                                                                                                  //\n  callbacks = component._componentInternals.templateBase._getCallbacks(hookName);                                      //\n  Template._withTemplateInstanceFunc(function () {                                                                     //\n    return templateInstance;                                                                                           //\n  }, function () {                                                                                                     //\n    var callback, i, len, results;                                                                                     //\n    results = [];                                                                                                      //\n    for (i = 0, len = callbacks.length; i < len; i++) {                                                                //\n      callback = callbacks[i];                                                                                         //\n      results.push(callback.call(templateInstance));                                                                   //\n    }                                                                                                                  //\n    return results;                                                                                                    //\n  });                                                                                                                  //\n};                                                                                                                     //\n                                                                                                                       //\nwrapViewAndTemplate = function wrapViewAndTemplate(currentView, f) {                                                   //\n  var templateInstance;                                                                                                //\n  templateInstance = getTemplateInstanceFunction(currentView, true);                                                   //\n  return withTemplateInstanceFunc(templateInstance, function () {                                                      //\n    return Blaze._withCurrentView(currentView, function () {                                                           //\n      return f();                                                                                                      //\n    });                                                                                                                //\n  });                                                                                                                  //\n};                                                                                                                     //\n                                                                                                                       //\naddEvents = function addEvents(view, component) {                                                                      //\n  var eventMap, events, eventsList, fn, handler, i, len, spec;                                                         //\n  eventsList = component.events();                                                                                     //\n  if (!_.isArray(eventsList)) {                                                                                        //\n    throw new Error(\"'events' method from the component '\" + (component.componentName() || 'unnamed') + \"' did not return a list of event maps.\");\n  }                                                                                                                    //\n  for (i = 0, len = eventsList.length; i < len; i++) {                                                                 //\n    events = eventsList[i];                                                                                            //\n    eventMap = {};                                                                                                     //\n    fn = function fn(spec, handler) {                                                                                  //\n      return eventMap[spec] = function () {                                                                            //\n        var args, currentView, event;                                                                                  //\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                  //\n        event = args[0];                                                                                               //\n        currentView = Blaze.getView(event.currentTarget);                                                              //\n        wrapViewAndTemplate(currentView, function () {                                                                 //\n          return handler.apply(component, args);                                                                       //\n        });                                                                                                            //\n      };                                                                                                               //\n    };                                                                                                                 //\n    for (spec in meteorBabelHelpers.sanitizeForInObject(events)) {                                                     //\n      handler = events[spec];                                                                                          //\n      fn(spec, handler);                                                                                               //\n    }                                                                                                                  //\n    Blaze._addEventMap(view, eventMap, view);                                                                          //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\noriginalGetTemplate = Blaze._getTemplate;                                                                              //\n                                                                                                                       //\nBlaze._getTemplate = function (name, templateInstance) {                                                               //\n  var template;                                                                                                        //\n  template = Tracker.nonreactive(function () {                                                                         //\n    var parentComponent, ref;                                                                                          //\n    if (Blaze.currentView) {                                                                                           //\n      parentComponent = BlazeComponent.currentComponent();                                                             //\n    } else {                                                                                                           //\n      parentComponent = templateInstanceToComponent(templateInstance, false);                                          //\n    }                                                                                                                  //\n    return (ref = BlazeComponent.getComponent(name)) != null ? ref.renderComponent(parentComponent) : void 0;          //\n  });                                                                                                                  //\n  if (template && (template instanceof Blaze.Template || _.isFunction(template))) {                                    //\n    return template;                                                                                                   //\n  }                                                                                                                    //\n  return originalGetTemplate(name);                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nregisterHooks = function registerHooks(template, hooks) {                                                              //\n  if (template.onCreated) {                                                                                            //\n    template.onCreated(hooks.onCreated);                                                                               //\n    template.onRendered(hooks.onRendered);                                                                             //\n    return template.onDestroyed(hooks.onDestroyed);                                                                    //\n  } else {                                                                                                             //\n    template.created = hooks.onCreated;                                                                                //\n    template.rendered = hooks.onRendered;                                                                              //\n    return template.destroyed = hooks.onDestroyed;                                                                     //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nregisterFirstCreatedHook = function registerFirstCreatedHook(template, onCreated) {                                    //\n  var oldCreated;                                                                                                      //\n  if (template._callbacks) {                                                                                           //\n    return template._callbacks.created.unshift(onCreated);                                                             //\n  } else {                                                                                                             //\n    oldCreated = template.created;                                                                                     //\n    return template.created = function () {                                                                            //\n      onCreated.call(this);                                                                                            //\n      return oldCreated != null ? oldCreated.call(this) : void 0;                                                      //\n    };                                                                                                                 //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nTemplate.__dynamicWithDataContext.__helpers.set('chooseTemplate', function (name) {                                    //\n  return Blaze._getTemplate(name, function (_this) {                                                                   //\n    return function () {                                                                                               //\n      return Template.instance();                                                                                      //\n    };                                                                                                                 //\n  }(this));                                                                                                            //\n});                                                                                                                    //\n                                                                                                                       //\nargumentsConstructor = function argumentsConstructor() {                                                               //\n  return assert(false);                                                                                                //\n};                                                                                                                     //\n                                                                                                                       //\nTemplate.registerHelper('args', function () {                                                                          //\n  var obj;                                                                                                             //\n  obj = {};                                                                                                            //\n  obj.constructor = argumentsConstructor;                                                                              //\n  obj._arguments = arguments;                                                                                          //\n  return obj;                                                                                                          //\n});                                                                                                                    //\n                                                                                                                       //\nshare.EVENT_HANDLER_REGEX = /^on[A-Z]/;                                                                                //\n                                                                                                                       //\nshare.isEventHandler = function (fun) {                                                                                //\n  return _.isFunction(fun) && fun.eventHandler;                                                                        //\n};                                                                                                                     //\n                                                                                                                       //\noriginalFlattenAttributes = HTML.flattenAttributes;                                                                    //\n                                                                                                                       //\nHTML.flattenAttributes = function (attrs) {                                                                            //\n  var name, value;                                                                                                     //\n  if (attrs = originalFlattenAttributes(attrs)) {                                                                      //\n    for (name in meteorBabelHelpers.sanitizeForInObject(attrs)) {                                                      //\n      value = attrs[name];                                                                                             //\n      if (!share.EVENT_HANDLER_REGEX.test(name)) {                                                                     //\n        continue;                                                                                                      //\n      }                                                                                                                //\n      if (share.isEventHandler(value)) {                                                                               //\n        continue;                                                                                                      //\n      }                                                                                                                //\n      if (_.isArray(value) && _.some(value, share.isEventHandler)) {                                                   //\n        continue;                                                                                                      //\n      }                                                                                                                //\n      if (_.isArray(value)) {                                                                                          //\n        attrs[name] = _.map(value, Spacebars.event);                                                                   //\n      } else {                                                                                                         //\n        attrs[name] = Spacebars.event(value);                                                                          //\n      }                                                                                                                //\n    }                                                                                                                  //\n  }                                                                                                                    //\n  return attrs;                                                                                                        //\n};                                                                                                                     //\n                                                                                                                       //\nSpacebars.event = function () {                                                                                        //\n  var args, eventHandler, fun;                                                                                         //\n  eventHandler = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];                           //\n  if (!_.isFunction(eventHandler)) {                                                                                   //\n    throw new Error(\"Event handler not a function: \" + eventHandler);                                                  //\n  }                                                                                                                    //\n  args = Spacebars.mustacheImpl.apply(Spacebars, [function () {                                                        //\n    var xs;                                                                                                            //\n    xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                        //\n    return xs;                                                                                                         //\n  }].concat(slice.call(args)));                                                                                        //\n  fun = function fun() {                                                                                               //\n    var currentView, event, eventArgs;                                                                                 //\n    event = arguments[0], eventArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];                           //\n    currentView = Blaze.getView(event.currentTarget);                                                                  //\n    return wrapViewAndTemplate(currentView, function () {                                                              //\n      return eventHandler.apply(null, [event].concat(args, eventArgs));                                                //\n    });                                                                                                                //\n  };                                                                                                                   //\n  fun.eventHandler = true;                                                                                             //\n  return fun;                                                                                                          //\n};                                                                                                                     //\n                                                                                                                       //\noriginalVisitTag = HTML.ToHTMLVisitor.prototype.visitTag;                                                              //\n                                                                                                                       //\nHTML.ToHTMLVisitor.prototype.visitTag = function (tag) {                                                               //\n  var attrs, name;                                                                                                     //\n  if (attrs = tag.attrs) {                                                                                             //\n    attrs = HTML.flattenAttributes(attrs);                                                                             //\n    for (name in meteorBabelHelpers.sanitizeForInObject(attrs)) {                                                      //\n      if (share.EVENT_HANDLER_REGEX.test(name)) {                                                                      //\n        delete attrs[name];                                                                                            //\n      }                                                                                                                //\n    }                                                                                                                  //\n    tag.attrs = attrs;                                                                                                 //\n  }                                                                                                                    //\n  return originalVisitTag.call(this, tag);                                                                             //\n};                                                                                                                     //\n                                                                                                                       //\ncurrentViewIfRendering = function currentViewIfRendering() {                                                           //\n  var view;                                                                                                            //\n  view = Blaze.currentView;                                                                                            //\n  if (view != null ? view._isInRender : void 0) {                                                                      //\n    return view;                                                                                                       //\n  } else {                                                                                                             //\n    return null;                                                                                                       //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\ncontentAsFunc = function contentAsFunc(content) {                                                                      //\n  if (!_.isFunction(content)) {                                                                                        //\n    return function () {                                                                                               //\n      return content;                                                                                                  //\n    };                                                                                                                 //\n  }                                                                                                                    //\n  return content;                                                                                                      //\n};                                                                                                                     //\n                                                                                                                       //\ncontentAsView = function contentAsView(content) {                                                                      //\n  if (content instanceof Blaze.Template) {                                                                             //\n    return content.constructView();                                                                                    //\n  } else if (content instanceof Blaze.View) {                                                                          //\n    return content;                                                                                                    //\n  } else {                                                                                                             //\n    return Blaze.View('render', contentAsFunc(content));                                                               //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nHTMLJSExpander = Blaze._HTMLJSExpander.extend();                                                                       //\n                                                                                                                       //\nHTMLJSExpander.def({                                                                                                   //\n  visitObject: function () {                                                                                           //\n    function visitObject(x) {                                                                                          //\n      if (x instanceof Blaze.Template) {                                                                               //\n        x = x.constructView();                                                                                         //\n      }                                                                                                                //\n      if (x instanceof Blaze.View) {                                                                                   //\n        return expandView(x, this.parentView);                                                                         //\n      }                                                                                                                //\n      return HTML.TransformingVisitor.prototype.visitObject.call(this, x);                                             //\n    }                                                                                                                  //\n                                                                                                                       //\n    return visitObject;                                                                                                //\n  }()                                                                                                                  //\n});                                                                                                                    //\n                                                                                                                       //\nexpand = function expand(htmljs, parentView) {                                                                         //\n  parentView = parentView || currentViewIfRendering();                                                                 //\n  return new HTMLJSExpander({                                                                                          //\n    parentView: parentView                                                                                             //\n  }).visit(htmljs);                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\nexpandView = function expandView(view, parentView) {                                                                   //\n  var htmljs, result;                                                                                                  //\n  Blaze._createView(view, parentView, true);                                                                           //\n  view._isInRender = true;                                                                                             //\n  htmljs = Blaze._withCurrentView(view, function () {                                                                  //\n    return view._render();                                                                                             //\n  });                                                                                                                  //\n  view._isInRender = false;                                                                                            //\n  Tracker.flush();                                                                                                     //\n  result = expand(htmljs, view);                                                                                       //\n  Tracker.flush();                                                                                                     //\n  if (Tracker.active) {                                                                                                //\n    Tracker.onInvalidate(function () {                                                                                 //\n      return Blaze._destroyView(view);                                                                                 //\n    });                                                                                                                //\n  } else {                                                                                                             //\n    Blaze._destroyView(view);                                                                                          //\n  }                                                                                                                    //\n  Tracker.flush();                                                                                                     //\n  return result;                                                                                                       //\n};                                                                                                                     //\n                                                                                                                       //\nBlazeComponent = function (superClass) {                                                                               //\n  extend(BlazeComponent, superClass);                                                                                  //\n                                                                                                                       //\n  function BlazeComponent() {                                                                                          //\n    return BlazeComponent.__super__.constructor.apply(this, arguments);                                                //\n  }                                                                                                                    //\n                                                                                                                       //\n  BlazeComponent.getComponentForElement = function (domElement) {                                                      //\n    var templateInstance;                                                                                              //\n    if (!domElement) {                                                                                                 //\n      return null;                                                                                                     //\n    }                                                                                                                  //\n    if (domElement.nodeType !== Node.ELEMENT_NODE) {                                                                   //\n      throw new Error(\"Expected DOM element.\");                                                                        //\n    }                                                                                                                  //\n    templateInstance = getTemplateInstanceFunction(Blaze.getView(domElement), true);                                   //\n    return templateInstanceToComponent(templateInstance, true);                                                        //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.mixins = function () {                                                                      //\n    return [];                                                                                                         //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.mixinParent = function (mixinParent) {                                                      //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if (mixinParent) {                                                                                                 //\n      this._componentInternals.mixinParent = mixinParent;                                                              //\n      return this;                                                                                                     //\n    }                                                                                                                  //\n    return this._componentInternals.mixinParent || null;                                                               //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.requireMixin = function (nameOrMixin) {                                                     //\n    var ref;                                                                                                           //\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);                                            //\n    Tracker.nonreactive(function (_this) {                                                                             //\n      return function () {                                                                                             //\n        var base, mixinInstance, mixinInstanceComponent, ref1, ref2, ref3;                                             //\n        if (_this.getMixin(nameOrMixin)) {                                                                             //\n          return;                                                                                                      //\n        }                                                                                                              //\n        if (_.isString(nameOrMixin)) {                                                                                 //\n          if (_this.constructor.getComponent) {                                                                        //\n            mixinInstanceComponent = _this.constructor.getComponent(nameOrMixin);                                      //\n          } else {                                                                                                     //\n            mixinInstanceComponent = BlazeComponent.getComponent(nameOrMixin);                                         //\n          }                                                                                                            //\n          if (!mixinInstanceComponent) {                                                                               //\n            throw new Error(\"Unknown mixin '\" + nameOrMixin + \"'.\");                                                   //\n          }                                                                                                            //\n          mixinInstance = new mixinInstanceComponent();                                                                //\n        } else if (_.isFunction(nameOrMixin)) {                                                                        //\n          mixinInstance = new nameOrMixin();                                                                           //\n        } else {                                                                                                       //\n          mixinInstance = nameOrMixin;                                                                                 //\n        }                                                                                                              //\n        _this._componentInternals.mixins.push(mixinInstance);                                                          //\n        if (mixinInstance.mixinParent) {                                                                               //\n          mixinInstance.mixinParent(_this);                                                                            //\n        }                                                                                                              //\n        if (typeof mixinInstance.createMixins === \"function\") {                                                        //\n          mixinInstance.createMixins();                                                                                //\n        }                                                                                                              //\n        if ((base = _this._componentInternals).templateInstance == null) {                                             //\n          base.templateInstance = new ReactiveField(null, function (a, b) {                                            //\n            return a === b;                                                                                            //\n          });                                                                                                          //\n        }                                                                                                              //\n        if (!((ref1 = _this._componentInternals.templateInstance()) != null ? ref1.view.isDestroyed : void 0)) {       //\n          if (!_this._componentInternals.inOnCreated && ((ref2 = _this._componentInternals.templateInstance()) != null ? ref2.view.isCreated : void 0)) {\n            if (typeof mixinInstance.onCreated === \"function\") {                                                       //\n              mixinInstance.onCreated();                                                                               //\n            }                                                                                                          //\n          }                                                                                                            //\n          if (!_this._componentInternals.inOnRendered && ((ref3 = _this._componentInternals.templateInstance()) != null ? ref3.view.isRendered : void 0)) {\n            return typeof mixinInstance.onRendered === \"function\" ? mixinInstance.onRendered() : void 0;               //\n          }                                                                                                            //\n        }                                                                                                              //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n    return this;                                                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.createMixins = function () {                                                                //\n    var i, len, mixin, ref;                                                                                            //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if (this._componentInternals.mixins) {                                                                             //\n      return;                                                                                                          //\n    }                                                                                                                  //\n    this._componentInternals.mixins = [];                                                                              //\n    ref = this.mixins();                                                                                               //\n    for (i = 0, len = ref.length; i < len; i++) {                                                                      //\n      mixin = ref[i];                                                                                                  //\n      this.requireMixin(mixin);                                                                                        //\n    }                                                                                                                  //\n    return this;                                                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.getMixin = function (nameOrMixin) {                                                         //\n    var i, j, len, len1, mixin, mixinComponentName, ref, ref1, ref2;                                                   //\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);                                            //\n    if (_.isString(nameOrMixin)) {                                                                                     //\n      ref1 = this._componentInternals.mixins;                                                                          //\n      for (i = 0, len = ref1.length; i < len; i++) {                                                                   //\n        mixin = ref1[i];                                                                                               //\n        mixinComponentName = (typeof mixin.componentName === \"function\" ? mixin.componentName() : void 0) || null;     //\n        if (mixinComponentName && mixinComponentName === nameOrMixin) {                                                //\n          return mixin;                                                                                                //\n        }                                                                                                              //\n      }                                                                                                                //\n    } else {                                                                                                           //\n      ref2 = this._componentInternals.mixins;                                                                          //\n      for (j = 0, len1 = ref2.length; j < len1; j++) {                                                                 //\n        mixin = ref2[j];                                                                                               //\n        if (mixin.constructor === nameOrMixin) {                                                                       //\n          return mixin;                                                                                                //\n        } else if (mixin === nameOrMixin) {                                                                            //\n          return mixin;                                                                                                //\n        }                                                                                                              //\n      }                                                                                                                //\n    }                                                                                                                  //\n    return null;                                                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.callFirstWith = function () {                                                               //\n    var afterComponentOrMixin, args, mixin, propertyName;                                                              //\n    afterComponentOrMixin = arguments[0], propertyName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n    mixin = this.getFirstWith(afterComponentOrMixin, propertyName);                                                    //\n    if (!mixin) {                                                                                                      //\n      return;                                                                                                          //\n    }                                                                                                                  //\n    if (_.isFunction(mixin[propertyName])) {                                                                           //\n      return mixin[propertyName].apply(mixin, args);                                                                   //\n    } else {                                                                                                           //\n      return mixin[propertyName];                                                                                      //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.getFirstWith = function (afterComponentOrMixin, propertyName) {                             //\n    var found, i, len, mixin, ref, ref1;                                                                               //\n    assert((ref = this._componentInternals) != null ? ref.mixins : void 0);                                            //\n    if (!afterComponentOrMixin) {                                                                                      //\n      if (propertyName in this) {                                                                                      //\n        return this;                                                                                                   //\n      }                                                                                                                //\n      found = true;                                                                                                    //\n    } else if (afterComponentOrMixin && afterComponentOrMixin === this) {                                              //\n      found = true;                                                                                                    //\n    } else {                                                                                                           //\n      found = false;                                                                                                   //\n    }                                                                                                                  //\n    ref1 = this._componentInternals.mixins;                                                                            //\n    for (i = 0, len = ref1.length; i < len; i++) {                                                                     //\n      mixin = ref1[i];                                                                                                 //\n      if (found && propertyName in mixin) {                                                                            //\n        return mixin;                                                                                                  //\n      }                                                                                                                //\n      if (mixin === afterComponentOrMixin) {                                                                           //\n        found = true;                                                                                                  //\n      }                                                                                                                //\n    }                                                                                                                  //\n    return null;                                                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.renderComponent = function (parentComponent) {                                                        //\n    return Tracker.nonreactive(function (_this) {                                                                      //\n      return function () {                                                                                             //\n        var componentClass, data;                                                                                      //\n        componentClass = _this;                                                                                        //\n        if (Blaze.currentView) {                                                                                       //\n          data = Template.currentData();                                                                               //\n        } else {                                                                                                       //\n          data = null;                                                                                                 //\n        }                                                                                                              //\n        if ((data != null ? data.constructor : void 0) !== argumentsConstructor) {                                     //\n          return wrapViewAndTemplate(Blaze.currentView, function () {                                                  //\n            var component;                                                                                             //\n            component = new componentClass();                                                                          //\n            return component.renderComponent(parentComponent);                                                         //\n          });                                                                                                          //\n        }                                                                                                              //\n        return function () {                                                                                           //\n          var currentWith, nonreactiveArguments, reactiveArguments;                                                    //\n          assert(Tracker.active);                                                                                      //\n          currentWith = Blaze.getView('with');                                                                         //\n          reactiveArguments = new ComputedField(function () {                                                          //\n            data = currentWith.dataVar.get();                                                                          //\n            assert.equal(data != null ? data.constructor : void 0, argumentsConstructor);                              //\n            return data._arguments;                                                                                    //\n          }, EJSON.equals);                                                                                            //\n          nonreactiveArguments = reactiveArguments();                                                                  //\n          return Tracker.nonreactive(function () {                                                                     //\n            var template;                                                                                              //\n            template = Blaze._withCurrentView(Blaze.currentView.parentView.parentView, function (_this) {              //\n              return function () {                                                                                     //\n                return wrapViewAndTemplate(Blaze.currentView, function () {                                            //\n                  var component;                                                                                       //\n                  component = function (func, args, ctor) {                                                            //\n                    ctor.prototype = func.prototype;                                                                   //\n                    var child = new ctor(),                                                                            //\n                        result = func.apply(child, args);                                                              //\n                    return Object(result) === result ? result : child;                                                 //\n                  }(componentClass, nonreactiveArguments, function () {});                                             //\n                  return component.renderComponent(parentComponent);                                                   //\n                });                                                                                                    //\n              };                                                                                                       //\n            }(this));                                                                                                  //\n            registerFirstCreatedHook(template, function () {                                                           //\n              this.view.originalParentView = this.view.parentView;                                                     //\n              return this.view.parentView = this.view.parentView.parentView.parentView;                                //\n            });                                                                                                        //\n            return template;                                                                                           //\n          });                                                                                                          //\n        };                                                                                                             //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.renderComponent = function (parentComponent) {                                              //\n    return Tracker.nonreactive(function (_this) {                                                                      //\n      return function () {                                                                                             //\n        var component, template, templateBase;                                                                         //\n        component = _this;                                                                                             //\n        component.createMixins();                                                                                      //\n        templateBase = getTemplateBase(component);                                                                     //\n        template = new Blaze.Template(\"BlazeComponent.\" + (component.componentName() || 'unnamed'), templateBase.renderFunction);\n        if (component._componentInternals == null) {                                                                   //\n          component._componentInternals = {};                                                                          //\n        }                                                                                                              //\n        component._componentInternals.templateBase = templateBase;                                                     //\n        registerHooks(template, {                                                                                      //\n          onCreated: function () {                                                                                     //\n            function onCreated() {                                                                                     //\n              var base, base1, base2, base3, componentOrMixin, results;                                                //\n              if (parentComponent) {                                                                                   //\n                Tracker.nonreactive(function (_this) {                                                                 //\n                  return function () {                                                                                 //\n                    assert(!component.parentComponent());                                                              //\n                    component.parentComponent(parentComponent);                                                        //\n                    return parentComponent.addChildComponent(component);                                               //\n                  };                                                                                                   //\n                }(this));                                                                                              //\n              }                                                                                                        //\n              this.view._onViewRendered(function (_this) {                                                             //\n                return function () {                                                                                   //\n                  var componentOrMixin, results;                                                                       //\n                  if (_this.view.renderCount !== 1) {                                                                  //\n                    return;                                                                                            //\n                  }                                                                                                    //\n                  componentOrMixin = null;                                                                             //\n                  results = [];                                                                                        //\n                  while (componentOrMixin = _this.component.getFirstWith(componentOrMixin, 'events')) {                //\n                    results.push(addEvents(_this.view, componentOrMixin));                                             //\n                  }                                                                                                    //\n                  return results;                                                                                      //\n                };                                                                                                     //\n              }(this));                                                                                                //\n              this.component = component;                                                                              //\n              assert(!Tracker.nonreactive(function (_this) {                                                           //\n                return function () {                                                                                   //\n                  var base;                                                                                            //\n                  return typeof (base = _this.component._componentInternals).templateInstance === \"function\" ? base.templateInstance() : void 0;\n                };                                                                                                     //\n              }(this)));                                                                                               //\n              if ((base = this.component._componentInternals).templateInstance == null) {                              //\n                base.templateInstance = new ReactiveField(this, function (a, b) {                                      //\n                  return a === b;                                                                                      //\n                });                                                                                                    //\n              }                                                                                                        //\n              this.component._componentInternals.templateInstance(this);                                               //\n              if ((base1 = this.component._componentInternals).isCreated == null) {                                    //\n                base1.isCreated = new ReactiveField(true);                                                             //\n              }                                                                                                        //\n              this.component._componentInternals.isCreated(true);                                                      //\n              if ((base2 = this.component._componentInternals).isRendered == null) {                                   //\n                base2.isRendered = new ReactiveField(false);                                                           //\n              }                                                                                                        //\n              this.component._componentInternals.isRendered(false);                                                    //\n              if ((base3 = this.component._componentInternals).isDestroyed == null) {                                  //\n                base3.isDestroyed = new ReactiveField(false);                                                          //\n              }                                                                                                        //\n              this.component._componentInternals.isDestroyed(false);                                                   //\n              try {                                                                                                    //\n                this.component._componentInternals.inOnCreated = true;                                                 //\n                componentOrMixin = null;                                                                               //\n                results = [];                                                                                          //\n                while (componentOrMixin = this.component.getFirstWith(componentOrMixin, 'onCreated')) {                //\n                  results.push(componentOrMixin.onCreated());                                                          //\n                }                                                                                                      //\n                return results;                                                                                        //\n              } finally {                                                                                              //\n                delete this.component._componentInternals.inOnCreated;                                                 //\n              }                                                                                                        //\n            }                                                                                                          //\n                                                                                                                       //\n            return onCreated;                                                                                          //\n          }(),                                                                                                         //\n          onRendered: function () {                                                                                    //\n            function onRendered() {                                                                                    //\n              var base, componentOrMixin, results;                                                                     //\n              if ((base = this.component._componentInternals).isRendered == null) {                                    //\n                base.isRendered = new ReactiveField(true);                                                             //\n              }                                                                                                        //\n              this.component._componentInternals.isRendered(true);                                                     //\n              Tracker.nonreactive(function (_this) {                                                                   //\n                return function () {                                                                                   //\n                  return assert.equal(_this.component._componentInternals.isCreated(), true);                          //\n                };                                                                                                     //\n              }(this));                                                                                                //\n              try {                                                                                                    //\n                this.component._componentInternals.inOnRendered = true;                                                //\n                componentOrMixin = null;                                                                               //\n                results = [];                                                                                          //\n                while (componentOrMixin = this.component.getFirstWith(componentOrMixin, 'onRendered')) {               //\n                  results.push(componentOrMixin.onRendered());                                                         //\n                }                                                                                                      //\n                return results;                                                                                        //\n              } finally {                                                                                              //\n                delete this.component._componentInternals.inOnRendered;                                                //\n              }                                                                                                        //\n            }                                                                                                          //\n                                                                                                                       //\n            return onRendered;                                                                                         //\n          }(),                                                                                                         //\n          onDestroyed: function () {                                                                                   //\n            function onDestroyed() {                                                                                   //\n              return this.autorun(function (_this) {                                                                   //\n                return function (computation) {                                                                        //\n                  if (_this.component.childComponents().length) {                                                      //\n                    return;                                                                                            //\n                  }                                                                                                    //\n                  computation.stop();                                                                                  //\n                  return Tracker.nonreactive(function () {                                                             //\n                    var base, base1, componentOrMixin;                                                                 //\n                    assert.equal(_this.component._componentInternals.isCreated(), true);                               //\n                    _this.component._componentInternals.isCreated(false);                                              //\n                    if ((base = _this.component._componentInternals).isRendered == null) {                             //\n                      base.isRendered = new ReactiveField(false);                                                      //\n                    }                                                                                                  //\n                    _this.component._componentInternals.isRendered(false);                                             //\n                    if ((base1 = _this.component._componentInternals).isDestroyed == null) {                           //\n                      base1.isDestroyed = new ReactiveField(true);                                                     //\n                    }                                                                                                  //\n                    _this.component._componentInternals.isDestroyed(true);                                             //\n                    componentOrMixin = null;                                                                           //\n                    while (componentOrMixin = _this.component.getFirstWith(componentOrMixin, 'onDestroyed')) {         //\n                      componentOrMixin.onDestroyed();                                                                  //\n                    }                                                                                                  //\n                    if (parentComponent) {                                                                             //\n                      component.parentComponent(null);                                                                 //\n                      parentComponent.removeChildComponent(component);                                                 //\n                    }                                                                                                  //\n                    return _this.component._componentInternals.templateInstance(null);                                 //\n                  });                                                                                                  //\n                };                                                                                                     //\n              }(this));                                                                                                //\n            }                                                                                                          //\n                                                                                                                       //\n            return onDestroyed;                                                                                        //\n          }()                                                                                                          //\n        });                                                                                                            //\n        return template;                                                                                               //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.removeComponent = function () {                                                             //\n    if (this.isRendered()) {                                                                                           //\n      return Blaze.remove(this._componentInternals.templateInstance().view);                                           //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.renderComponentToHTML = function (parentComponent, parentView, data) {                                //\n    var component;                                                                                                     //\n    component = Tracker.nonreactive(function (_this) {                                                                 //\n      return function () {                                                                                             //\n        var componentClass;                                                                                            //\n        componentClass = _this;                                                                                        //\n        parentView = parentView || currentViewIfRendering() || (parentComponent != null ? parentComponent.isRendered() : void 0) && parentComponent._componentInternals.templateInstance().view || null;\n        return wrapViewAndTemplate(parentView, function () {                                                           //\n          return new componentClass();                                                                                 //\n        });                                                                                                            //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n    if (arguments.length > 2) {                                                                                        //\n      return component.renderComponentToHTML(parentComponent, parentView, data);                                       //\n    } else {                                                                                                           //\n      return component.renderComponentToHTML(parentComponent, parentView);                                             //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.renderComponentToHTML = function (parentComponent, parentView, data) {                      //\n    var expandedView, template;                                                                                        //\n    template = Tracker.nonreactive(function (_this) {                                                                  //\n      return function () {                                                                                             //\n        parentView = parentView || currentViewIfRendering() || (parentComponent != null ? parentComponent.isRendered() : void 0) && parentComponent._componentInternals.templateInstance().view || null;\n        return wrapViewAndTemplate(parentView, function () {                                                           //\n          return _this.renderComponent(parentComponent);                                                               //\n        });                                                                                                            //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n    if (arguments.length > 2) {                                                                                        //\n      expandedView = expandView(Blaze._TemplateWith(data, contentAsFunc(template)), parentView);                       //\n    } else {                                                                                                           //\n      expandedView = expandView(contentAsView(template), parentView);                                                  //\n    }                                                                                                                  //\n    return HTML.toHTML(expandedView);                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.template = function () {                                                                    //\n    return this.callFirstWith(this, 'template') || this.constructor.componentName();                                   //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.onCreated = function () {                                                                   //\n    return callTemplateBaseHooks(this, 'created');                                                                     //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.onRendered = function () {                                                                  //\n    return callTemplateBaseHooks(this, 'rendered');                                                                    //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.onDestroyed = function () {                                                                 //\n    return callTemplateBaseHooks(this, 'destroyed');                                                                   //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.isCreated = function () {                                                                   //\n    var base;                                                                                                          //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if ((base = this._componentInternals).isCreated == null) {                                                         //\n      base.isCreated = new ReactiveField(false);                                                                       //\n    }                                                                                                                  //\n    return this._componentInternals.isCreated();                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.isRendered = function () {                                                                  //\n    var base;                                                                                                          //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if ((base = this._componentInternals).isRendered == null) {                                                        //\n      base.isRendered = new ReactiveField(false);                                                                      //\n    }                                                                                                                  //\n    return this._componentInternals.isRendered();                                                                      //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.isDestroyed = function () {                                                                 //\n    var base;                                                                                                          //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if ((base = this._componentInternals).isDestroyed == null) {                                                       //\n      base.isDestroyed = new ReactiveField(false);                                                                     //\n    }                                                                                                                  //\n    return this._componentInternals.isDestroyed();                                                                     //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.insertDOMElement = function (parent, node, before) {                                        //\n    if (before == null) {                                                                                              //\n      before = null;                                                                                                   //\n    }                                                                                                                  //\n    if (parent && node && (node.parentNode !== parent || node.nextSibling !== before)) {                               //\n      parent.insertBefore(node, before);                                                                               //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.moveDOMElement = function (parent, node, before) {                                          //\n    if (before == null) {                                                                                              //\n      before = null;                                                                                                   //\n    }                                                                                                                  //\n    if (parent && node && (node.parentNode !== parent || node.nextSibling !== before)) {                               //\n      parent.insertBefore(node, before);                                                                               //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.removeDOMElement = function (parent, node) {                                                //\n    if (parent && node && node.parentNode === parent) {                                                                //\n      parent.removeChild(node);                                                                                        //\n    }                                                                                                                  //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.events = function () {                                                                      //\n    var eventMap, events, fn, handler, i, len, ref, results, spec, templateInstance, view;                             //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if (!this._componentInternals.templateInstance) {                                                                  //\n      return [];                                                                                                       //\n    }                                                                                                                  //\n    view = Tracker.nonreactive(function (_this) {                                                                      //\n      return function () {                                                                                             //\n        return _this._componentInternals.templateInstance().view;                                                      //\n      };                                                                                                               //\n    }(this));                                                                                                          //\n    templateInstance = getTemplateInstanceFunction(view, true);                                                        //\n    ref = this._componentInternals.templateBase.__eventMaps;                                                           //\n    results = [];                                                                                                      //\n    for (i = 0, len = ref.length; i < len; i++) {                                                                      //\n      events = ref[i];                                                                                                 //\n      eventMap = {};                                                                                                   //\n      fn = function fn(spec, handler) {                                                                                //\n        return eventMap[spec] = function () {                                                                          //\n          var args;                                                                                                    //\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                //\n          return withTemplateInstanceFunc(templateInstance, function () {                                              //\n            return Blaze._withCurrentView(view, function () {                                                          //\n              return handler.apply(view, args);                                                                        //\n            });                                                                                                        //\n          });                                                                                                          //\n        };                                                                                                             //\n      };                                                                                                               //\n      for (spec in meteorBabelHelpers.sanitizeForInObject(events)) {                                                   //\n        handler = events[spec];                                                                                        //\n        fn(spec, handler);                                                                                             //\n      }                                                                                                                //\n      results.push(eventMap);                                                                                          //\n    }                                                                                                                  //\n    return results;                                                                                                    //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.data = function (path, equalsFunc) {                                                        //\n    var base, ref, view;                                                                                               //\n    if (this._componentInternals == null) {                                                                            //\n      this._componentInternals = {};                                                                                   //\n    }                                                                                                                  //\n    if ((base = this._componentInternals).templateInstance == null) {                                                  //\n      base.templateInstance = new ReactiveField(null, function (a, b) {                                                //\n        return a === b;                                                                                                //\n      });                                                                                                              //\n    }                                                                                                                  //\n    if (view = (ref = this._componentInternals.templateInstance()) != null ? ref.view : void 0) {                      //\n      if (path != null) {                                                                                              //\n        return DataLookup.get(function (_this) {                                                                       //\n          return function () {                                                                                         //\n            return Blaze.getData(view);                                                                                //\n          };                                                                                                           //\n        }(this), path, equalsFunc);                                                                                    //\n      } else {                                                                                                         //\n        return Blaze.getData(view);                                                                                    //\n      }                                                                                                                //\n    }                                                                                                                  //\n    return void 0;                                                                                                     //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.currentData = function (path, equalsFunc) {                                                           //\n    var currentView;                                                                                                   //\n    if (!Blaze.currentView) {                                                                                          //\n      return void 0;                                                                                                   //\n    }                                                                                                                  //\n    currentView = Blaze.currentView;                                                                                   //\n    if (_.isString(path)) {                                                                                            //\n      path = path.split('.');                                                                                          //\n    } else if (!_.isArray(path)) {                                                                                     //\n      return Blaze.getData(currentView);                                                                               //\n    }                                                                                                                  //\n    return DataLookup.get(function (_this) {                                                                           //\n      return function () {                                                                                             //\n        var lexicalData, result;                                                                                       //\n        if (Blaze._lexicalBindingLookup && (lexicalData = Blaze._lexicalBindingLookup(currentView, path[0]))) {        //\n          result = {};                                                                                                 //\n          result[path[0]] = lexicalData;                                                                               //\n          return result;                                                                                               //\n        }                                                                                                              //\n        return Blaze.getData(currentView);                                                                             //\n      };                                                                                                               //\n    }(this), path, equalsFunc);                                                                                        //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.currentData = function (path, equalsFunc) {                                                 //\n    return this.constructor.currentData(path, equalsFunc);                                                             //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.component = function () {                                                                   //\n    return this;                                                                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.currentComponent = function () {                                                                      //\n    var templateInstance;                                                                                              //\n    templateInstance = getTemplateInstanceFunction(Blaze.currentView, false);                                          //\n    return templateInstanceToComponent(templateInstance, false);                                                       //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.currentComponent = function () {                                                            //\n    return this.constructor.currentComponent();                                                                        //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.firstNode = function () {                                                                   //\n    if (this.isRendered()) {                                                                                           //\n      return this._componentInternals.templateInstance().view._domrange.firstNode();                                   //\n    }                                                                                                                  //\n    return void 0;                                                                                                     //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.lastNode = function () {                                                                    //\n    if (this.isRendered()) {                                                                                           //\n      return this._componentInternals.templateInstance().view._domrange.lastNode();                                    //\n    }                                                                                                                  //\n    return void 0;                                                                                                     //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponent.prototype.autorun = function (runFunc) {                                                              //\n    var templateInstance;                                                                                              //\n    templateInstance = Tracker.nonreactive(function (_this) {                                                          //\n      return function () {                                                                                             //\n        var ref;                                                                                                       //\n        return (ref = _this._componentInternals) != null ? typeof ref.templateInstance === \"function\" ? ref.templateInstance() : void 0 : void 0;\n      };                                                                                                               //\n    }(this));                                                                                                          //\n    if (!templateInstance) {                                                                                           //\n      throw new Error(\"The component has to be created before calling 'autorun'.\");                                    //\n    }                                                                                                                  //\n    return templateInstance.autorun(_.bind(runFunc, this));                                                            //\n  };                                                                                                                   //\n                                                                                                                       //\n  return BlazeComponent;                                                                                               //\n}(BaseComponent);                                                                                                      //\n                                                                                                                       //\nSUPPORTS_REACTIVE_INSTANCE = ['subscriptionsReady'];                                                                   //\n                                                                                                                       //\nREQUIRE_RENDERED_INSTANCE = ['$', 'find', 'findAll'];                                                                  //\n                                                                                                                       //\nref = Blaze.TemplateInstance.prototype;                                                                                //\nfor (methodName in meteorBabelHelpers.sanitizeForInObject(ref)) {                                                      //\n  method = ref[methodName];                                                                                            //\n  if (!(methodName in BlazeComponent.prototype)) {                                                                     //\n    (function (methodName, method) {                                                                                   //\n      if (indexOf.call(SUPPORTS_REACTIVE_INSTANCE, methodName) >= 0) {                                                 //\n        return BlazeComponent.prototype[methodName] = function () {                                                    //\n          var args, base, templateInstance;                                                                            //\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                //\n          if (this._componentInternals == null) {                                                                      //\n            this._componentInternals = {};                                                                             //\n          }                                                                                                            //\n          if ((base = this._componentInternals).templateInstance == null) {                                            //\n            base.templateInstance = new ReactiveField(null, function (a, b) {                                          //\n              return a === b;                                                                                          //\n            });                                                                                                        //\n          }                                                                                                            //\n          if (templateInstance = this._componentInternals.templateInstance()) {                                        //\n            return templateInstance[methodName].apply(templateInstance, args);                                         //\n          }                                                                                                            //\n          return void 0;                                                                                               //\n        };                                                                                                             //\n      } else if (indexOf.call(REQUIRE_RENDERED_INSTANCE, methodName) >= 0) {                                           //\n        return BlazeComponent.prototype[methodName] = function () {                                                    //\n          var args, ref1;                                                                                              //\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                //\n          if (this.isRendered()) {                                                                                     //\n            return (ref1 = this._componentInternals.templateInstance())[methodName].apply(ref1, args);                 //\n          }                                                                                                            //\n          return void 0;                                                                                               //\n        };                                                                                                             //\n      } else {                                                                                                         //\n        return BlazeComponent.prototype[methodName] = function () {                                                    //\n          var args, templateInstance;                                                                                  //\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];                                                //\n          templateInstance = Tracker.nonreactive(function (_this) {                                                    //\n            return function () {                                                                                       //\n              var ref1;                                                                                                //\n              return (ref1 = _this._componentInternals) != null ? typeof ref1.templateInstance === \"function\" ? ref1.templateInstance() : void 0 : void 0;\n            };                                                                                                         //\n          }(this));                                                                                                    //\n          if (!templateInstance) {                                                                                     //\n            throw new Error(\"The component has to be created before calling '\" + methodName + \"'.\");                   //\n          }                                                                                                            //\n          return templateInstance[methodName].apply(templateInstance, args);                                           //\n        };                                                                                                             //\n      }                                                                                                                //\n    })(methodName, method);                                                                                            //\n  }                                                                                                                    //\n}                                                                                                                      //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/debug.coffee.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar                                                                                                                    // 1\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,                                                                                         //\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n                                                                                                                       //\nBlazeComponentDebug = (function(superClass) {                                                                          // 1\n  extend(BlazeComponentDebug, superClass);                                                                             //\n                                                                                                                       //\n  function BlazeComponentDebug() {                                                                                     //\n    return BlazeComponentDebug.__super__.constructor.apply(this, arguments);                                           //\n  }                                                                                                                    //\n                                                                                                                       //\n  BlazeComponentDebug.startComponent = function(component) {                                                           //\n    BlazeComponentDebug.__super__.constructor.startComponent.apply(this, arguments);                                   //\n    return console.log(component.data());                                                                              //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponentDebug.startMarkedComponent = function(component) {                                                     //\n    BlazeComponentDebug.__super__.constructor.startMarkedComponent.apply(this, arguments);                             //\n    return console.log(component.data());                                                                              //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponentDebug.dumpComponentSubtree = function(rootComponentOrElement) {                                        //\n    if ('nodeType' in rootComponentOrElement && rootComponentOrElement.nodeType === Node.ELEMENT_NODE) {               //\n      rootComponentOrElement = BlazeComponent.getComponentForElement(rootComponentOrElement);                          //\n    }                                                                                                                  //\n    return BlazeComponentDebug.__super__.constructor.dumpComponentSubtree.apply(this, arguments);                      //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponentDebug.dumpComponentTree = function(rootComponentOrElement) {                                           //\n    if ('nodeType' in rootComponentOrElement && rootComponentOrElement.nodeType === Node.ELEMENT_NODE) {               //\n      rootComponentOrElement = BlazeComponent.getComponentForElement(rootComponentOrElement);                          //\n    }                                                                                                                  //\n    return BlazeComponentDebug.__super__.constructor.dumpComponentTree.apply(this, arguments);                         //\n  };                                                                                                                   //\n                                                                                                                       //\n  BlazeComponentDebug.dumpAllComponents = function() {                                                                 //\n    var allRootComponents, j, len, rootComponent;                                                                      // 25\n    allRootComponents = [];                                                                                            //\n    $('*').each((function(_this) {                                                                                     //\n      return function(i, element) {                                                                                    //\n        var component, rootComponent;                                                                                  // 28\n        component = BlazeComponent.getComponentForElement(element);                                                    //\n        if (!component) {                                                                                              //\n          return;                                                                                                      // 29\n        }                                                                                                              //\n        rootComponent = _this.componentRoot(component);                                                                //\n        if (indexOf.call(allRootComponents, rootComponent) < 0) {                                                      //\n          return allRootComponents.push(rootComponent);                                                                //\n        }                                                                                                              //\n      };                                                                                                               //\n    })(this));                                                                                                         //\n    for (j = 0, len = allRootComponents.length; j < len; j++) {                                                        // 33\n      rootComponent = allRootComponents[j];                                                                            //\n      this.dumpComponentSubtree(rootComponent);                                                                        //\n    }                                                                                                                  // 33\n  };                                                                                                                   //\n                                                                                                                       //\n  return BlazeComponentDebug;                                                                                          //\n                                                                                                                       //\n})(BaseComponentDebug);                                                                                                //\n                                                                                                                       //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary_blaze-components/server.coffee.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nTemplate.body.renderToDocument = function() {};                                                                        // 2\n                                                                                                                       //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['peerlibrary:blaze-components'] = {}, {\n  Template: Template,\n  BlazeComponent: BlazeComponent,\n  BlazeComponentDebug: BlazeComponentDebug\n});\n\n})();\n","servePath":"/packages/peerlibrary_blaze-components.js","sourceMap":{"version":3,"sources":["/packages/peerlibrary_blaze-components/template.coffee","/packages/peerlibrary_blaze-components/compatibility/templating.js","/packages/peerlibrary_blaze-components/compatibility/template.dynamic.js","/packages/peerlibrary_blaze-components/compatibility/dynamic.js","/packages/peerlibrary_blaze-components/compatibility/lookup.js","/packages/peerlibrary_blaze-components/compatibility/attrs.js","/packages/peerlibrary_blaze-components/compatibility/materializer.js","/packages/peerlibrary_blaze-components/debug.coffee","/packages/peerlibrary_blaze-components/server.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAA,WAAW,KAAK,CAAC;;;;;;;;;;;;;;;;;;;ACAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMA;EAAA;;;;AAAM;;;;;;;EACJ,mBAAC,eAAD,GAAiB,SAAC,SAAD;IACf;WAEA,OAAO,CAAC,GAAR,CAAY,SAAS,CAAC,IAAV,EAAZ;EAHe;;EAKjB,mBAAC,qBAAD,GAAuB,SAAC,SAAD;IACrB;WAEA,OAAO,CAAC,GAAR,CAAY,SAAS,CAAC,IAAV,EAAZ;EAHqB;;EAKvB,mBAAC,qBAAD,GAAuB,SAAC,sBAAD;IACrB,IAAG,cAAc,sBAAd,IAAyC,sBAAsB,CAAC,QAAvB,KAAmC,IAAI,CAAC,YAApF;MACE,yBAAyB,cAAc,CAAC,sBAAf,CAAsC,sBAAtC,EAD3B;;WAGA;EAJqB;;EAMvB,mBAAC,kBAAD,GAAoB,SAAC,sBAAD;IAClB,IAAG,cAAc,sBAAd,IAAyC,sBAAsB,CAAC,QAAvB,KAAmC,IAAI,CAAC,YAApF;MACE,yBAAyB,cAAc,CAAC,sBAAf,CAAsC,sBAAtC,EAD3B;;WAGA;EAJkB;;EAMpB,mBAAC,kBAAD,GAAoB;AAClB;IAAA,oBAAoB;IAEpB,EAAE,GAAF,CAAM,CAAC,IAAP,CAAY;aAAA,SAAC,CAAD,EAAI,OAAJ;AACV;QAAA,YAAY,cAAc,CAAC,sBAAf,CAAsC,OAAtC;QACZ,KAAc,SAAd;AAAA;;QACA,gBAAgB,KAAC,cAAD,CAAe,SAAf;QAChB,IAA4C,aAAiB,iBAAjB,oBAA5C;iBAAA,iBAAiB,CAAC,IAAlB,CAAuB,aAAvB;;MAJU;IAAA,QAAZ;AAMA;;MACE,IAAC,qBAAD,CAAsB,aAAtB;AADF;EATkB;;;;GAvBY;;;;;;;;;;;;;;;;;;;;ACClC,QAAQ,CAAC,IAAI,CAAC,gBAAd,GAAiC","file":"/packages/peerlibrary_blaze-components.js","sourcesContent":["Template = Blaze.Template\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of templating.js file wrapped into a condition.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__checkName) {\n  // Packages and apps add templates on to this object.\n\n  /**\n   * @summary The class for defining templates\n   * @class\n   * @instanceName Template.myTemplate\n   */\n  Template = Blaze.Template;\n\n  var RESERVED_TEMPLATE_NAMES = \"__proto__ name\".split(\" \");\n\n  // Check for duplicate template names and illegal names that won't work.\n  Template.__checkName = function (name) {\n    // Some names can't be used for Templates. These include:\n    //  - Properties Blaze sets on the Template object.\n    //  - Properties that some browsers don't let the code to set.\n    //    These are specified in RESERVED_TEMPLATE_NAMES.\n    if (name in Template || _.contains(RESERVED_TEMPLATE_NAMES, name)) {\n      if ((Template[name] instanceof Template) && name !== \"body\")\n        throw new Error(\"There are multiple templates named '\" + name + \"'. Each template needs a unique name.\");\n      throw new Error(\"This template name is reserved: \" + name);\n    }\n  };\n\n  // XXX COMPAT WITH 0.8.3\n  Template.__define__ = function (name, renderFunc) {\n    Template.__checkName(name);\n    Template[name] = new Template(\"Template.\" + name, renderFunc);\n    // Exempt packages built pre-0.9.0 from warnings about using old\n    // helper syntax, because we can.  It's not very useful to get a\n    // warning about someone else's code (like a package on Atmosphere),\n    // and this should at least put a bit of a dent in number of warnings\n    // that come from packages that haven't been updated lately.\n    Template[name]._NOWARN_OLDSTYLE_HELPERS = true;\n  };\n\n  // Define a template `Template.body` that renders its\n  // `contentRenderFuncs`.  `<body>` tags (of which there may be\n  // multiple) will have their contents added to it.\n\n  /**\n   * @summary The [template object](#templates_api) representing your `<body>`\n   * tag.\n   * @locus Client\n   */\n  Template.body = new Template('body', function () {\n    var view = this;\n    return _.map(Template.body.contentRenderFuncs, function (func) {\n      return func.apply(view);\n    });\n  });\n  Template.body.contentRenderFuncs = []; // array of Blaze.Views\n  Template.body.view = null;\n\n  Template.body.addContent = function (renderFunc) {\n    Template.body.contentRenderFuncs.push(renderFunc);\n  };\n\n  // This function does not use `this` and so it may be called\n  // as `Meteor.startup(Template.body.renderIntoDocument)`.\n  Template.body.renderToDocument = function () {\n    // Only do it once.\n    if (Template.body.view)\n      return;\n\n    var view = Blaze.render(Template.body, document.body);\n    Template.body.view = view;\n  };\n\n  // XXX COMPAT WITH 0.9.0\n  UI.body = Template.body;\n\n  // XXX COMPAT WITH 0.9.0\n  // (<body> tags in packages built with 0.9.0)\n  Template.__body__ = Template.body;\n  Template.__body__.__contentParts = Template.body.contentViews;\n  Template.__body__.__instantiate = Template.body.renderToDocument;\n}\n","\nTemplate.__checkName(\"__dynamicBackport\");\nTemplate[\"__dynamicBackport\"] = new Template(\"Template.__dynamicBackport\", (function() {\n  var view = this;\n  return [ Blaze.View(\"lookup:checkContext\", function() {\n    return Spacebars.mustache(view.lookup(\"checkContext\"));\n  }), \"\\n  \", Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"dataContextPresent\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n      return Blaze._InOuterTemplateScope(view, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(view.templateContentBlock);\n        });\n      });\n    }), \"\\n  \" ];\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return {\n        template: Spacebars.call(view.lookup(\"template\")),\n        data: Spacebars.call(view.lookup(\"..\"))\n      };\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  }) ];\n}));\n\nTemplate.__checkName(\"__dynamicWithDataContextBackport\");\nTemplate[\"__dynamicWithDataContextBackport\"] = new Template(\"Template.__dynamicWithDataContextBackport\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"chooseTemplate\"), view.lookup(\"template\"));\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"data\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"..\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  });\n}));\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of dynamic.js file wrapped into a condition with renaming of backported templates.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__dynamicWithDataContext) {\n  Blaze.Template.__dynamicWithDataContext = Blaze.Template.__dynamicWithDataContextBackport;\n  Blaze.Template.__dynamicWithDataContext.viewName = 'Template.__dynamicWithDataContext';\n  Blaze.Template.__dynamic = Blaze.Template.__dynamicBackport;\n  Blaze.Template.__dynamic.viewName = 'Template.__dynamic';\n\n  var Template = Blaze.Template;\n\n  /**\n   * @isTemplate true\n   * @memberOf Template\n   * @function dynamic\n   * @summary Choose a template to include dynamically, by name.\n   * @locus Templates\n   * @param {String} template The name of the template to include.\n   * @param {Object} [data] Optional. The data context in which to include the\n   * template.\n   */\n\n  Template.__dynamicWithDataContext.helpers({\n    chooseTemplate: function (name) {\n      return Blaze._getTemplate(name, function () {\n        return Template.instance();\n      });\n    }\n  });\n\n  Template.__dynamic.helpers({\n    dataContextPresent: function () {\n      return _.has(this, \"data\");\n    },\n    checkContext: function () {\n      if (!_.has(this, \"template\")) {\n        throw new Error(\"Must specify name in the 'template' argument \" +\n          \"to {{> Template.dynamic}}.\");\n      }\n\n      _.each(this, function (v, k) {\n        if (k !== \"template\" && k !== \"data\") {\n          throw new Error(\"Invalid argument to {{> Template.dynamic}}: \" +\n            k);\n        }\n      });\n    }\n  });\n}","/* This file backports Blaze lookup.js from Meteor 1.2 so that required Blaze features to support Blaze\n   Components are available also in older Meteor versions.\n   It is a copy of lookup.js file from Meteor 1.2 with lexical scope lookup commented out.\n\n   TODO: Remove this file eventually.\n */\n\n// Check if we are not running Meteor 1.2+.\nif (! Blaze._getTemplate) {\n  // If `x` is a function, binds the value of `this` for that function\n  // to the current data context.\n  var bindDataContext = function (x) {\n    if (typeof x === 'function') {\n      return function () {\n        var data = Blaze.getData();\n        if (data == null)\n          data = {};\n        return x.apply(data, arguments);\n      };\n    }\n    return x;\n  };\n\n  Blaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n    // XXX COMPAT WITH 0.9.3\n    var isKnownOldStyleHelper = false;\n\n    if (template.__helpers.has(name)) {\n      var helper = template.__helpers.get(name);\n      if (helper === Blaze._OLDSTYLE_HELPER) {\n        isKnownOldStyleHelper = true;\n      } else if (helper != null) {\n        return wrapHelper(bindDataContext(helper), tmplInstanceFunc);\n      } else {\n        return null;\n      }\n    }\n\n    // old-style helper\n    if (name in template) {\n      // Only warn once per helper\n      if (!isKnownOldStyleHelper) {\n        template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n        if (!template._NOWARN_OLDSTYLE_HELPERS) {\n          Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n            name + ' = ...` is deprecated.  Use `' + template.viewName +\n            '.helpers(...)` instead.');\n        }\n      }\n      if (template[name] != null) {\n        return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n      }\n    }\n\n    return null;\n  };\n\n  var wrapHelper = function (f, templateFunc) {\n    // XXX COMPAT WITH METEOR 1.0.3.2\n    if (!Blaze.Template._withTemplateInstanceFunc) {\n      return Blaze._wrapCatchingExceptions(f, 'template helper');\n    }\n\n    if (typeof f !== \"function\") {\n      return f;\n    }\n\n    return function () {\n      var self = this;\n      var args = arguments;\n\n      return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n        return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n      });\n    };\n  };\n\n  // templateInstance argument is provided to be available for possible\n  // alternative implementations of this function by 3rd party packages.\n  Blaze._getTemplate = function (name, templateInstance) {\n    if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {\n      return Blaze.Template[name];\n    }\n    return null;\n  };\n\n  Blaze._getGlobalHelper = function (name, templateInstance) {\n    if (Blaze._globalHelpers[name] != null) {\n      return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance);\n    }\n    return null;\n  };\n\n  Blaze.View.prototype.lookup = function (name, _options) {\n    var template = this.template;\n    var lookupTemplate = _options && _options.template;\n    var helper;\n    var binding;\n    var boundTmplInstance;\n    var foundTemplate;\n\n    if (this.templateInstance) {\n      boundTmplInstance = _.bind(this.templateInstance, this);\n    }\n\n    // 0. looking up the parent data context with the special \"../\" syntax\n    if (/^\\./.test(name)) {\n      // starts with a dot. must be a series of dots which maps to an\n      // ancestor of the appropriate height.\n      if (!/^(\\.)+$/.test(name))\n        throw new Error(\"id starting with dot must be a series of dots\");\n\n      return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n    }\n\n    // 1. look up a helper on the current template\n    if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {\n      return helper;\n    }\n\n    // 2. look up a binding by traversing the lexical view hierarchy inside the\n    // current template\n    /*if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n      return binding;\n    }*/\n\n    // 3. look up a template by name\n    if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {\n      return foundTemplate;\n    }\n\n    // 4. look up a global helper\n    if ((helper = Blaze._getGlobalHelper(name, boundTmplInstance)) != null) {\n      return helper;\n    }\n\n    // 5. look up in a data context\n    return function () {\n      var isCalledAsFunction = (arguments.length > 0);\n      var data = Blaze.getData();\n      var x = data && data[name];\n      if (!x) {\n        if (lookupTemplate) {\n          throw new Error(\"No such template: \" + name);\n        } else if (isCalledAsFunction) {\n          throw new Error(\"No such function: \" + name);\n        } /*else if (name.charAt(0) === '@' && ((x === null) ||\n          (x === undefined))) {\n          // Throw an error if the user tries to use a `@directive`\n          // that doesn't exist.  We don't implement all directives\n          // from Handlebars, so there's a potential for confusion\n          // if we fail silently.  On the other hand, we want to\n          // throw late in case some app or package wants to provide\n          // a missing directive.\n          throw new Error(\"Unsupported directive: \" + name);\n        }*/\n      }\n      if (!data) {\n        return null;\n      }\n      if (typeof x !== 'function') {\n        if (isCalledAsFunction) {\n          throw new Error(\"Can't call non-function: \" + x);\n        }\n        return x;\n      }\n      return x.apply(data, arguments);\n    };\n  };\n}","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of attrs.js file with the changes from the above pull request merged in.\n\n   TODO: Remove this file eventually.\n */\n\nvar jsUrlsAllowed = false;\nBlaze._allowJavascriptUrls = function () {\n  jsUrlsAllowed = true;\n};\nBlaze._javascriptUrlsAllowed = function () {\n  return jsUrlsAllowed;\n};\n\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\nBlaze._AttributeHandler = AttributeHandler;\n\nAttributeHandler.prototype.update = function (element, oldValue, value) {\n  if (value === null) {\n    if (oldValue !== null)\n      element.removeAttribute(this.name);\n  } else {\n    element.setAttribute(this.name, value);\n  }\n};\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"\n//\n// Each subclass must implement a parseValue method which takes a string\n// as an input and returns a dict of attributes. The keys of the dict\n// are unique identifiers (ie. css properties in the case of styles), and the\n// values are the entire attribute which will be injected into the element.\n//\n// Extended below to support classes, SVG elements and styles.\n\nBlaze._DiffingAttributeHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");\n\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};\n    var newAttrsMap = value ? this.parseValue(value) : {};\n\n    // the current attributes on the element, which we will mutate.\n\n    var attrString = this.getCurrentValue(element);\n    var attrsMap = attrString ? this.parseValue(attrString) : {};\n\n    _.each(_.keys(oldAttrsMap), function (t) {\n      if (! (t in newAttrsMap))\n        delete attrsMap[t];\n    });\n\n    _.each(_.keys(newAttrsMap), function (t) {\n      attrsMap[t] = newAttrsMap[t];\n    });\n\n    this.setValue(element, _.values(attrsMap).join(' '));\n  }\n});\n\nvar ClassHandler = Blaze._DiffingAttributeHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  },\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    _.each(attrString.split(' '), function(token) {\n      if (token)\n        tokens[token] = token;\n    });\n    return tokens;\n  }\n});\n\nvar SVGClassHandler = ClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar StyleHandler = Blaze._DiffingAttributeHandler.extend({\n  getCurrentValue: function (element) {\n    return element.getAttribute('style');\n  },\n  setValue: function (element, style) {\n    if (style === '') {\n      element.removeAttribute('style');\n    } else {\n      element.setAttribute('style', style);\n    }\n  },\n\n  // Parse a string to produce a map from property to attribute string.\n  //\n  // Example:\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    // Regex for parsing a css attribute declaration, taken from css-parse:\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\n    var match = regex.exec(attrString);\n    while (match) {\n      // match[0] = entire matching string\n      // match[1] = css property\n      // Prefix the token to prevent conflicts with existing properties.\n\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to\n      // remove strong dep on jquery.\n      tokens[' ' + match[1]] = match[0].trim ?\n        match[0].trim() : $.trim(match[0]);\n\n      match = regex.exec(attrString);\n    }\n\n    return tokens;\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar DOMPropertyHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value !== element[name])\n      element[name] = value;\n  }\n});\n\n// attributes of the type 'xlink:something' should be set using\n// the correct namespace in order to work\nvar XlinkHandler = AttributeHandler.extend({\n  update: function(element, oldValue, value) {\n    var NS = 'http://www.w3.org/1999/xlink';\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttributeNS(NS, this.name);\n    } else {\n      element.setAttributeNS(NS, this.name, this.value);\n    }\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\nvar isUrlAttribute = function (tagName, attrName) {\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\n  // and\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\n  var urlAttrs = {\n    FORM: ['action'],\n    BODY: ['background'],\n    BLOCKQUOTE: ['cite'],\n    Q: ['cite'],\n    DEL: ['cite'],\n    INS: ['cite'],\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\n    APPLET: ['codebase'],\n    A: ['href'],\n    AREA: ['href'],\n    LINK: ['href'],\n    BASE: ['href'],\n    IMG: ['longdesc', 'src', 'usemap'],\n    FRAME: ['longdesc', 'src'],\n    IFRAME: ['longdesc', 'src'],\n    HEAD: ['profile'],\n    SCRIPT: ['src'],\n    INPUT: ['src', 'usemap', 'formaction'],\n    BUTTON: ['formaction'],\n    BASE: ['href'],\n    MENUITEM: ['icon'],\n    HTML: ['manifest'],\n    VIDEO: ['poster']\n  };\n\n  if (attrName === 'itemid') {\n    return true;\n  }\n\n  var urlAttrNames = urlAttrs[tagName] || [];\n  return _.contains(urlAttrNames, attrName);\n};\n\n// To get the protocol for a URL, we let the browser normalize it for\n// us, by setting it as the href for an anchor tag and then reading out\n// the 'protocol' property.\nif (Meteor.isClient) {\n  var anchorForNormalization = document.createElement('A');\n}\n\nvar getUrlProtocol = function (url) {\n  if (Meteor.isClient) {\n    anchorForNormalization.href = url;\n    return (anchorForNormalization.protocol || \"\").toLowerCase();\n  } else {\n    throw new Error('getUrlProtocol not implemented on the server');\n  }\n};\n\n// UrlHandler is an attribute handler for all HTML attributes that take\n// URL values. It disallows javascript: URLs, unless\n// Blaze._allowJavascriptUrls() has been called. To detect javascript:\n// urls, we set the attribute on a dummy anchor element and then read\n// out the 'protocol' property of the attribute.\nvar origUpdate = AttributeHandler.prototype.update;\nvar UrlHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var self = this;\n    var args = arguments;\n\n    if (Blaze._javascriptUrlsAllowed()) {\n      origUpdate.apply(self, args);\n    } else {\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");\n      if (isJavascriptProtocol) {\n        Blaze._warn(\"URLs that use the 'javascript:' protocol are not \" +\n                    \"allowed in URL attribute values. \" +\n                    \"Call Blaze._allowJavascriptUrls() \" +\n                    \"to enable them.\");\n        origUpdate.apply(self, [element, oldValue, null]);\n      } else {\n        origUpdate.apply(self, args);\n      }\n    }\n  }\n});\n\n// XXX make it possible for users to register attribute handlers!\nBlaze._makeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'style') {\n    return new StyleHandler(name, value);\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\n             (elem.tagName === 'INPUT' && name === 'checked')) {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new DOMPropertyHandler(name, value);\n  } else if (name.substring(0,6) === 'xlink:') {\n    return new XlinkHandler(name.substring(6), value);\n  } else if (isUrlAttribute(elem.tagName, name)) {\n    return new UrlHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n\n\nElementAttributesUpdater = function (elem) {\n  this.elem = elem;\n  this.handlers = {};\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, whose\n// values are strings.\nElementAttributesUpdater.prototype.update = function(newAttrs) {\n  var elem = this.elem;\n  var handlers = this.handlers;\n\n  for (var k in handlers) {\n    if (! _.has(newAttrs, k)) {\n      // remove attributes (and handlers) for attribute names\n      // that don't exist as keys of `newAttrs` and so won't\n      // be visited when traversing it.  (Attributes that\n      // exist in the `newAttrs` object but are `null`\n      // are handled later.)\n      var handler = handlers[k];\n      var oldValue = handler.value;\n      handler.value = null;\n      handler.update(elem, oldValue, null);\n      delete handlers[k];\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if (! _.has(handlers, k)) {\n      if (value !== null) {\n        // make new handler\n        handler = Blaze._makeAttributeHandler(elem, k, value);\n        handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of the materializer.js file and is needed because it references symbols from attrs.js.\n\n   TODO: Remove this file eventually.\n */\n\n// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,\n                                  _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = (_existingWorkStack || []);\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n\n  if (! _existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n\n  return intoArray;\n};\n\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n\n  switch (typeof htmljs) {\n  case 'string': case 'boolean': case 'number':\n    intoArray.push(document.createTextNode(String(htmljs)));\n    return;\n  case 'object':\n    if (htmljs.htmljsType) {\n      switch (htmljs.htmljsType) {\n      case HTML.Tag.htmljsType:\n        intoArray.push(materializeTag(htmljs, parentView, workStack));\n        return;\n      case HTML.CharRef.htmljsType:\n        intoArray.push(document.createTextNode(htmljs.str));\n        return;\n      case HTML.Comment.htmljsType:\n        intoArray.push(document.createComment(htmljs.sanitizedValue));\n        return;\n      case HTML.Raw.htmljsType:\n        // Get an array of DOM nodes by using the browser's HTML parser\n        // (like innerHTML).\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n        for (var i = 0; i < nodes.length; i++)\n          intoArray.push(nodes[i]);\n        return;\n      }\n    } else if (HTML.isArray(htmljs)) {\n      for (var i = htmljs.length-1; i >= 0; i--) {\n        workStack.push(_.bind(Blaze._materializeDOM, null,\n                              htmljs[i], intoArray, parentView, workStack));\n      }\n      return;\n    } else {\n      if (htmljs instanceof Blaze.Template) {\n        htmljs = htmljs.constructView();\n        // fall through to Blaze.View case below\n      }\n      if (htmljs instanceof Blaze.View) {\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n        return;\n      }\n    }\n  }\n\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\n\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\n      && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length &&\n      ! (rawAttrs && ('value' in rawAttrs))) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' ||\n        HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\n                      \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = _.extend({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],\n                                              parentView,\n                                              HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation =\n        parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange)\n          x.attach(elem);\n        else\n          elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(_.bind(Blaze._materializeDOM, null,\n                          children, childNodesAndRanges, parentView,\n                          workStack));\n  }\n\n  return elem;\n};\n\n\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return (node.tagName === \"a\" &&\n          node.attrs &&\n          node.attrs[\"xlink:href\"] !== undefined);\n};\n","class BlazeComponentDebug extends BaseComponentDebug\n  @startComponent: (component) ->\n    super\n\n    console.log component.data()\n\n  @startMarkedComponent: (component) ->\n    super\n\n    console.log component.data()\n\n  @dumpComponentSubtree: (rootComponentOrElement) ->\n    if 'nodeType' of rootComponentOrElement and rootComponentOrElement.nodeType is Node.ELEMENT_NODE\n      rootComponentOrElement = BlazeComponent.getComponentForElement rootComponentOrElement\n\n    super\n\n  @dumpComponentTree: (rootComponentOrElement) ->\n    if 'nodeType' of rootComponentOrElement and rootComponentOrElement.nodeType is Node.ELEMENT_NODE\n      rootComponentOrElement = BlazeComponent.getComponentForElement rootComponentOrElement\n\n    super\n\n  @dumpAllComponents: ->\n    allRootComponents = []\n\n    $('*').each (i, element) =>\n      component = BlazeComponent.getComponentForElement element\n      return unless component\n      rootComponent = @componentRoot component\n      allRootComponents.push rootComponent unless rootComponent in allRootComponents\n\n    for rootComponent in allRootComponents\n      @dumpComponentSubtree rootComponent\n\n    return\n","# No-op on the server.\nTemplate.body.renderToDocument = ->\n"]}}]