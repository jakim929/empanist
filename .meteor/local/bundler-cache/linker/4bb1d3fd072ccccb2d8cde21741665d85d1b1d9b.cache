[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Picker = Package['meteorhacks:picker'].Picker;\n\n/* Package-scope variables */\nvar SearchSource;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/meteorhacks_search-source/lib/server.js                            //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nSearchSource = {};\nSearchSource._sources = {};\nvar bodyParser = Npm.require('body-parser');\n\nSearchSource.defineSource = function(name, callback) {\n  SearchSource._sources[name] = callback;\n};\n\nMeteor.methods({\n  \"search.source\": function(name, query, options) {\n    check(name, String);\n    check(query, Match.OneOf(String, null, undefined));\n    check(options, Match.OneOf(Object, null, undefined));\n    this.unblock();\n\n    // we need to send the context of the method\n    // that's why we use .call instead just invoking the function\n    return getSourceData.call(this, name, query, options);\n  }\n});\n\nvar postRoutes = Picker.filter(function(req, res) {\n  return req.method == \"POST\";\n});\n\npostRoutes.middleware(bodyParser.text({\n  type: \"text/ejson\"\n}));\n\npostRoutes.route('/_search-source', function(params, req, res, next) {\n  if(req.body) {\n    var payload = EJSON.parse(req.body);\n    try {\n      // supporting the use of Meteor.userId()\n      var data = DDP._CurrentInvocation.withValue({userId: null}, function() {\n        return getSourceData(payload.source, payload.query, payload.options);\n      });\n      sendData(res, null, data);\n    } catch(ex) {\n      if(ex instanceof Meteor.Error) {\n        var error = { code: ex.error, message: ex.reason };\n      } else {\n        var error = { message: ex.message };\n      }\n      sendData(res, error);\n    }\n  } else {\n    next();\n  }\n});\n\n\nfunction sendData(res, err, data) {\n  var payload = {\n    error: err,\n    data: data\n  };\n\n  res.end(EJSON.stringify(payload));\n}\n\nfunction getSourceData(name, query, options) {\n  var source = SearchSource._sources[name];\n  if(source) {\n    return source.call(this, query, options);\n  } else {\n    throw new Meteor.Error(404, \"No such search source: \" + name);\n  }\n}\n/////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['meteorhacks:search-source'] = {}, {\n  SearchSource: SearchSource\n});\n\n})();\n","servePath":"/packages/meteorhacks_search-source.js","sourceMap":{"version":3,"sources":["/packages/meteorhacks_search-source/lib/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"/packages/meteorhacks_search-source.js","sourcesContent":["SearchSource = {};\nSearchSource._sources = {};\nvar bodyParser = Npm.require('body-parser');\n\nSearchSource.defineSource = function(name, callback) {\n  SearchSource._sources[name] = callback;\n};\n\nMeteor.methods({\n  \"search.source\": function(name, query, options) {\n    check(name, String);\n    check(query, Match.OneOf(String, null, undefined));\n    check(options, Match.OneOf(Object, null, undefined));\n    this.unblock();\n\n    // we need to send the context of the method\n    // that's why we use .call instead just invoking the function\n    return getSourceData.call(this, name, query, options);\n  }\n});\n\nvar postRoutes = Picker.filter(function(req, res) {\n  return req.method == \"POST\";\n});\n\npostRoutes.middleware(bodyParser.text({\n  type: \"text/ejson\"\n}));\n\npostRoutes.route('/_search-source', function(params, req, res, next) {\n  if(req.body) {\n    var payload = EJSON.parse(req.body);\n    try {\n      // supporting the use of Meteor.userId()\n      var data = DDP._CurrentInvocation.withValue({userId: null}, function() {\n        return getSourceData(payload.source, payload.query, payload.options);\n      });\n      sendData(res, null, data);\n    } catch(ex) {\n      if(ex instanceof Meteor.Error) {\n        var error = { code: ex.error, message: ex.reason };\n      } else {\n        var error = { message: ex.message };\n      }\n      sendData(res, error);\n    }\n  } else {\n    next();\n  }\n});\n\n\nfunction sendData(res, err, data) {\n  var payload = {\n    error: err,\n    data: data\n  };\n\n  res.end(EJSON.stringify(payload));\n}\n\nfunction getSourceData(name, query, options) {\n  var source = SearchSource._sources[name];\n  if(source) {\n    return source.call(this, query, options);\n  } else {\n    throw new Meteor.Error(404, \"No such search source: \" + name);\n  }\n}"]}}]