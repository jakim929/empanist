{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_blaze-components/template.coffee","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/templating.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/template.dynamic.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/dynamic.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/lookup.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/attrs.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/compatibility/materializer.js","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/debug.coffee","meteor://ðŸ’»app/packages/peerlibrary_blaze-components/server.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAA,WAAW,KAAK,CAAC;;;;;;;;;;;;;;;;;;;ACAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMA;EAAA;;;;AAAM;;;;;;;EACJ,mBAAC,eAAD,GAAiB,SAAC,SAAD;IACf;WAEA,OAAO,CAAC,GAAR,CAAY,SAAS,CAAC,IAAV,EAAZ;EAHe;;EAKjB,mBAAC,qBAAD,GAAuB,SAAC,SAAD;IACrB;WAEA,OAAO,CAAC,GAAR,CAAY,SAAS,CAAC,IAAV,EAAZ;EAHqB;;EAKvB,mBAAC,qBAAD,GAAuB,SAAC,sBAAD;IACrB,IAAG,cAAc,sBAAd,IAAyC,sBAAsB,CAAC,QAAvB,KAAmC,IAAI,CAAC,YAApF;MACE,yBAAyB,cAAc,CAAC,sBAAf,CAAsC,sBAAtC,EAD3B;;WAGA;EAJqB;;EAMvB,mBAAC,kBAAD,GAAoB,SAAC,sBAAD;IAClB,IAAG,cAAc,sBAAd,IAAyC,sBAAsB,CAAC,QAAvB,KAAmC,IAAI,CAAC,YAApF;MACE,yBAAyB,cAAc,CAAC,sBAAf,CAAsC,sBAAtC,EAD3B;;WAGA;EAJkB;;EAMpB,mBAAC,kBAAD,GAAoB;AAClB;IAAA,oBAAoB;IAEpB,EAAE,GAAF,CAAM,CAAC,IAAP,CAAY;aAAA,SAAC,CAAD,EAAI,OAAJ;AACV;QAAA,YAAY,cAAc,CAAC,sBAAf,CAAsC,OAAtC;QACZ,KAAc,SAAd;AAAA;;QACA,gBAAgB,KAAC,cAAD,CAAe,SAAf;QAChB,IAA4C,aAAiB,iBAAjB,oBAA5C;iBAAA,iBAAiB,CAAC,IAAlB,CAAuB,aAAvB;;MAJU;IAAA,QAAZ;AAMA;;MACE,IAAC,qBAAD,CAAsB,aAAtB;AADF;EATkB;;;;GAvBY;;;;;;;;;;;;;;;;;;;;ACClC,QAAQ,CAAC,IAAI,CAAC,gBAAd,GAAiC","file":"/packages/peerlibrary_blaze-components.js","sourcesContent":["Template = Blaze.Template\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of templating.js file wrapped into a condition.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__checkName) {\n  // Packages and apps add templates on to this object.\n\n  /**\n   * @summary The class for defining templates\n   * @class\n   * @instanceName Template.myTemplate\n   */\n  Template = Blaze.Template;\n\n  var RESERVED_TEMPLATE_NAMES = \"__proto__ name\".split(\" \");\n\n  // Check for duplicate template names and illegal names that won't work.\n  Template.__checkName = function (name) {\n    // Some names can't be used for Templates. These include:\n    //  - Properties Blaze sets on the Template object.\n    //  - Properties that some browsers don't let the code to set.\n    //    These are specified in RESERVED_TEMPLATE_NAMES.\n    if (name in Template || _.contains(RESERVED_TEMPLATE_NAMES, name)) {\n      if ((Template[name] instanceof Template) && name !== \"body\")\n        throw new Error(\"There are multiple templates named '\" + name + \"'. Each template needs a unique name.\");\n      throw new Error(\"This template name is reserved: \" + name);\n    }\n  };\n\n  // XXX COMPAT WITH 0.8.3\n  Template.__define__ = function (name, renderFunc) {\n    Template.__checkName(name);\n    Template[name] = new Template(\"Template.\" + name, renderFunc);\n    // Exempt packages built pre-0.9.0 from warnings about using old\n    // helper syntax, because we can.  It's not very useful to get a\n    // warning about someone else's code (like a package on Atmosphere),\n    // and this should at least put a bit of a dent in number of warnings\n    // that come from packages that haven't been updated lately.\n    Template[name]._NOWARN_OLDSTYLE_HELPERS = true;\n  };\n\n  // Define a template `Template.body` that renders its\n  // `contentRenderFuncs`.  `<body>` tags (of which there may be\n  // multiple) will have their contents added to it.\n\n  /**\n   * @summary The [template object](#templates_api) representing your `<body>`\n   * tag.\n   * @locus Client\n   */\n  Template.body = new Template('body', function () {\n    var view = this;\n    return _.map(Template.body.contentRenderFuncs, function (func) {\n      return func.apply(view);\n    });\n  });\n  Template.body.contentRenderFuncs = []; // array of Blaze.Views\n  Template.body.view = null;\n\n  Template.body.addContent = function (renderFunc) {\n    Template.body.contentRenderFuncs.push(renderFunc);\n  };\n\n  // This function does not use `this` and so it may be called\n  // as `Meteor.startup(Template.body.renderIntoDocument)`.\n  Template.body.renderToDocument = function () {\n    // Only do it once.\n    if (Template.body.view)\n      return;\n\n    var view = Blaze.render(Template.body, document.body);\n    Template.body.view = view;\n  };\n\n  // XXX COMPAT WITH 0.9.0\n  UI.body = Template.body;\n\n  // XXX COMPAT WITH 0.9.0\n  // (<body> tags in packages built with 0.9.0)\n  Template.__body__ = Template.body;\n  Template.__body__.__contentParts = Template.body.contentViews;\n  Template.__body__.__instantiate = Template.body.renderToDocument;\n}\n","\nTemplate.__checkName(\"__dynamicBackport\");\nTemplate[\"__dynamicBackport\"] = new Template(\"Template.__dynamicBackport\", (function() {\n  var view = this;\n  return [ Blaze.View(\"lookup:checkContext\", function() {\n    return Spacebars.mustache(view.lookup(\"checkContext\"));\n  }), \"\\n  \", Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"dataContextPresent\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n      return Blaze._InOuterTemplateScope(view, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(view.templateContentBlock);\n        });\n      });\n    }), \"\\n  \" ];\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return {\n        template: Spacebars.call(view.lookup(\"template\")),\n        data: Spacebars.call(view.lookup(\"..\"))\n      };\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"__dynamicWithDataContext\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  }) ];\n}));\n\nTemplate.__checkName(\"__dynamicWithDataContextBackport\");\nTemplate[\"__dynamicWithDataContextBackport\"] = new Template(\"Template.__dynamicWithDataContextBackport\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"chooseTemplate\"), view.lookup(\"template\"));\n  }, function() {\n    return [ \"\\n    \\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"data\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"..\"), function() {\n        return Blaze._InOuterTemplateScope(view, function() {\n          return Spacebars.include(function() {\n            return Spacebars.call(view.templateContentBlock);\n          });\n        });\n      });\n    }), \"\\n  \" ];\n  });\n}));\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5903\n   If it is a copy of dynamic.js file wrapped into a condition with renaming of backported templates.\n\n   TODO: Remove this file eventually.\n */\n\nif (!Blaze.Template.__dynamicWithDataContext) {\n  Blaze.Template.__dynamicWithDataContext = Blaze.Template.__dynamicWithDataContextBackport;\n  Blaze.Template.__dynamicWithDataContext.viewName = 'Template.__dynamicWithDataContext';\n  Blaze.Template.__dynamic = Blaze.Template.__dynamicBackport;\n  Blaze.Template.__dynamic.viewName = 'Template.__dynamic';\n\n  var Template = Blaze.Template;\n\n  /**\n   * @isTemplate true\n   * @memberOf Template\n   * @function dynamic\n   * @summary Choose a template to include dynamically, by name.\n   * @locus Templates\n   * @param {String} template The name of the template to include.\n   * @param {Object} [data] Optional. The data context in which to include the\n   * template.\n   */\n\n  Template.__dynamicWithDataContext.helpers({\n    chooseTemplate: function (name) {\n      return Blaze._getTemplate(name, function () {\n        return Template.instance();\n      });\n    }\n  });\n\n  Template.__dynamic.helpers({\n    dataContextPresent: function () {\n      return _.has(this, \"data\");\n    },\n    checkContext: function () {\n      if (!_.has(this, \"template\")) {\n        throw new Error(\"Must specify name in the 'template' argument \" +\n          \"to {{> Template.dynamic}}.\");\n      }\n\n      _.each(this, function (v, k) {\n        if (k !== \"template\" && k !== \"data\") {\n          throw new Error(\"Invalid argument to {{> Template.dynamic}}: \" +\n            k);\n        }\n      });\n    }\n  });\n}","/* This file backports Blaze lookup.js from Meteor 1.2 so that required Blaze features to support Blaze\n   Components are available also in older Meteor versions.\n   It is a copy of lookup.js file from Meteor 1.2 with lexical scope lookup commented out.\n\n   TODO: Remove this file eventually.\n */\n\n// Check if we are not running Meteor 1.2+.\nif (! Blaze._getTemplate) {\n  // If `x` is a function, binds the value of `this` for that function\n  // to the current data context.\n  var bindDataContext = function (x) {\n    if (typeof x === 'function') {\n      return function () {\n        var data = Blaze.getData();\n        if (data == null)\n          data = {};\n        return x.apply(data, arguments);\n      };\n    }\n    return x;\n  };\n\n  Blaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n    // XXX COMPAT WITH 0.9.3\n    var isKnownOldStyleHelper = false;\n\n    if (template.__helpers.has(name)) {\n      var helper = template.__helpers.get(name);\n      if (helper === Blaze._OLDSTYLE_HELPER) {\n        isKnownOldStyleHelper = true;\n      } else if (helper != null) {\n        return wrapHelper(bindDataContext(helper), tmplInstanceFunc);\n      } else {\n        return null;\n      }\n    }\n\n    // old-style helper\n    if (name in template) {\n      // Only warn once per helper\n      if (!isKnownOldStyleHelper) {\n        template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n        if (!template._NOWARN_OLDSTYLE_HELPERS) {\n          Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n            name + ' = ...` is deprecated.  Use `' + template.viewName +\n            '.helpers(...)` instead.');\n        }\n      }\n      if (template[name] != null) {\n        return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n      }\n    }\n\n    return null;\n  };\n\n  var wrapHelper = function (f, templateFunc) {\n    // XXX COMPAT WITH METEOR 1.0.3.2\n    if (!Blaze.Template._withTemplateInstanceFunc) {\n      return Blaze._wrapCatchingExceptions(f, 'template helper');\n    }\n\n    if (typeof f !== \"function\") {\n      return f;\n    }\n\n    return function () {\n      var self = this;\n      var args = arguments;\n\n      return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n        return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n      });\n    };\n  };\n\n  // templateInstance argument is provided to be available for possible\n  // alternative implementations of this function by 3rd party packages.\n  Blaze._getTemplate = function (name, templateInstance) {\n    if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {\n      return Blaze.Template[name];\n    }\n    return null;\n  };\n\n  Blaze._getGlobalHelper = function (name, templateInstance) {\n    if (Blaze._globalHelpers[name] != null) {\n      return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance);\n    }\n    return null;\n  };\n\n  Blaze.View.prototype.lookup = function (name, _options) {\n    var template = this.template;\n    var lookupTemplate = _options && _options.template;\n    var helper;\n    var binding;\n    var boundTmplInstance;\n    var foundTemplate;\n\n    if (this.templateInstance) {\n      boundTmplInstance = _.bind(this.templateInstance, this);\n    }\n\n    // 0. looking up the parent data context with the special \"../\" syntax\n    if (/^\\./.test(name)) {\n      // starts with a dot. must be a series of dots which maps to an\n      // ancestor of the appropriate height.\n      if (!/^(\\.)+$/.test(name))\n        throw new Error(\"id starting with dot must be a series of dots\");\n\n      return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n    }\n\n    // 1. look up a helper on the current template\n    if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {\n      return helper;\n    }\n\n    // 2. look up a binding by traversing the lexical view hierarchy inside the\n    // current template\n    /*if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n      return binding;\n    }*/\n\n    // 3. look up a template by name\n    if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {\n      return foundTemplate;\n    }\n\n    // 4. look up a global helper\n    if ((helper = Blaze._getGlobalHelper(name, boundTmplInstance)) != null) {\n      return helper;\n    }\n\n    // 5. look up in a data context\n    return function () {\n      var isCalledAsFunction = (arguments.length > 0);\n      var data = Blaze.getData();\n      var x = data && data[name];\n      if (!x) {\n        if (lookupTemplate) {\n          throw new Error(\"No such template: \" + name);\n        } else if (isCalledAsFunction) {\n          throw new Error(\"No such function: \" + name);\n        } /*else if (name.charAt(0) === '@' && ((x === null) ||\n          (x === undefined))) {\n          // Throw an error if the user tries to use a `@directive`\n          // that doesn't exist.  We don't implement all directives\n          // from Handlebars, so there's a potential for confusion\n          // if we fail silently.  On the other hand, we want to\n          // throw late in case some app or package wants to provide\n          // a missing directive.\n          throw new Error(\"Unsupported directive: \" + name);\n        }*/\n      }\n      if (!data) {\n        return null;\n      }\n      if (typeof x !== 'function') {\n        if (isCalledAsFunction) {\n          throw new Error(\"Can't call non-function: \" + x);\n        }\n        return x;\n      }\n      return x.apply(data, arguments);\n    };\n  };\n}","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of attrs.js file with the changes from the above pull request merged in.\n\n   TODO: Remove this file eventually.\n */\n\nvar jsUrlsAllowed = false;\nBlaze._allowJavascriptUrls = function () {\n  jsUrlsAllowed = true;\n};\nBlaze._javascriptUrlsAllowed = function () {\n  return jsUrlsAllowed;\n};\n\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\nBlaze._AttributeHandler = AttributeHandler;\n\nAttributeHandler.prototype.update = function (element, oldValue, value) {\n  if (value === null) {\n    if (oldValue !== null)\n      element.removeAttribute(this.name);\n  } else {\n    element.setAttribute(this.name, value);\n  }\n};\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"\n//\n// Each subclass must implement a parseValue method which takes a string\n// as an input and returns a dict of attributes. The keys of the dict\n// are unique identifiers (ie. css properties in the case of styles), and the\n// values are the entire attribute which will be injected into the element.\n//\n// Extended below to support classes, SVG elements and styles.\n\nBlaze._DiffingAttributeHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");\n\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};\n    var newAttrsMap = value ? this.parseValue(value) : {};\n\n    // the current attributes on the element, which we will mutate.\n\n    var attrString = this.getCurrentValue(element);\n    var attrsMap = attrString ? this.parseValue(attrString) : {};\n\n    _.each(_.keys(oldAttrsMap), function (t) {\n      if (! (t in newAttrsMap))\n        delete attrsMap[t];\n    });\n\n    _.each(_.keys(newAttrsMap), function (t) {\n      attrsMap[t] = newAttrsMap[t];\n    });\n\n    this.setValue(element, _.values(attrsMap).join(' '));\n  }\n});\n\nvar ClassHandler = Blaze._DiffingAttributeHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  },\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    _.each(attrString.split(' '), function(token) {\n      if (token)\n        tokens[token] = token;\n    });\n    return tokens;\n  }\n});\n\nvar SVGClassHandler = ClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar StyleHandler = Blaze._DiffingAttributeHandler.extend({\n  getCurrentValue: function (element) {\n    return element.getAttribute('style');\n  },\n  setValue: function (element, style) {\n    if (style === '') {\n      element.removeAttribute('style');\n    } else {\n      element.setAttribute('style', style);\n    }\n  },\n\n  // Parse a string to produce a map from property to attribute string.\n  //\n  // Example:\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    // Regex for parsing a css attribute declaration, taken from css-parse:\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\n    var match = regex.exec(attrString);\n    while (match) {\n      // match[0] = entire matching string\n      // match[1] = css property\n      // Prefix the token to prevent conflicts with existing properties.\n\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to\n      // remove strong dep on jquery.\n      tokens[' ' + match[1]] = match[0].trim ?\n        match[0].trim() : $.trim(match[0]);\n\n      match = regex.exec(attrString);\n    }\n\n    return tokens;\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar DOMPropertyHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value !== element[name])\n      element[name] = value;\n  }\n});\n\n// attributes of the type 'xlink:something' should be set using\n// the correct namespace in order to work\nvar XlinkHandler = AttributeHandler.extend({\n  update: function(element, oldValue, value) {\n    var NS = 'http://www.w3.org/1999/xlink';\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttributeNS(NS, this.name);\n    } else {\n      element.setAttributeNS(NS, this.name, this.value);\n    }\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\nvar isUrlAttribute = function (tagName, attrName) {\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\n  // and\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\n  var urlAttrs = {\n    FORM: ['action'],\n    BODY: ['background'],\n    BLOCKQUOTE: ['cite'],\n    Q: ['cite'],\n    DEL: ['cite'],\n    INS: ['cite'],\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\n    APPLET: ['codebase'],\n    A: ['href'],\n    AREA: ['href'],\n    LINK: ['href'],\n    BASE: ['href'],\n    IMG: ['longdesc', 'src', 'usemap'],\n    FRAME: ['longdesc', 'src'],\n    IFRAME: ['longdesc', 'src'],\n    HEAD: ['profile'],\n    SCRIPT: ['src'],\n    INPUT: ['src', 'usemap', 'formaction'],\n    BUTTON: ['formaction'],\n    BASE: ['href'],\n    MENUITEM: ['icon'],\n    HTML: ['manifest'],\n    VIDEO: ['poster']\n  };\n\n  if (attrName === 'itemid') {\n    return true;\n  }\n\n  var urlAttrNames = urlAttrs[tagName] || [];\n  return _.contains(urlAttrNames, attrName);\n};\n\n// To get the protocol for a URL, we let the browser normalize it for\n// us, by setting it as the href for an anchor tag and then reading out\n// the 'protocol' property.\nif (Meteor.isClient) {\n  var anchorForNormalization = document.createElement('A');\n}\n\nvar getUrlProtocol = function (url) {\n  if (Meteor.isClient) {\n    anchorForNormalization.href = url;\n    return (anchorForNormalization.protocol || \"\").toLowerCase();\n  } else {\n    throw new Error('getUrlProtocol not implemented on the server');\n  }\n};\n\n// UrlHandler is an attribute handler for all HTML attributes that take\n// URL values. It disallows javascript: URLs, unless\n// Blaze._allowJavascriptUrls() has been called. To detect javascript:\n// urls, we set the attribute on a dummy anchor element and then read\n// out the 'protocol' property of the attribute.\nvar origUpdate = AttributeHandler.prototype.update;\nvar UrlHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var self = this;\n    var args = arguments;\n\n    if (Blaze._javascriptUrlsAllowed()) {\n      origUpdate.apply(self, args);\n    } else {\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");\n      if (isJavascriptProtocol) {\n        Blaze._warn(\"URLs that use the 'javascript:' protocol are not \" +\n                    \"allowed in URL attribute values. \" +\n                    \"Call Blaze._allowJavascriptUrls() \" +\n                    \"to enable them.\");\n        origUpdate.apply(self, [element, oldValue, null]);\n      } else {\n        origUpdate.apply(self, args);\n      }\n    }\n  }\n});\n\n// XXX make it possible for users to register attribute handlers!\nBlaze._makeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'style') {\n    return new StyleHandler(name, value);\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\n             (elem.tagName === 'INPUT' && name === 'checked')) {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new DOMPropertyHandler(name, value);\n  } else if (name.substring(0,6) === 'xlink:') {\n    return new XlinkHandler(name.substring(6), value);\n  } else if (isUrlAttribute(elem.tagName, name)) {\n    return new UrlHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n\n\nElementAttributesUpdater = function (elem) {\n  this.elem = elem;\n  this.handlers = {};\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, whose\n// values are strings.\nElementAttributesUpdater.prototype.update = function(newAttrs) {\n  var elem = this.elem;\n  var handlers = this.handlers;\n\n  for (var k in handlers) {\n    if (! _.has(newAttrs, k)) {\n      // remove attributes (and handlers) for attribute names\n      // that don't exist as keys of `newAttrs` and so won't\n      // be visited when traversing it.  (Attributes that\n      // exist in the `newAttrs` object but are `null`\n      // are handled later.)\n      var handler = handlers[k];\n      var oldValue = handler.value;\n      handler.value = null;\n      handler.update(elem, oldValue, null);\n      delete handlers[k];\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if (! _.has(handlers, k)) {\n      if (value !== null) {\n        // make new handler\n        handler = Blaze._makeAttributeHandler(elem, k, value);\n        handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n","/* This file is needed to backport this pull request: https://github.com/meteor/meteor/pull/5893\n   It is a copy of the materializer.js file and is needed because it references symbols from attrs.js.\n\n   TODO: Remove this file eventually.\n */\n\n// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,\n                                  _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = (_existingWorkStack || []);\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n\n  if (! _existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n\n  return intoArray;\n};\n\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n\n  switch (typeof htmljs) {\n  case 'string': case 'boolean': case 'number':\n    intoArray.push(document.createTextNode(String(htmljs)));\n    return;\n  case 'object':\n    if (htmljs.htmljsType) {\n      switch (htmljs.htmljsType) {\n      case HTML.Tag.htmljsType:\n        intoArray.push(materializeTag(htmljs, parentView, workStack));\n        return;\n      case HTML.CharRef.htmljsType:\n        intoArray.push(document.createTextNode(htmljs.str));\n        return;\n      case HTML.Comment.htmljsType:\n        intoArray.push(document.createComment(htmljs.sanitizedValue));\n        return;\n      case HTML.Raw.htmljsType:\n        // Get an array of DOM nodes by using the browser's HTML parser\n        // (like innerHTML).\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n        for (var i = 0; i < nodes.length; i++)\n          intoArray.push(nodes[i]);\n        return;\n      }\n    } else if (HTML.isArray(htmljs)) {\n      for (var i = htmljs.length-1; i >= 0; i--) {\n        workStack.push(_.bind(Blaze._materializeDOM, null,\n                              htmljs[i], intoArray, parentView, workStack));\n      }\n      return;\n    } else {\n      if (htmljs instanceof Blaze.Template) {\n        htmljs = htmljs.constructView();\n        // fall through to Blaze.View case below\n      }\n      if (htmljs instanceof Blaze.View) {\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n        return;\n      }\n    }\n  }\n\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\n\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\n      && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length &&\n      ! (rawAttrs && ('value' in rawAttrs))) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' ||\n        HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\n                      \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = _.extend({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],\n                                              parentView,\n                                              HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation =\n        parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange)\n          x.attach(elem);\n        else\n          elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(_.bind(Blaze._materializeDOM, null,\n                          children, childNodesAndRanges, parentView,\n                          workStack));\n  }\n\n  return elem;\n};\n\n\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return (node.tagName === \"a\" &&\n          node.attrs &&\n          node.attrs[\"xlink:href\"] !== undefined);\n};\n","class BlazeComponentDebug extends BaseComponentDebug\n  @startComponent: (component) ->\n    super\n\n    console.log component.data()\n\n  @startMarkedComponent: (component) ->\n    super\n\n    console.log component.data()\n\n  @dumpComponentSubtree: (rootComponentOrElement) ->\n    if 'nodeType' of rootComponentOrElement and rootComponentOrElement.nodeType is Node.ELEMENT_NODE\n      rootComponentOrElement = BlazeComponent.getComponentForElement rootComponentOrElement\n\n    super\n\n  @dumpComponentTree: (rootComponentOrElement) ->\n    if 'nodeType' of rootComponentOrElement and rootComponentOrElement.nodeType is Node.ELEMENT_NODE\n      rootComponentOrElement = BlazeComponent.getComponentForElement rootComponentOrElement\n\n    super\n\n  @dumpAllComponents: ->\n    allRootComponents = []\n\n    $('*').each (i, element) =>\n      component = BlazeComponent.getComponentForElement element\n      return unless component\n      rootComponent = @componentRoot component\n      allRootComponents.push rootComponent unless rootComponent in allRootComponents\n\n    for rootComponent in allRootComponents\n      @dumpComponentSubtree rootComponent\n\n    return\n","# No-op on the server.\nTemplate.body.renderToDocument = ->\n"]}