{"version":3,"sources":["meteor://ðŸ’»app/packages/meteorhacks_search-source/lib/client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+F","file":"/packages/meteorhacks_search-source.js","sourcesContent":["SearchSource = function SearchSource(source, fields, options) {\n  this.source = source;\n  this.searchFields = fields;\n  this.currentQuery = null;\n  this.options = options || {};\n\n  this.status =  new ReactiveVar({loaded: true});\n  this.metaData = new ReactiveVar({});\n  this.history = {};\n  this.store = new Mongo.Collection(null);\n\n  this._storeDep = new Tracker.Dependency();\n  this._currentQueryDep = new Tracker.Dependency();\n  this._currentVersion = 0;\n  this._loadedVersion = 0;\n}\n\nSearchSource.prototype._loadData = function(query, options) {\n  var self = this;\n  var version = 0;\n  var historyKey = query + EJSON.stringify(options);\n  if(this._canUseHistory(historyKey)) {\n    this._updateStore(this.history[historyKey].data);\n    this.metaData.set(this.history[historyKey].metadata);\n    self._storeDep.changed();\n  } else {\n    this.status.set({loading: true});\n    version = ++this._currentVersion;\n    this._fetch(this.source, query, options, handleData);\n  }\n\n  function handleData(err, payload) {\n    if(err) {\n      self.status.set({error: err});\n      throw err;\n    } else {\n      if(payload instanceof Array) {\n        var data = payload;\n        var metadata = {};\n      } else {\n        var data = payload.data;\n        var metadata = payload.metadata;\n        self.metaData.set(payload.metadata || {});\n      }\n\n      if(self.options.keepHistory) {\n        self.history[historyKey] = {data: data, loaded: new Date(), metadata: metadata};\n      }\n\n      if(version > self._loadedVersion) {\n        self._updateStore(data);\n        self._loadedVersion = version;\n      }\n\n      if(version == self._currentVersion) {\n        self.status.set({loaded: true});\n      }\n\n      self._storeDep.changed();\n    }\n  }\n};\n\nSearchSource.prototype._canUseHistory = function(historyKey) {\n  var historyItem = this.history[historyKey];\n  if(this.options.keepHistory && historyItem) {\n    var diff = Date.now() - historyItem.loaded.getTime();\n    return diff < this.options.keepHistory;\n  }\n\n  return false;\n};\n\nSearchSource.prototype._updateStore = function(data) {\n  var self = this;\n  var storeIds = _.pluck(this.store.find().fetch(), \"_id\");\n  var currentIds = [];\n  data.forEach(function(item) {\n    currentIds.push(item._id);\n    self.store.update(item._id, item, {upsert: true});\n  });\n\n  // Remove items in client DB that we no longer need\n  var currentIdMappings  = {};\n  _.each(currentIds, function(currentId) {\n    // to support Object Ids\n    var str = (currentId._str)? currentId._str : currentId;\n    currentIdMappings[str] = true;\n  });\n\n  _.each(storeIds, function(storeId) {\n    // to support Object Ids\n    var str = (storeId._str)? storeId._str : storeId;\n    if(!currentIdMappings[str]) {\n      self.store.remove(storeId);\n    }\n  });\n};\n\nSearchSource.prototype.search = function(query, options) {\n  this.currentQuery = query;\n  this._currentQueryDep.changed();\n\n  this._loadData(query, options);\n\n  if(this.options.localSearch) {\n    this._storeDep.changed();\n  }\n};\n\nSearchSource.prototype.getData = function(options, getCursor) {\n  options = options || {};\n  var self = this;\n  this._storeDep.depend();\n  var selector = {$or: []};\n\n  var regExp = this._buildRegExp(self.currentQuery);\n\n  // only do client side searching if we are on the loading state\n  // once loaded, we need to send all of them\n  if(this.getStatus().loading) {\n    self.searchFields.forEach(function(field) {\n      var singleQuery = {};\n      singleQuery[field] = regExp;\n      selector['$or'].push(singleQuery);\n    });\n  } else {\n    selector = {};\n  }\n\n  function transform(doc) {\n    if(options.transform) {\n      self.searchFields.forEach(function(field) {\n        if(self.currentQuery && doc[field]) {\n          doc[field] = options.transform(doc[field], regExp, field, self.currentQuery);\n        }\n      });\n    }\n    if(options.docTransform) {\n      return options.docTransform(doc);\n    }\n\n    return doc;\n  }\n\n  var cursor = this.store.find(selector, {\n    sort: options.sort,\n    limit: options.limit,\n    transform: transform\n  });\n\n  if(getCursor) {\n    return cursor;\n  }\n\n  return cursor.fetch();\n};\n\nSearchSource.prototype._fetch = function(source, query, options, callback) {\n  if(typeof this.fetchData == 'function') {\n    this.fetchData(query, options, callback);\n  } else if(Meteor.status().connected) {\n    this._fetchDDP.apply(this, arguments);\n  } else {\n    this._fetchHttp.apply(this, arguments);\n  }\n};\n\nSearchSource.prototype._fetchDDP = function(source, query, options, callback) {\n  Meteor.call(\"search.source\", this.source, query, options, callback);\n};\n\nSearchSource.prototype._fetchHttp = function(source, query, options, callback) {\n  var payload = {\n    source: source,\n    query: query,\n    options: options\n  };\n\n  var headers = {\n    \"Content-Type\": \"text/ejson\"\n  };\n\n  HTTP.post('/_search-source', {\n    content: EJSON.stringify(payload),\n    headers: headers\n  }, function(err, res) {\n    if(err) {\n      callback(err);\n    } else {\n      var response = EJSON.parse(res.content);\n      if(response.error) {\n        callback(response.error);\n      } else {\n        callback(null, response.data);\n      }\n    }\n  });\n};\n\nSearchSource.prototype.getMetadata = function() {\n  return this.metaData.get();\n};\n\nSearchSource.prototype.getCurrentQuery = function() {\n  this._currentQueryDep.depend();\n  return this.currentQuery;\n}\n\nSearchSource.prototype.getStatus = function() {\n  return this.status.get();\n};\n\nSearchSource.prototype.cleanHistory = function() {\n  this.history = {};\n};\n\nSearchSource.prototype._buildRegExp = function(query) {\n  query = query || \"\";\n\n  var afterFilteredRegExpChars = query.replace(this._getRegExpFilterRegExp(), \"\\\\$&\");\n  var parts = afterFilteredRegExpChars.trim().split(' ');\n\n  return new RegExp(\"(\" + parts.join('|') + \")\", \"ig\");\n};\n\nSearchSource.prototype._getRegExpFilterRegExp = _.once(function() {\n  var regExpChars = [\n    \"\\\\\", \"^\", \"$\", \"*\", \"+\", \"?\", \".\",\n     \"(\", \")\", \":\", \"|\", \"{\", \"}\", \"[\", \"]\",\n     \"=\", \"!\", \",\"\n  ];\n  var regExpCharsReplace = _.map(regExpChars, function(c) {\n    return \"\\\\\" + c;\n  }).join(\"|\");\n  return new RegExp(\"(\" + regExpCharsReplace + \")\", \"g\");\n});"]}